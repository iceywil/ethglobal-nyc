import { ChainDatum, Environment, PermitVariant, Universe } from "@arcana/ca-common";
import { DirectSecp256k1Wallet } from "@cosmjs/proto-signing";
import Decimal from "decimal.js";
import { ByteArray, Hex, WalletClient } from "viem";
import { ChainList } from "./chains";
import { FeeStore } from "./utils";
export type AddChainParams = {
    blockExplorerUrls?: string[];
    chainId: string;
    chainName: string;
    iconUrls?: string[];
    nativeCurrency: {
        decimals: number;
        name: string;
        symbol: string;
    };
    rpcUrls: string[];
};
export type AllowanceHookSources = onAllowanceHookSource[];
export type AssetBalanceResponse = {
    balance: string;
    chain_id: number;
    token_address: Uint8Array;
    value: string;
};
export type BridgeInput = {
    amount: number;
    symbol: string;
};
export type BridgeQueryInput = {
    amount: number | string;
    chainID: number;
    gas?: bigint;
    token: string;
};
export interface CA {
    createEVMHandler(tx: EVMTransaction, s: {
        bridge: boolean;
        gas: bigint;
        skipTx: boolean;
    }): Promise<CreateHandlerResponse | null>;
    getChainID(): Promise<number>;
    init(): Promise<void>;
    switchChain(chainID: number): Promise<void>;
}
export type Chain = {
    blockExplorers?: {
        default: {
            name: string;
            url: string;
        };
    };
    custom: {
        icon: string;
        knownTokens: TokenInfo[];
    };
    id: number;
    name: string;
    nativeCurrency: {
        decimals: number;
        name: string;
        symbol: string;
    };
    rpcUrls: {
        default: {
            http: string[];
            publicHttp?: string[];
            webSocket: string[];
        };
    };
    universe: Universe;
};
export interface CreateHandlerResponse {
    handler: IRequestHandler | null;
    processTx: () => Promise<unknown>;
}
export interface EthereumProvider {
    on(eventName: string | symbol, listener: (...args: any[]) => void): this;
    removeListener(eventName: string | symbol, listener: (...args: any[]) => void): this;
    request(args: RequestArguments): Promise<unknown>;
}
export type EVMTransaction = {
    data?: `0x${string}`;
    from: `0x${string}`;
    to: `0x${string}`;
    value?: `0x${string}`;
};
export type FeeStoreData = {
    fee: {
        collection: {
            chainID: number;
            fee: number;
            tokenAddress: string;
            universe: Universe;
        }[];
        fulfilment: {
            chainID: number;
            fee: number;
            tokenAddress: string;
            universe: Universe;
        }[];
        protocol: {
            feeBP: string;
        };
    };
    solverRoutes: {
        destinationChainID: number;
        destinationTokenAddress: string;
        destinationUniverse: Universe;
        feeBP: number;
        sourceChainID: number;
        sourceTokenAddress: string;
        sourceUniverse: Universe;
    }[];
};
export type FeeUniverse = "ETHEREUM" | "FUEL";
export type Intent = {
    destination: IntentDestination;
    fees: {
        caGas: string;
        collection: string;
        fulfilment: string;
        gasSupplied: string;
        protocol: string;
        solver: string;
    };
    isAvailableBalanceInsufficient: boolean;
    sources: IntentSource[];
};
export type IntentDestination = {
    amount: Decimal;
    chainID: number;
    decimals: number;
    gas: bigint;
    tokenContract: `0x${string}`;
    universe: Universe;
};
export type IntentSource = {
    amount: Decimal;
    chainID: number;
    tokenContract: `0x${string}`;
    universe: Universe;
};
export type IntentSourceForAllowance = {
    chainID: number;
    currentAllowance: bigint;
    requiredAllowance: bigint;
    token: TokenInfo;
};
export interface IRequestHandler {
    buildIntent(): Promise<{
        intent: Intent;
        token: TokenInfo;
    } | undefined>;
    process(): Promise<unknown>;
}
export type Network = Extract<Environment, Environment.CERISE | Environment.CORAL | Environment.FOLLY>;
export type NetworkConfig = {
    COSMOS_URL: string;
    EXPLORER_URL: string;
    FAUCET_URL: string;
    GRPC_URL: string;
    NETWORK_HINT: Environment;
    SIMULATION_URL: string;
    VSC_DOMAIN: string;
};
export type OnAllowanceHook = (data: {
    allow: (s: Array<"max" | "min" | bigint | string>) => void;
    deny: () => void;
    sources: AllowanceHookSources;
}) => void;
export type onAllowanceHookSource = {
    allowance: {
        current: string;
        minimum: string;
    };
    chain: {
        id: number;
        logo: string;
        name: string;
    };
    token: {
        contractAddress: `0x${string}`;
        decimals: number;
        logo: string;
        name: string;
        symbol: string;
    };
};
export type OnIntentHook = (data: {
    allow: () => void;
    deny: () => void;
    intent: ReadableIntent;
    refresh: () => Promise<ReadableIntent>;
}) => void;
export type OraclePriceResponse = {
    chainId: number;
    priceUsd: Decimal;
    tokenAddress: `0x${string}`;
    tokensPerUsd: Decimal;
}[];
export type ReadableIntent = {
    destination: {
        amount: string;
        chainID: number;
        chainLogo: string | undefined;
        chainName: string;
    };
    fees: {
        caGas: string;
        gasSupplied: string;
        protocol: string;
        solver: string;
        total: string;
    };
    sources: {
        amount: string;
        chainID: number;
        chainLogo: string | undefined;
        chainName: string;
        contractAddress: `0x${string}`;
    }[];
    sourcesTotal: string;
    token: {
        decimals: number;
        logo: string | undefined;
        name: string;
        symbol: string;
    };
};
export type RequestArguments = {
    readonly method: string;
    readonly params?: object | readonly unknown[];
};
export type RequestHandler = new (i: RequestHandlerInput) => IRequestHandler;
export type RequestHandlerInput = {
    chain: Chain;
    chainList: ChainList;
    cosmosWallet: DirectSecp256k1Wallet;
    evm: {
        address: `0x${string}`;
        client: WalletClient;
        tx: EVMTransaction;
    };
    hooks: {
        onAllowance: OnAllowanceHook;
        onIntent: OnIntentHook;
    };
    options: {
        bridge: boolean;
        emit: (eventName: string, ...args: any[]) => void;
        gas: bigint;
        networkConfig: NetworkConfig;
        skipTx: boolean;
    };
};
export type RequestHandlerResponse = {
    buildIntent(): Promise<{
        intent: Intent;
        token: TokenInfo;
    } | undefined>;
    input: RequestHandlerInput;
    process(): Promise<unknown>;
} | null;
export type RFF = {
    deposited: boolean;
    destinationChainID: number;
    destinations: {
        tokenAddress: Hex;
        value: bigint;
    }[];
    destinationUniverse: string;
    expiry: number;
    fulfilled: boolean;
    id: number;
    refunded: boolean;
    sources: {
        chainID: number;
        tokenAddress: Hex;
        universe: string;
        value: bigint;
    }[];
};
export type SDKConfig = {
    debug?: boolean;
    network?: Network | NetworkConfig;
    siweStatement?: string;
};
export type SetAllowanceInput = {
    amount: bigint;
    chainID: number;
    tokenContract: `0x${string}`;
};
export type SimulateReturnType = {
    amount: Decimal;
    gas: bigint;
    gasFee: Decimal;
    token: {
        contractAddress: `0x${string}`;
        decimals: number;
        name: string;
        symbol: string;
    };
};
export type SimulationResultData = {
    amount: number;
    gasBreakdown: {
        feeData: {
            maxFeePerGas: string;
            maxPriorityFeePerGas: string;
        };
        limit: string;
    };
    gasUsed: string;
    tokenContract: `0x${string}`;
};
export type SponsoredApprovalData = {
    address: ByteArray;
    chain_id: ChainDatum["ChainID32"];
    operations: {
        sig_r: ByteArray;
        sig_s: ByteArray;
        sig_v: number;
        token_address: ByteArray;
        value: ByteArray;
        variant: PermitVariant;
    }[];
    universe: Universe;
};
export type SponsoredApprovalDataArray = SponsoredApprovalData[];
export type Step = {
    data?: {
        amount: string;
        chainName: string;
        symbol: string;
    } | {
        chainID: number;
        chainName: string;
    } | {
        confirmed: number;
        total: number;
    } | {
        explorerURL: string;
        intentID: number;
    };
} & StepInfo;
export type StepInfo = {
    type: string;
    typeID: string;
};
export type Steps = Step[];
export type Token = {
    contractAddress: `0x${string}`;
    decimals: number;
    name: string;
    symbol: string;
};
export type TokenInfo = {
    contractAddress: `0x${string}`;
    decimals: number;
    logo?: string;
    name: string;
    symbol: string;
};
export type TransferQueryInput = {
    to: Hex;
} & Omit<BridgeQueryInput, "gas">;
export type TxOptions = {
    bridge: boolean;
    gas: bigint;
    skipTx: boolean;
};
export type UnifiedBalanceResponseData = {
    chain_id: Uint8Array;
    currencies: {
        balance: string;
        token_address: Uint8Array;
        value: string;
    }[];
    total_usd: string;
    universe: Universe;
};
export type UserAssetDatum = {
    abstracted?: boolean;
    balance: string;
    balanceInFiat: number;
    breakdown: {
        balance: string;
        balanceInFiat: number;
        chain: {
            id: number;
            logo: string;
            name: string;
        };
        contractAddress: `0x${string}`;
        decimals: number;
        isNative?: boolean;
        universe: Universe;
    }[];
    decimals: number;
    icon?: string;
    symbol: string;
};
export declare class UserAsset {
    value: UserAssetDatum;
    get balance(): string;
    constructor(value: UserAssetDatum);
    getBalanceOnChain(chainID: number, tokenAddress?: `0x${string}`): string;
    isDeposit(tokenAddress: `0x${string}`, universe: Universe): boolean;
    iterate(feeStore: FeeStore): {
        balance: Decimal;
        chainID: number;
        tokenContract: `0x${string}`;
        universe: Universe;
    }[];
}
export declare class UserAssets {
    data: UserAssetDatum[];
    constructor(data: UserAssetDatum[]);
    add(asset: UserAssetDatum): void;
    find(symbol: string): UserAsset;
    findOnChain(chainID: number, address: `0x${string}`): UserAssetDatum | undefined;
    getAssetDetails(chain: Chain, address: `0x${string}`): {
        asset: UserAssetDatum;
        chainsWithBalance: number;
        destinationAssetBalance: string;
        destinationGasBalance: string;
    };
    getBalanceInFiat(): number;
    getChainCountWithBalance(asset?: UserAssetDatum): number;
    getNativeBalance(chain: Chain): string;
    sort(): void;
    [Symbol.iterator](): ArrayIterator<UserAssetDatum>;
}
