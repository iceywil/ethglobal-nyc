import { equalFold, getAllowance, setAllowances } from "../utils";
class AllowanceQuery {
    constructor(walletClient, networkConfig, chainList) {
        this.walletClient = walletClient;
        this.networkConfig = networkConfig;
        this.chainList = chainList;
    }
    async get(input) {
        const addresses = await this.walletClient.getAddresses();
        if (!addresses.length) {
            throw new Error("No account connected with wallet client");
        }
        const address = addresses[0];
        const tokens = input.tokens ?? ["USDT", "USDC"];
        const chainID = input.chainID
            ? [input.chainID]
            : this.chainList.chains.map((c) => c.id);
        const inp = [];
        const out = [];
        for (const c of chainID) {
            for (const t of tokens) {
                const token = this.chainList.getTokenInfoBySymbol(c, t);
                if (token) {
                    const chain = this.chainList.getChainByID(c);
                    if (!chain) {
                        throw new Error("chain not supported");
                    }
                    inp.push(getAllowance(chain, address, token.contractAddress, this.chainList).then((val) => {
                        out.push({
                            allowance: val,
                            chainID: c,
                            token: t,
                        });
                    }));
                }
            }
        }
        return Promise.all(inp).then(() => out);
    }
    async revoke(input) {
        await this.set({ ...input, amount: 0n });
    }
    async set(input) {
        if (input.tokens == null) {
            throw new Error("missing token param");
        }
        if (input.amount == null) {
            throw new Error("missing amount param");
        }
        if (input.chainID == null) {
            throw new Error("missing chainID param");
        }
        const chain = this.chainList.getChainByID(input.chainID);
        if (!chain) {
            throw new Error("chain not supported");
        }
        let chainID = await this.walletClient.getChainId();
        if (input.chainID && input.chainID !== chainID) {
            await this.walletClient.switchChain({
                id: input.chainID,
            });
            chainID = input.chainID;
        }
        const tokenAddresses = [];
        for (const t of input.tokens) {
            const token = chain.custom.knownTokens.find((kt) => equalFold(kt.symbol, t));
            if (token) {
                tokenAddresses.push(token.contractAddress);
            }
        }
        if (!tokenAddresses.length) {
            throw new Error("None of the supplied token symbols are recognised on this chain");
        }
        await setAllowances(tokenAddresses, this.walletClient, this.networkConfig, this.chainList, chain, input.amount);
    }
}
export { AllowanceQuery };
