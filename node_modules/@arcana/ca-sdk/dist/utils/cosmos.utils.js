import { createCosmosClient, MsgCreateRequestForFundsResponse, MsgRefundReq, MsgRefundReqResponse, } from "@arcana/ca-common";
import { isDeliverTxFailure, isDeliverTxSuccess } from "@cosmjs/stargate";
import axios from "axios";
import { getLogger } from "../logger";
import { vscCreateFeeGrant } from "./api.utils";
const logger = getLogger();
const getCosmosURL = (cosmosURL, kind) => {
    const u = new URL(cosmosURL);
    if (kind === "rpc") {
        // FIXME: don't hardcode port here
        u.port = "26650";
    }
    return u.toString();
};
const cosmosFeeGrant = async (cosmosURL, vscDomain, address) => {
    try {
        await axios.get(`/cosmos/auth/v1beta1/accounts/${address}`, {
            baseURL: getCosmosURL(cosmosURL, "rest"),
        });
    }
    catch (e) {
        logger.error("Requesting a fee grant", e);
        const response = await vscCreateFeeGrant(vscDomain, address);
        logger.debug("Fee grant response", response.data);
        return;
    }
};
const cosmosCreateRFF = async ({ address, cosmosURL, msg, wallet, }) => {
    const client = await createCosmosClient(wallet, getCosmosURL(cosmosURL, "rpc"), {
        broadcastPollIntervalMs: 250,
    });
    try {
        const res = await client.signAndBroadcast(address, [
            {
                typeUrl: "/xarchain.chainabstraction.MsgCreateRequestForFunds",
                value: msg,
            },
        ], {
            amount: [],
            gas: 100000n.toString(10),
        });
        if (isDeliverTxFailure(res)) {
            throw new Error(`Error creating RFF â€“ code=${res.code} log=${res.rawLog ?? "n/a"}`);
        }
        const decoded = MsgCreateRequestForFundsResponse.decode(res.msgResponses[0].value);
        return decoded.id;
    }
    finally {
        client.disconnect();
    }
};
const cosmosRefundIntent = async (cosmosURL, intentID, wallet) => {
    const address = (await wallet.getAccounts())[0].address;
    const client = await createCosmosClient(wallet, getCosmosURL(cosmosURL, "rpc"), {
        broadcastPollIntervalMs: 250,
    });
    try {
        const resp = await client.signAndBroadcast(address, [
            {
                typeUrl: "/xarchain.chainabstraction.MsgRefundReq",
                value: MsgRefundReq.create({
                    creator: address,
                    rffID: intentID,
                }),
            },
        ], {
            amount: [],
            gas: 100000n.toString(10),
        });
        logger.debug("Refund response", { resp });
        try {
            if (isDeliverTxSuccess(resp)) {
                const decoded = MsgRefundReqResponse.decode(resp.msgResponses[0].value);
                logger.debug("Refund success", { decoded, resp });
                return resp;
            }
            else if (resp.code === 18) {
                if (resp.rawLog?.includes("RFF already refunded") ||
                    resp.rawLog?.includes("RFF already filled")) {
                    return resp;
                }
                throw new Error("RFF is not expired yet.");
            }
            else {
                // unknown error
            }
        }
        catch (e) {
            logger.error("Refund failed", e);
            throw e;
        }
    }
    finally {
        client.disconnect();
    }
};
const cosmosCreateDoubleCheckTx = async ({ address, cosmosURL, msg, wallet, }) => {
    const client = await createCosmosClient(wallet, getCosmosURL(cosmosURL, "rpc"), {
        broadcastPollIntervalMs: 250,
    });
    try {
        logger.debug("cosmosCreateDoubleCheckTx", { doubleCheckMsg: msg });
        const res = await client.signAndBroadcast(address, [
            {
                typeUrl: "/xarchain.chainabstraction.MsgDoubleCheckTx",
                value: msg,
            },
        ], {
            amount: [],
            gas: 100000n.toString(10),
        });
        if (isDeliverTxFailure(res)) {
            throw new Error("Error creating MsgDoubleCheckTx");
        }
        logger.debug("double check response", { doubleCheckTx: res });
    }
    finally {
        client.disconnect();
    }
};
export { cosmosCreateDoubleCheckTx, cosmosCreateRFF, cosmosFeeGrant, cosmosRefundIntent, };
