"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Currency = exports.CurrencyID = void 0;
const tslib_1 = require("tslib");
const viem_1 = require("viem");
const decimal_js_1 = tslib_1.__importDefault(require("decimal.js"));
const utils_1 = require("./utils");
var CurrencyID;
(function (CurrencyID) {
    CurrencyID[CurrencyID["USDC"] = 1] = "USDC";
    CurrencyID[CurrencyID["USDT"] = 2] = "USDT";
    CurrencyID[CurrencyID["ETH"] = 3] = "ETH";
    CurrencyID[CurrencyID["POL"] = 4] = "POL";
    CurrencyID[CurrencyID["AVAX"] = 5] = "AVAX";
    CurrencyID[CurrencyID["HYPE"] = 16] = "HYPE";
    CurrencyID[CurrencyID["KAIA"] = 17] = "KAIA";
})(CurrencyID || (exports.CurrencyID = CurrencyID = {}));
class Currency {
    currencyID;
    decimals;
    permitVariant;
    permitContractVersion;
    isGasToken;
    // this is always 32 byte long
    tokenAddress;
    /* This is the ratio between one unit to the smallest unit used.
  
       For example, USDC, which has a ‘decimals’ value of 6, is designed so that 1 USDC = 10⁶ μUSDC, which is the smallest indivisible amount representable.
     */
    oneUnitToAtomicUnitRatio;
    constructor(currencyID, tokenAddress, decimals, permitVariant, permitContractVersion = 0, isGasToken) {
        this.currencyID = currencyID;
        this.decimals = decimals;
        this.permitVariant = permitVariant;
        this.permitContractVersion = permitContractVersion;
        this.isGasToken = isGasToken;
        if (typeof tokenAddress === 'string') {
            this.tokenAddress = (0, utils_1.zeroExtendBufToGivenSize)((0, viem_1.toBytes)(tokenAddress), 32);
        }
        else if (tokenAddress instanceof Uint8Array) {
            this.tokenAddress = (0, utils_1.zeroExtendBufToGivenSize)(tokenAddress, 32);
        }
        else if (Array.isArray(tokenAddress) && tokenAddress.length >= 1 && typeof tokenAddress[0] === 'number') {
            this.tokenAddress = (0, utils_1.zeroExtendBufToGivenSize)(Buffer.from(tokenAddress), 32);
        }
        this.oneUnitToAtomicUnitRatio = decimal_js_1.default.pow(10, decimals);
    }
    convertUnitsToAmountDecimal(input) {
        let rawunits;
        if (typeof input === 'bigint') {
            rawunits = input.toString(10);
        }
        else if (typeof input === 'number') {
            rawunits = input.toString();
        }
        else if (input instanceof Uint8Array) {
            rawunits = (0, viem_1.bytesToBigInt)(input).toString(10);
        }
        else if (typeof input === 'string') {
            rawunits = input;
        }
        else {
            throw new Error('Invalid input');
        }
        return decimal_js_1.default.div(rawunits, this.oneUnitToAtomicUnitRatio);
    }
    convertAmountToUnitsInBinary(input) {
        return Buffer.from((0, viem_1.toBytes)(input.mul(this.oneUnitToAtomicUnitRatio).ceil().toHex()));
    }
}
exports.Currency = Currency;
