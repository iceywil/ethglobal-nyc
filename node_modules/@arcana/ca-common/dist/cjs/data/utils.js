"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertToBufferIfNecessary = convertToBufferIfNecessary;
exports.zeroExtendBufToGivenSize = zeroExtendBufToGivenSize;
exports.ezPadTo32Hex = ezPadTo32Hex;
exports.convertDecimalToBigInt = convertDecimalToBigInt;
exports.convertBigIntToDecimal = convertBigIntToDecimal;
exports.maxByBigInt = maxByBigInt;
exports.minByByBigInt = minByByBigInt;
const tslib_1 = require("tslib");
const viem_1 = require("viem");
const decimal_js_1 = tslib_1.__importDefault(require("decimal.js"));
function convertToBufferIfNecessary(buf) {
    return Buffer.isBuffer(buf) ? buf : Buffer.from(buf);
}
function zeroExtendBufToGivenSize(buf, size = 32) {
    if (buf.length === size) {
        return convertToBufferIfNecessary(buf);
    }
    if (buf.length > size) {
        return convertToBufferIfNecessary(buf.subarray(0, size));
    }
    const out = Buffer.alloc(size);
    out.set(buf, size - buf.length);
    return out;
}
function ezPadTo32Hex(input) {
    return (0, viem_1.pad)(typeof input !== "string" ? (0, viem_1.toHex)(input) : input, {
        dir: "left",
        size: 32,
    });
}
function convertDecimalToBigInt(dec) {
    return BigInt(dec.ceil().toFixed());
}
function convertBigIntToDecimal(big) {
    return new decimal_js_1.default(big.toString(10));
}
function maxByBigInt(items, getValue) {
    return items.reduce((m, e) => getValue(e) > getValue(m) ? e : m);
}
function minByByBigInt(items, getValue) {
    return items.reduce((m, e) => getValue(e) < getValue(m) ? e : m);
}
