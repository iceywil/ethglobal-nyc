"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiFiAggregator = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importStar(require("axios"));
const viem_1 = require("viem");
const iface_1 = require("./iface");
const definition_1 = require("../proto/definition");
class LiFiAggregator {
    static BASE_URL_V1 = "https://li.quest/v1";
    static COMMON_OPTIONS = {
        denyExchanges: "openocean",
        slippage: "0.01",
    };
    axios;
    constructor(apiKey) {
        this.axios = axios_1.default.create({
            baseURL: LiFiAggregator.BASE_URL_V1,
            headers: {
                "x-lifi-api-key": apiKey,
            },
        });
    }
    async getQuotes(requests) {
        const list = await Promise.allSettled(requests.map(async (r) => {
            if (r.chain.universe !== definition_1.Universe.ETHEREUM) {
                return null;
            }
            let respPromise;
            const chIDStr = r.chain.chainID.toString();
            const inputTokenAddr = (0, viem_1.getAddress)((0, viem_1.bytesToHex)(r.inputToken.subarray(12)));
            const outputTokenAddr = (0, viem_1.getAddress)((0, viem_1.bytesToHex)(r.outputToken.subarray(12)));
            const userAddrHex = (0, viem_1.getAddress)((0, viem_1.bytesToHex)(r.userAddress.subarray(12)));
            const receiverAddrHex = r.receiverAddress != null
                ? (0, viem_1.getAddress)((0, viem_1.bytesToHex)(r.receiverAddress.subarray(12)))
                : userAddrHex;
            switch (r.type) {
                case iface_1.QuoteType.ExactIn: {
                    respPromise = this.axios({
                        method: "GET",
                        url: "/quote",
                        params: {
                            fromChain: chIDStr,
                            toChain: chIDStr,
                            fromToken: inputTokenAddr,
                            toToken: outputTokenAddr,
                            fromAddress: userAddrHex,
                            toAddress: receiverAddrHex,
                            fromAmount: r.inputAmount.toString(),
                            ...LiFiAggregator.COMMON_OPTIONS,
                        },
                    });
                    break;
                }
                case iface_1.QuoteType.ExactOut: {
                    respPromise = this.axios({
                        method: "GET",
                        url: "/quote/toAmount",
                        params: {
                            fromChain: chIDStr,
                            toChain: chIDStr,
                            fromToken: inputTokenAddr,
                            toToken: outputTokenAddr,
                            fromAddress: userAddrHex,
                            toAddress: receiverAddrHex,
                            toAmount: r.outputAmount.toString(),
                            ...LiFiAggregator.COMMON_OPTIONS,
                        },
                    });
                    break;
                }
            }
            let resp;
            try {
                resp = await respPromise;
            }
            catch (e) {
                if (e instanceof axios_1.AxiosError && e.isAxiosError) {
                    if (e.response?.status === 404 &&
                        e.response.data.code === 1002 &&
                        e.response.data.message ===
                            "No available quotes for the requested transfer") {
                        return null;
                    }
                }
                throw e;
            }
            return {
                type: r.type,
                inputAmount: BigInt(resp.data.estimate.fromAmount),
                outputAmountMinimum: BigInt(resp.data.estimate.toAmountMin),
                outputAmountLikely: BigInt(resp.data.estimate.toAmount),
                originalResponse: resp.data,
            };
        }));
        return list.map((item) => {
            switch (item.status) {
                case "fulfilled": {
                    return item.value;
                }
                case "rejected": {
                    console.error("Caught error in fetching LiFi quotes:", item.reason);
                    return null;
                }
            }
        });
    }
}
exports.LiFiAggregator = LiFiAggregator;
