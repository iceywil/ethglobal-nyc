"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.YieldYakAggregator = void 0;
const viem_1 = require("viem");
const es_toolkit_1 = require("es-toolkit");
const iface_1 = require("./iface");
const data_1 = require("../data");
const definition_1 = require("../proto/definition");
const yakaggregator_evm_abi_1 = require("../data/yakaggregator.evm.abi");
const YakAggregatorAddresses = new Map([
    [(0, data_1.encodeChainID36)(definition_1.Universe.ETHEREUM, 42161), '0xb32C79a25291265eF240Eb32E9faBbc6DcEE3cE3'],
    [(0, data_1.encodeChainID36)(definition_1.Universe.ETHEREUM, 10), '0xCd887F78c77b36B0b541E77AfD6F91C0253182A2'],
    [(0, data_1.encodeChainID36)(definition_1.Universe.ETHEREUM, 43114), '0xC4729E56b831d74bBc18797e0e17A295fA77488c'],
].map(([chainID, addr]) => {
    return [(0, viem_1.bytesToHex)(chainID), addr];
}));
class YieldYakAggregator {
    clients = new Map();
    constructor(clients) {
        for (const client of clients) {
            const chainIDHex = (0, viem_1.bytesToHex)(client.chainID.toBytes());
            const aggAddr = YakAggregatorAddresses.get(chainIDHex);
            if (aggAddr == null) {
                continue;
            }
            this.clients.set(chainIDHex, {
                chainID: client.chainID,
                client: client.client,
                aggregatorAddress: aggAddr
            });
        }
    }
    async getQuotes(_requests) {
        const requestsWithOriginalIndexes = _requests.map((r, rid) => {
            return {
                req: r,
                idx: rid,
            };
        });
        const responses = new Array(_requests.length).fill(null);
        // it's so sad that JS doesn't have a proper binary data type
        const groupedByChainID = (0, es_toolkit_1.groupBy)(requestsWithOriginalIndexes, r => (0, viem_1.bytesToHex)(r.req.chain.toBytes()));
        await Promise.all(Array.from(Object.entries(groupedByChainID)).map(async ([chainIDHex, requests]) => {
            const config = this.clients.get(chainIDHex);
            if (config == null) {
                return;
            }
            const reverseIndexes = [];
            const mc3calls = [];
            for (const req of requests) {
                const inputTokenHex = (0, viem_1.bytesToHex)(req.req.inputToken.subarray(12));
                const outputTokenHex = (0, viem_1.bytesToHex)(req.req.outputToken.subarray(12));
                let args;
                switch (req.req.type) {
                    case iface_1.QuoteType.ExactIn: {
                        args = [req.req.inputAmount, inputTokenHex, outputTokenHex, 0, 1];
                        break;
                    }
                    case iface_1.QuoteType.ExactOut: {
                        args = [req.req.outputAmount, outputTokenHex, inputTokenHex, 0, 1];
                        break;
                    }
                }
                const indexes = [];
                for (let steps = 1; steps !== 5; steps++) {
                    const clonedArgs = (0, es_toolkit_1.clone)(args);
                    clonedArgs[3] = steps;
                    const idx = mc3calls.push({
                        address: config.aggregatorAddress,
                        abi: yakaggregator_evm_abi_1.YakAggregatorEVMABI,
                        functionName: 'findBestPathWithGas',
                        args: clonedArgs
                    });
                    indexes.push(idx - 1);
                }
                reverseIndexes.push([req, indexes]);
            }
            const _final = await config.client.multicall({
                allowFailure: false,
                contracts: mc3calls,
                multicallAddress: '0xcA11bde05977b3631167028862bE2a173976CA11'
            });
            for (const [req, indexes] of reverseIndexes) {
                const collected = [];
                for (const index of indexes) {
                    collected.push(_final[index]);
                }
                // @ts-expect-error the typing in maxBy is wrong, it can work with anything that is comparable
                const optimalChoice = (0, es_toolkit_1.maxBy)(collected, route => (0, es_toolkit_1.last)(route.amounts));
                if (optimalChoice.path.length === 0) {
                    responses[req.idx] = null;
                    return;
                }
                // we have to reverse everything
                if (req.req.type === iface_1.QuoteType.ExactOut) {
                    optimalChoice.adapters.reverse();
                    optimalChoice.amounts.reverse();
                    optimalChoice.path.reverse();
                }
                const output = (0, es_toolkit_1.last)(optimalChoice.amounts);
                responses[req.idx] = {
                    type: req.req.type,
                    inputAmount: optimalChoice.amounts[0],
                    outputAmountLikely: output,
                    outputAmountMinimum: output,
                    offer: optimalChoice
                };
            }
        }));
        return responses;
    }
}
exports.YieldYakAggregator = YieldYakAggregator;
