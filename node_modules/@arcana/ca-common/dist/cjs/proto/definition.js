"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.31.0
// source: definition.proto
Object.defineProperty(exports, "__esModule", { value: true });
exports.FillVEPacket = exports.DepositVEPacket = exports.MsgRefundReqResponse = exports.MsgRefundReq = exports.QueryGetPriceOracleDataResponse = exports.QueryGetPriceOracleDataRequest = exports.PriceOracleData = exports.PriceOracleDatum = exports.MsgUpdateProtocolFeesResponse = exports.MsgUpdateProtocolFees = exports.MsgCreateProtocolFeesResponse = exports.MsgCreateProtocolFees = exports.QueryGetProtocolFeesResponse = exports.QueryGetProtocolFeesRequest = exports.ProtocolFees = exports.AdminFeeRecipient = exports.FixedFeeTuple = exports.QueryRequestForFundsByAddressRequest = exports.QueryAllSettlementResponse = exports.QueryAllSettlementRequest = exports.QueryGetSettlementResponse = exports.QueryGetSettlementRequest = exports.Settlement = exports.MsgUpdateSolverDataResponse = exports.MsgUpdateSolverData = exports.MsgCreateSolverDataResponse = exports.MsgCreateSolverData = exports.QueryAllSolverDataResponse = exports.QueryAllSolverDataRequest = exports.QueryGetSolverDataResponse = exports.QueryGetSolverDataRequest = exports.SolverData = exports.SolverAddress = exports.RouteFee = exports.QueryAllRequestForFundsResponse = exports.QueryAllRequestForFundsRequest = exports.QueryGetRequestForFundsResponse = exports.QueryGetRequestForFundsRequest = exports.MsgCreateRequestForFundsResponse = exports.MsgCreateRequestForFunds = exports.RequestForFunds = exports.RFFDestinationPair = exports.SignatureDatum = exports.RFFSourcePair = exports.PageResponse = exports.PageRequest = exports.Universe = exports.CollectionFeeRequirement = exports.RFFSourceState = exports.protobufPackage = void 0;
exports.MsgDoubleCheckTx = void 0;
exports.rFFSourceStateFromJSON = rFFSourceStateFromJSON;
exports.rFFSourceStateToJSON = rFFSourceStateToJSON;
exports.collectionFeeRequirementFromJSON = collectionFeeRequirementFromJSON;
exports.collectionFeeRequirementToJSON = collectionFeeRequirementToJSON;
exports.universeFromJSON = universeFromJSON;
exports.universeToJSON = universeToJSON;
const tslib_1 = require("tslib");
/* eslint-disable */
const wire_1 = require("@bufbuild/protobuf/wire");
const long_1 = tslib_1.__importDefault(require("long"));
exports.protobufPackage = "";
var RFFSourceState;
(function (RFFSourceState) {
    RFFSourceState[RFFSourceState["WAITING"] = 0] = "WAITING";
    RFFSourceState[RFFSourceState["DEPOSITED"] = 1] = "DEPOSITED";
    RFFSourceState[RFFSourceState["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(RFFSourceState || (exports.RFFSourceState = RFFSourceState = {}));
function rFFSourceStateFromJSON(object) {
    switch (object) {
        case 0:
        case "WAITING":
            return RFFSourceState.WAITING;
        case 1:
        case "DEPOSITED":
            return RFFSourceState.DEPOSITED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return RFFSourceState.UNRECOGNIZED;
    }
}
function rFFSourceStateToJSON(object) {
    switch (object) {
        case RFFSourceState.WAITING:
            return "WAITING";
        case RFFSourceState.DEPOSITED:
            return "DEPOSITED";
        case RFFSourceState.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
var CollectionFeeRequirement;
(function (CollectionFeeRequirement) {
    CollectionFeeRequirement[CollectionFeeRequirement["UNDETERMINED"] = 0] = "UNDETERMINED";
    CollectionFeeRequirement[CollectionFeeRequirement["YES"] = 1] = "YES";
    CollectionFeeRequirement[CollectionFeeRequirement["NO"] = 2] = "NO";
    CollectionFeeRequirement[CollectionFeeRequirement["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CollectionFeeRequirement || (exports.CollectionFeeRequirement = CollectionFeeRequirement = {}));
function collectionFeeRequirementFromJSON(object) {
    switch (object) {
        case 0:
        case "UNDETERMINED":
            return CollectionFeeRequirement.UNDETERMINED;
        case 1:
        case "YES":
            return CollectionFeeRequirement.YES;
        case 2:
        case "NO":
            return CollectionFeeRequirement.NO;
        case -1:
        case "UNRECOGNIZED":
        default:
            return CollectionFeeRequirement.UNRECOGNIZED;
    }
}
function collectionFeeRequirementToJSON(object) {
    switch (object) {
        case CollectionFeeRequirement.UNDETERMINED:
            return "UNDETERMINED";
        case CollectionFeeRequirement.YES:
            return "YES";
        case CollectionFeeRequirement.NO:
            return "NO";
        case CollectionFeeRequirement.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
var Universe;
(function (Universe) {
    Universe[Universe["ETHEREUM"] = 0] = "ETHEREUM";
    Universe[Universe["FUEL"] = 1] = "FUEL";
    Universe[Universe["SOLANA"] = 2] = "SOLANA";
    Universe[Universe["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Universe || (exports.Universe = Universe = {}));
function universeFromJSON(object) {
    switch (object) {
        case 0:
        case "ETHEREUM":
            return Universe.ETHEREUM;
        case 1:
        case "FUEL":
            return Universe.FUEL;
        case 2:
        case "SOLANA":
            return Universe.SOLANA;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Universe.UNRECOGNIZED;
    }
}
function universeToJSON(object) {
    switch (object) {
        case Universe.ETHEREUM:
            return "ETHEREUM";
        case Universe.FUEL:
            return "FUEL";
        case Universe.SOLANA:
            return "SOLANA";
        case Universe.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBasePageRequest() {
    return {
        key: new Uint8Array(0),
        offset: long_1.default.UZERO,
        limit: long_1.default.UZERO,
        countTotal: false,
        reverse: false,
    };
}
exports.PageRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key.length !== 0) {
            writer.uint32(10).bytes(message.key);
        }
        if (!message.offset.equals(long_1.default.UZERO)) {
            writer.uint32(16).uint64(message.offset.toString());
        }
        if (!message.limit.equals(long_1.default.UZERO)) {
            writer.uint32(24).uint64(message.limit.toString());
        }
        if (message.countTotal !== false) {
            writer.uint32(32).bool(message.countTotal);
        }
        if (message.reverse !== false) {
            writer.uint32(40).bool(message.reverse);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePageRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.offset = long_1.default.fromString(reader.uint64().toString(), true);
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.limit = long_1.default.fromString(reader.uint64().toString(), true);
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.countTotal = reader.bool();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.reverse = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0),
            offset: isSet(object.offset) ? long_1.default.fromValue(object.offset) : long_1.default.UZERO,
            limit: isSet(object.limit) ? long_1.default.fromValue(object.limit) : long_1.default.UZERO,
            countTotal: isSet(object.countTotal)
                ? globalThis.Boolean(object.countTotal)
                : false,
            reverse: isSet(object.reverse)
                ? globalThis.Boolean(object.reverse)
                : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key.length !== 0) {
            obj.key = base64FromBytes(message.key);
        }
        if (!message.offset.equals(long_1.default.UZERO)) {
            obj.offset = (message.offset || long_1.default.UZERO).toString();
        }
        if (!message.limit.equals(long_1.default.UZERO)) {
            obj.limit = (message.limit || long_1.default.UZERO).toString();
        }
        if (message.countTotal !== false) {
            obj.countTotal = message.countTotal;
        }
        if (message.reverse !== false) {
            obj.reverse = message.reverse;
        }
        return obj;
    },
    create(base) {
        return exports.PageRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePageRequest();
        message.key = object.key ?? new Uint8Array(0);
        message.offset =
            object.offset !== undefined && object.offset !== null
                ? long_1.default.fromValue(object.offset)
                : long_1.default.UZERO;
        message.limit =
            object.limit !== undefined && object.limit !== null
                ? long_1.default.fromValue(object.limit)
                : long_1.default.UZERO;
        message.countTotal = object.countTotal ?? false;
        message.reverse = object.reverse ?? false;
        return message;
    },
};
function createBasePageResponse() {
    return { nextKey: new Uint8Array(0), total: long_1.default.UZERO };
}
exports.PageResponse = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.nextKey.length !== 0) {
            writer.uint32(10).bytes(message.nextKey);
        }
        if (!message.total.equals(long_1.default.UZERO)) {
            writer.uint32(16).uint64(message.total.toString());
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePageResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.nextKey = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.total = long_1.default.fromString(reader.uint64().toString(), true);
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            nextKey: isSet(object.nextKey)
                ? bytesFromBase64(object.nextKey)
                : new Uint8Array(0),
            total: isSet(object.total) ? long_1.default.fromValue(object.total) : long_1.default.UZERO,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.nextKey.length !== 0) {
            obj.nextKey = base64FromBytes(message.nextKey);
        }
        if (!message.total.equals(long_1.default.UZERO)) {
            obj.total = (message.total || long_1.default.UZERO).toString();
        }
        return obj;
    },
    create(base) {
        return exports.PageResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePageResponse();
        message.nextKey = object.nextKey ?? new Uint8Array(0);
        message.total =
            object.total !== undefined && object.total !== null
                ? long_1.default.fromValue(object.total)
                : long_1.default.UZERO;
        return message;
    },
};
function createBaseRFFSourcePair() {
    return {
        universe: 0,
        chainID: new Uint8Array(0),
        tokenAddress: new Uint8Array(0),
        value: new Uint8Array(0),
        status: 0,
        collectionFeeRequired: 0,
    };
}
exports.RFFSourcePair = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.universe !== 0) {
            writer.uint32(8).int32(message.universe);
        }
        if (message.chainID.length !== 0) {
            writer.uint32(18).bytes(message.chainID);
        }
        if (message.tokenAddress.length !== 0) {
            writer.uint32(26).bytes(message.tokenAddress);
        }
        if (message.value.length !== 0) {
            writer.uint32(34).bytes(message.value);
        }
        if (message.status !== 0) {
            writer.uint32(40).int32(message.status);
        }
        if (message.collectionFeeRequired !== 0) {
            writer.uint32(48).int32(message.collectionFeeRequired);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRFFSourcePair();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.universe = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.chainID = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.tokenAddress = reader.bytes();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.value = reader.bytes();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.status = reader.int32();
                    continue;
                }
                case 6: {
                    if (tag !== 48) {
                        break;
                    }
                    message.collectionFeeRequired = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
            chainID: isSet(object.chainID)
                ? bytesFromBase64(object.chainID)
                : new Uint8Array(0),
            tokenAddress: isSet(object.tokenAddress)
                ? bytesFromBase64(object.tokenAddress)
                : new Uint8Array(0),
            value: isSet(object.value)
                ? bytesFromBase64(object.value)
                : new Uint8Array(0),
            status: isSet(object.status) ? rFFSourceStateFromJSON(object.status) : 0,
            collectionFeeRequired: isSet(object.collectionFeeRequired)
                ? collectionFeeRequirementFromJSON(object.collectionFeeRequired)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.universe !== 0) {
            obj.universe = universeToJSON(message.universe);
        }
        if (message.chainID.length !== 0) {
            obj.chainID = base64FromBytes(message.chainID);
        }
        if (message.tokenAddress.length !== 0) {
            obj.tokenAddress = base64FromBytes(message.tokenAddress);
        }
        if (message.value.length !== 0) {
            obj.value = base64FromBytes(message.value);
        }
        if (message.status !== 0) {
            obj.status = rFFSourceStateToJSON(message.status);
        }
        if (message.collectionFeeRequired !== 0) {
            obj.collectionFeeRequired = collectionFeeRequirementToJSON(message.collectionFeeRequired);
        }
        return obj;
    },
    create(base) {
        return exports.RFFSourcePair.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRFFSourcePair();
        message.universe = object.universe ?? 0;
        message.chainID = object.chainID ?? new Uint8Array(0);
        message.tokenAddress = object.tokenAddress ?? new Uint8Array(0);
        message.value = object.value ?? new Uint8Array(0);
        message.status = object.status ?? 0;
        message.collectionFeeRequired = object.collectionFeeRequired ?? 0;
        return message;
    },
};
function createBaseSignatureDatum() {
    return {
        universe: 0,
        address: new Uint8Array(0),
        signature: new Uint8Array(0),
        hash: new Uint8Array(0),
    };
}
exports.SignatureDatum = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.universe !== 0) {
            writer.uint32(8).int32(message.universe);
        }
        if (message.address.length !== 0) {
            writer.uint32(18).bytes(message.address);
        }
        if (message.signature.length !== 0) {
            writer.uint32(26).bytes(message.signature);
        }
        if (message.hash.length !== 0) {
            writer.uint32(34).bytes(message.hash);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignatureDatum();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.universe = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.address = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.signature = reader.bytes();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.hash = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
            address: isSet(object.address)
                ? bytesFromBase64(object.address)
                : new Uint8Array(0),
            signature: isSet(object.signature)
                ? bytesFromBase64(object.signature)
                : new Uint8Array(0),
            hash: isSet(object.hash)
                ? bytesFromBase64(object.hash)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.universe !== 0) {
            obj.universe = universeToJSON(message.universe);
        }
        if (message.address.length !== 0) {
            obj.address = base64FromBytes(message.address);
        }
        if (message.signature.length !== 0) {
            obj.signature = base64FromBytes(message.signature);
        }
        if (message.hash.length !== 0) {
            obj.hash = base64FromBytes(message.hash);
        }
        return obj;
    },
    create(base) {
        return exports.SignatureDatum.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSignatureDatum();
        message.universe = object.universe ?? 0;
        message.address = object.address ?? new Uint8Array(0);
        message.signature = object.signature ?? new Uint8Array(0);
        message.hash = object.hash ?? new Uint8Array(0);
        return message;
    },
};
function createBaseRFFDestinationPair() {
    return { tokenAddress: new Uint8Array(0), value: new Uint8Array(0) };
}
exports.RFFDestinationPair = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.tokenAddress.length !== 0) {
            writer.uint32(10).bytes(message.tokenAddress);
        }
        if (message.value.length !== 0) {
            writer.uint32(18).bytes(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRFFDestinationPair();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.tokenAddress = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            tokenAddress: isSet(object.tokenAddress)
                ? bytesFromBase64(object.tokenAddress)
                : new Uint8Array(0),
            value: isSet(object.value)
                ? bytesFromBase64(object.value)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.tokenAddress.length !== 0) {
            obj.tokenAddress = base64FromBytes(message.tokenAddress);
        }
        if (message.value.length !== 0) {
            obj.value = base64FromBytes(message.value);
        }
        return obj;
    },
    create(base) {
        return exports.RFFDestinationPair.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRFFDestinationPair();
        message.tokenAddress = object.tokenAddress ?? new Uint8Array(0);
        message.value = object.value ?? new Uint8Array(0);
        return message;
    },
};
function createBaseRequestForFunds() {
    return {
        id: long_1.default.UZERO,
        sources: [],
        destinationChainID: new Uint8Array(0),
        destinations: [],
        nonce: new Uint8Array(0),
        expiry: long_1.default.UZERO,
        destinationUniverse: 0,
        signatureData: [],
        user: "",
        fulfilledBy: new Uint8Array(0),
        fulfilledAt: long_1.default.UZERO,
        deposited: false,
        fulfilled: false,
        settled: false,
        refunded: false,
        creationBlock: long_1.default.ZERO,
    };
}
exports.RequestForFunds = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (!message.id.equals(long_1.default.UZERO)) {
            writer.uint32(8).uint64(message.id.toString());
        }
        for (const v of message.sources) {
            exports.RFFSourcePair.encode(v, writer.uint32(18).fork()).join();
        }
        if (message.destinationChainID.length !== 0) {
            writer.uint32(26).bytes(message.destinationChainID);
        }
        for (const v of message.destinations) {
            exports.RFFDestinationPair.encode(v, writer.uint32(34).fork()).join();
        }
        if (message.nonce.length !== 0) {
            writer.uint32(42).bytes(message.nonce);
        }
        if (!message.expiry.equals(long_1.default.UZERO)) {
            writer.uint32(48).uint64(message.expiry.toString());
        }
        if (message.destinationUniverse !== 0) {
            writer.uint32(72).int32(message.destinationUniverse);
        }
        for (const v of message.signatureData) {
            exports.SignatureDatum.encode(v, writer.uint32(82).fork()).join();
        }
        if (message.user !== "") {
            writer.uint32(810).string(message.user);
        }
        if (message.fulfilledBy.length !== 0) {
            writer.uint32(818).bytes(message.fulfilledBy);
        }
        if (!message.fulfilledAt.equals(long_1.default.UZERO)) {
            writer.uint32(824).uint64(message.fulfilledAt.toString());
        }
        if (message.deposited !== false) {
            writer.uint32(832).bool(message.deposited);
        }
        if (message.fulfilled !== false) {
            writer.uint32(840).bool(message.fulfilled);
        }
        if (message.settled !== false) {
            writer.uint32(848).bool(message.settled);
        }
        if (message.refunded !== false) {
            writer.uint32(856).bool(message.refunded);
        }
        if (!message.creationBlock.equals(long_1.default.ZERO)) {
            writer.uint32(872).int64(message.creationBlock.toString());
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestForFunds();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.id = long_1.default.fromString(reader.uint64().toString(), true);
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.sources.push(exports.RFFSourcePair.decode(reader, reader.uint32()));
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.destinationChainID = reader.bytes();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.destinations.push(exports.RFFDestinationPair.decode(reader, reader.uint32()));
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.nonce = reader.bytes();
                    continue;
                }
                case 6: {
                    if (tag !== 48) {
                        break;
                    }
                    message.expiry = long_1.default.fromString(reader.uint64().toString(), true);
                    continue;
                }
                case 9: {
                    if (tag !== 72) {
                        break;
                    }
                    message.destinationUniverse = reader.int32();
                    continue;
                }
                case 10: {
                    if (tag !== 82) {
                        break;
                    }
                    message.signatureData.push(exports.SignatureDatum.decode(reader, reader.uint32()));
                    continue;
                }
                case 101: {
                    if (tag !== 810) {
                        break;
                    }
                    message.user = reader.string();
                    continue;
                }
                case 102: {
                    if (tag !== 818) {
                        break;
                    }
                    message.fulfilledBy = reader.bytes();
                    continue;
                }
                case 103: {
                    if (tag !== 824) {
                        break;
                    }
                    message.fulfilledAt = long_1.default.fromString(reader.uint64().toString(), true);
                    continue;
                }
                case 104: {
                    if (tag !== 832) {
                        break;
                    }
                    message.deposited = reader.bool();
                    continue;
                }
                case 105: {
                    if (tag !== 840) {
                        break;
                    }
                    message.fulfilled = reader.bool();
                    continue;
                }
                case 106: {
                    if (tag !== 848) {
                        break;
                    }
                    message.settled = reader.bool();
                    continue;
                }
                case 107: {
                    if (tag !== 856) {
                        break;
                    }
                    message.refunded = reader.bool();
                    continue;
                }
                case 109: {
                    if (tag !== 872) {
                        break;
                    }
                    message.creationBlock = long_1.default.fromString(reader.int64().toString());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? long_1.default.fromValue(object.id) : long_1.default.UZERO,
            sources: globalThis.Array.isArray(object?.sources)
                ? object.sources.map((e) => exports.RFFSourcePair.fromJSON(e))
                : [],
            destinationChainID: isSet(object.destinationChainID)
                ? bytesFromBase64(object.destinationChainID)
                : new Uint8Array(0),
            destinations: globalThis.Array.isArray(object?.destinations)
                ? object.destinations.map((e) => exports.RFFDestinationPair.fromJSON(e))
                : [],
            nonce: isSet(object.nonce)
                ? bytesFromBase64(object.nonce)
                : new Uint8Array(0),
            expiry: isSet(object.expiry) ? long_1.default.fromValue(object.expiry) : long_1.default.UZERO,
            destinationUniverse: isSet(object.destinationUniverse)
                ? universeFromJSON(object.destinationUniverse)
                : 0,
            signatureData: globalThis.Array.isArray(object?.signatureData)
                ? object.signatureData.map((e) => exports.SignatureDatum.fromJSON(e))
                : [],
            user: isSet(object.user) ? globalThis.String(object.user) : "",
            fulfilledBy: isSet(object.fulfilledBy)
                ? bytesFromBase64(object.fulfilledBy)
                : new Uint8Array(0),
            fulfilledAt: isSet(object.fulfilledAt)
                ? long_1.default.fromValue(object.fulfilledAt)
                : long_1.default.UZERO,
            deposited: isSet(object.deposited)
                ? globalThis.Boolean(object.deposited)
                : false,
            fulfilled: isSet(object.fulfilled)
                ? globalThis.Boolean(object.fulfilled)
                : false,
            settled: isSet(object.settled)
                ? globalThis.Boolean(object.settled)
                : false,
            refunded: isSet(object.refunded)
                ? globalThis.Boolean(object.refunded)
                : false,
            creationBlock: isSet(object.creationBlock)
                ? long_1.default.fromValue(object.creationBlock)
                : long_1.default.ZERO,
        };
    },
    toJSON(message) {
        const obj = {};
        if (!message.id.equals(long_1.default.UZERO)) {
            obj.id = (message.id || long_1.default.UZERO).toString();
        }
        if (message.sources?.length) {
            obj.sources = message.sources.map((e) => exports.RFFSourcePair.toJSON(e));
        }
        if (message.destinationChainID.length !== 0) {
            obj.destinationChainID = base64FromBytes(message.destinationChainID);
        }
        if (message.destinations?.length) {
            obj.destinations = message.destinations.map((e) => exports.RFFDestinationPair.toJSON(e));
        }
        if (message.nonce.length !== 0) {
            obj.nonce = base64FromBytes(message.nonce);
        }
        if (!message.expiry.equals(long_1.default.UZERO)) {
            obj.expiry = (message.expiry || long_1.default.UZERO).toString();
        }
        if (message.destinationUniverse !== 0) {
            obj.destinationUniverse = universeToJSON(message.destinationUniverse);
        }
        if (message.signatureData?.length) {
            obj.signatureData = message.signatureData.map((e) => exports.SignatureDatum.toJSON(e));
        }
        if (message.user !== "") {
            obj.user = message.user;
        }
        if (message.fulfilledBy.length !== 0) {
            obj.fulfilledBy = base64FromBytes(message.fulfilledBy);
        }
        if (!message.fulfilledAt.equals(long_1.default.UZERO)) {
            obj.fulfilledAt = (message.fulfilledAt || long_1.default.UZERO).toString();
        }
        if (message.deposited !== false) {
            obj.deposited = message.deposited;
        }
        if (message.fulfilled !== false) {
            obj.fulfilled = message.fulfilled;
        }
        if (message.settled !== false) {
            obj.settled = message.settled;
        }
        if (message.refunded !== false) {
            obj.refunded = message.refunded;
        }
        if (!message.creationBlock.equals(long_1.default.ZERO)) {
            obj.creationBlock = (message.creationBlock || long_1.default.ZERO).toString();
        }
        return obj;
    },
    create(base) {
        return exports.RequestForFunds.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRequestForFunds();
        message.id =
            object.id !== undefined && object.id !== null
                ? long_1.default.fromValue(object.id)
                : long_1.default.UZERO;
        message.sources =
            object.sources?.map((e) => exports.RFFSourcePair.fromPartial(e)) || [];
        message.destinationChainID = object.destinationChainID ?? new Uint8Array(0);
        message.destinations =
            object.destinations?.map((e) => exports.RFFDestinationPair.fromPartial(e)) || [];
        message.nonce = object.nonce ?? new Uint8Array(0);
        message.expiry =
            object.expiry !== undefined && object.expiry !== null
                ? long_1.default.fromValue(object.expiry)
                : long_1.default.UZERO;
        message.destinationUniverse = object.destinationUniverse ?? 0;
        message.signatureData =
            object.signatureData?.map((e) => exports.SignatureDatum.fromPartial(e)) || [];
        message.user = object.user ?? "";
        message.fulfilledBy = object.fulfilledBy ?? new Uint8Array(0);
        message.fulfilledAt =
            object.fulfilledAt !== undefined && object.fulfilledAt !== null
                ? long_1.default.fromValue(object.fulfilledAt)
                : long_1.default.UZERO;
        message.deposited = object.deposited ?? false;
        message.fulfilled = object.fulfilled ?? false;
        message.settled = object.settled ?? false;
        message.refunded = object.refunded ?? false;
        message.creationBlock =
            object.creationBlock !== undefined && object.creationBlock !== null
                ? long_1.default.fromValue(object.creationBlock)
                : long_1.default.ZERO;
        return message;
    },
};
function createBaseMsgCreateRequestForFunds() {
    return {
        sources: [],
        destinationUniverse: 0,
        destinationChainID: new Uint8Array(0),
        destinations: [],
        nonce: new Uint8Array(0),
        expiry: long_1.default.UZERO,
        user: "",
        signatureData: [],
    };
}
exports.MsgCreateRequestForFunds = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.sources) {
            exports.RFFSourcePair.encode(v, writer.uint32(10).fork()).join();
        }
        if (message.destinationUniverse !== 0) {
            writer.uint32(16).int32(message.destinationUniverse);
        }
        if (message.destinationChainID.length !== 0) {
            writer.uint32(26).bytes(message.destinationChainID);
        }
        for (const v of message.destinations) {
            exports.RFFDestinationPair.encode(v, writer.uint32(34).fork()).join();
        }
        if (message.nonce.length !== 0) {
            writer.uint32(42).bytes(message.nonce);
        }
        if (!message.expiry.equals(long_1.default.UZERO)) {
            writer.uint32(48).uint64(message.expiry.toString());
        }
        if (message.user !== "") {
            writer.uint32(58).string(message.user);
        }
        for (const v of message.signatureData) {
            exports.SignatureDatum.encode(v, writer.uint32(66).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateRequestForFunds();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.sources.push(exports.RFFSourcePair.decode(reader, reader.uint32()));
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.destinationUniverse = reader.int32();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.destinationChainID = reader.bytes();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.destinations.push(exports.RFFDestinationPair.decode(reader, reader.uint32()));
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.nonce = reader.bytes();
                    continue;
                }
                case 6: {
                    if (tag !== 48) {
                        break;
                    }
                    message.expiry = long_1.default.fromString(reader.uint64().toString(), true);
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.user = reader.string();
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }
                    message.signatureData.push(exports.SignatureDatum.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sources: globalThis.Array.isArray(object?.sources)
                ? object.sources.map((e) => exports.RFFSourcePair.fromJSON(e))
                : [],
            destinationUniverse: isSet(object.destinationUniverse)
                ? universeFromJSON(object.destinationUniverse)
                : 0,
            destinationChainID: isSet(object.destinationChainID)
                ? bytesFromBase64(object.destinationChainID)
                : new Uint8Array(0),
            destinations: globalThis.Array.isArray(object?.destinations)
                ? object.destinations.map((e) => exports.RFFDestinationPair.fromJSON(e))
                : [],
            nonce: isSet(object.nonce)
                ? bytesFromBase64(object.nonce)
                : new Uint8Array(0),
            expiry: isSet(object.expiry) ? long_1.default.fromValue(object.expiry) : long_1.default.UZERO,
            user: isSet(object.user) ? globalThis.String(object.user) : "",
            signatureData: globalThis.Array.isArray(object?.signatureData)
                ? object.signatureData.map((e) => exports.SignatureDatum.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.sources?.length) {
            obj.sources = message.sources.map((e) => exports.RFFSourcePair.toJSON(e));
        }
        if (message.destinationUniverse !== 0) {
            obj.destinationUniverse = universeToJSON(message.destinationUniverse);
        }
        if (message.destinationChainID.length !== 0) {
            obj.destinationChainID = base64FromBytes(message.destinationChainID);
        }
        if (message.destinations?.length) {
            obj.destinations = message.destinations.map((e) => exports.RFFDestinationPair.toJSON(e));
        }
        if (message.nonce.length !== 0) {
            obj.nonce = base64FromBytes(message.nonce);
        }
        if (!message.expiry.equals(long_1.default.UZERO)) {
            obj.expiry = (message.expiry || long_1.default.UZERO).toString();
        }
        if (message.user !== "") {
            obj.user = message.user;
        }
        if (message.signatureData?.length) {
            obj.signatureData = message.signatureData.map((e) => exports.SignatureDatum.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.MsgCreateRequestForFunds.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgCreateRequestForFunds();
        message.sources =
            object.sources?.map((e) => exports.RFFSourcePair.fromPartial(e)) || [];
        message.destinationUniverse = object.destinationUniverse ?? 0;
        message.destinationChainID = object.destinationChainID ?? new Uint8Array(0);
        message.destinations =
            object.destinations?.map((e) => exports.RFFDestinationPair.fromPartial(e)) || [];
        message.nonce = object.nonce ?? new Uint8Array(0);
        message.expiry =
            object.expiry !== undefined && object.expiry !== null
                ? long_1.default.fromValue(object.expiry)
                : long_1.default.UZERO;
        message.user = object.user ?? "";
        message.signatureData =
            object.signatureData?.map((e) => exports.SignatureDatum.fromPartial(e)) || [];
        return message;
    },
};
function createBaseMsgCreateRequestForFundsResponse() {
    return { id: long_1.default.UZERO };
}
exports.MsgCreateRequestForFundsResponse = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (!message.id.equals(long_1.default.UZERO)) {
            writer.uint32(8).uint64(message.id.toString());
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateRequestForFundsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.id = long_1.default.fromString(reader.uint64().toString(), true);
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { id: isSet(object.id) ? long_1.default.fromValue(object.id) : long_1.default.UZERO };
    },
    toJSON(message) {
        const obj = {};
        if (!message.id.equals(long_1.default.UZERO)) {
            obj.id = (message.id || long_1.default.UZERO).toString();
        }
        return obj;
    },
    create(base) {
        return exports.MsgCreateRequestForFundsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgCreateRequestForFundsResponse();
        message.id =
            object.id !== undefined && object.id !== null
                ? long_1.default.fromValue(object.id)
                : long_1.default.UZERO;
        return message;
    },
};
function createBaseQueryGetRequestForFundsRequest() {
    return { id: long_1.default.UZERO };
}
exports.QueryGetRequestForFundsRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (!message.id.equals(long_1.default.UZERO)) {
            writer.uint32(8).uint64(message.id.toString());
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryGetRequestForFundsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.id = long_1.default.fromString(reader.uint64().toString(), true);
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { id: isSet(object.id) ? long_1.default.fromValue(object.id) : long_1.default.UZERO };
    },
    toJSON(message) {
        const obj = {};
        if (!message.id.equals(long_1.default.UZERO)) {
            obj.id = (message.id || long_1.default.UZERO).toString();
        }
        return obj;
    },
    create(base) {
        return exports.QueryGetRequestForFundsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryGetRequestForFundsRequest();
        message.id =
            object.id !== undefined && object.id !== null
                ? long_1.default.fromValue(object.id)
                : long_1.default.UZERO;
        return message;
    },
};
function createBaseQueryGetRequestForFundsResponse() {
    return { requestForFunds: undefined };
}
exports.QueryGetRequestForFundsResponse = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.requestForFunds !== undefined) {
            exports.RequestForFunds.encode(message.requestForFunds, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryGetRequestForFundsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.requestForFunds = exports.RequestForFunds.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            requestForFunds: isSet(object.requestForFunds)
                ? exports.RequestForFunds.fromJSON(object.requestForFunds)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.requestForFunds !== undefined) {
            obj.requestForFunds = exports.RequestForFunds.toJSON(message.requestForFunds);
        }
        return obj;
    },
    create(base) {
        return exports.QueryGetRequestForFundsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryGetRequestForFundsResponse();
        message.requestForFunds =
            object.requestForFunds !== undefined && object.requestForFunds !== null
                ? exports.RequestForFunds.fromPartial(object.requestForFunds)
                : undefined;
        return message;
    },
};
function createBaseQueryAllRequestForFundsRequest() {
    return { pagination: undefined };
}
exports.QueryAllRequestForFundsRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.pagination !== undefined) {
            exports.PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllRequestForFundsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.pagination = exports.PageRequest.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            pagination: isSet(object.pagination)
                ? exports.PageRequest.fromJSON(object.pagination)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.pagination !== undefined) {
            obj.pagination = exports.PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return exports.QueryAllRequestForFundsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllRequestForFundsRequest();
        message.pagination =
            object.pagination !== undefined && object.pagination !== null
                ? exports.PageRequest.fromPartial(object.pagination)
                : undefined;
        return message;
    },
};
function createBaseQueryAllRequestForFundsResponse() {
    return { requestForFunds: [], pagination: undefined };
}
exports.QueryAllRequestForFundsResponse = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.requestForFunds) {
            exports.RequestForFunds.encode(v, writer.uint32(10).fork()).join();
        }
        if (message.pagination !== undefined) {
            exports.PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllRequestForFundsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.requestForFunds.push(exports.RequestForFunds.decode(reader, reader.uint32()));
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = exports.PageResponse.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            requestForFunds: globalThis.Array.isArray(object?.requestForFunds)
                ? object.requestForFunds.map((e) => exports.RequestForFunds.fromJSON(e))
                : [],
            pagination: isSet(object.pagination)
                ? exports.PageResponse.fromJSON(object.pagination)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.requestForFunds?.length) {
            obj.requestForFunds = message.requestForFunds.map((e) => exports.RequestForFunds.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = exports.PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return exports.QueryAllRequestForFundsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllRequestForFundsResponse();
        message.requestForFunds =
            object.requestForFunds?.map((e) => exports.RequestForFunds.fromPartial(e)) ||
                [];
        message.pagination =
            object.pagination !== undefined && object.pagination !== null
                ? exports.PageResponse.fromPartial(object.pagination)
                : undefined;
        return message;
    },
};
function createBaseRouteFee() {
    return {
        sourceUniverse: 0,
        destinationUniverse: 0,
        sourceChainID: new Uint8Array(0),
        destinationChainID: new Uint8Array(0),
        sourceTokenAddress: new Uint8Array(0),
        destinationTokenAddress: new Uint8Array(0),
        feeBP: 0,
    };
}
exports.RouteFee = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.sourceUniverse !== 0) {
            writer.uint32(8).int32(message.sourceUniverse);
        }
        if (message.destinationUniverse !== 0) {
            writer.uint32(16).int32(message.destinationUniverse);
        }
        if (message.sourceChainID.length !== 0) {
            writer.uint32(26).bytes(message.sourceChainID);
        }
        if (message.destinationChainID.length !== 0) {
            writer.uint32(34).bytes(message.destinationChainID);
        }
        if (message.sourceTokenAddress.length !== 0) {
            writer.uint32(42).bytes(message.sourceTokenAddress);
        }
        if (message.destinationTokenAddress.length !== 0) {
            writer.uint32(50).bytes(message.destinationTokenAddress);
        }
        if (message.feeBP !== 0) {
            writer.uint32(80).uint32(message.feeBP);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRouteFee();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.sourceUniverse = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.destinationUniverse = reader.int32();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.sourceChainID = reader.bytes();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.destinationChainID = reader.bytes();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.sourceTokenAddress = reader.bytes();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.destinationTokenAddress = reader.bytes();
                    continue;
                }
                case 10: {
                    if (tag !== 80) {
                        break;
                    }
                    message.feeBP = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sourceUniverse: isSet(object.sourceUniverse)
                ? universeFromJSON(object.sourceUniverse)
                : 0,
            destinationUniverse: isSet(object.destinationUniverse)
                ? universeFromJSON(object.destinationUniverse)
                : 0,
            sourceChainID: isSet(object.sourceChainID)
                ? bytesFromBase64(object.sourceChainID)
                : new Uint8Array(0),
            destinationChainID: isSet(object.destinationChainID)
                ? bytesFromBase64(object.destinationChainID)
                : new Uint8Array(0),
            sourceTokenAddress: isSet(object.sourceTokenAddress)
                ? bytesFromBase64(object.sourceTokenAddress)
                : new Uint8Array(0),
            destinationTokenAddress: isSet(object.destinationTokenAddress)
                ? bytesFromBase64(object.destinationTokenAddress)
                : new Uint8Array(0),
            feeBP: isSet(object.feeBP) ? globalThis.Number(object.feeBP) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.sourceUniverse !== 0) {
            obj.sourceUniverse = universeToJSON(message.sourceUniverse);
        }
        if (message.destinationUniverse !== 0) {
            obj.destinationUniverse = universeToJSON(message.destinationUniverse);
        }
        if (message.sourceChainID.length !== 0) {
            obj.sourceChainID = base64FromBytes(message.sourceChainID);
        }
        if (message.destinationChainID.length !== 0) {
            obj.destinationChainID = base64FromBytes(message.destinationChainID);
        }
        if (message.sourceTokenAddress.length !== 0) {
            obj.sourceTokenAddress = base64FromBytes(message.sourceTokenAddress);
        }
        if (message.destinationTokenAddress.length !== 0) {
            obj.destinationTokenAddress = base64FromBytes(message.destinationTokenAddress);
        }
        if (message.feeBP !== 0) {
            obj.feeBP = Math.round(message.feeBP);
        }
        return obj;
    },
    create(base) {
        return exports.RouteFee.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRouteFee();
        message.sourceUniverse = object.sourceUniverse ?? 0;
        message.destinationUniverse = object.destinationUniverse ?? 0;
        message.sourceChainID = object.sourceChainID ?? new Uint8Array(0);
        message.destinationChainID = object.destinationChainID ?? new Uint8Array(0);
        message.sourceTokenAddress = object.sourceTokenAddress ?? new Uint8Array(0);
        message.destinationTokenAddress =
            object.destinationTokenAddress ?? new Uint8Array(0);
        message.feeBP = object.feeBP ?? 0;
        return message;
    },
};
function createBaseSolverAddress() {
    return {
        universe: 0,
        address: new Uint8Array(0),
        signature: new Uint8Array(0),
    };
}
exports.SolverAddress = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.universe !== 0) {
            writer.uint32(8).int32(message.universe);
        }
        if (message.address.length !== 0) {
            writer.uint32(18).bytes(message.address);
        }
        if (message.signature.length !== 0) {
            writer.uint32(26).bytes(message.signature);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSolverAddress();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.universe = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.address = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.signature = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
            address: isSet(object.address)
                ? bytesFromBase64(object.address)
                : new Uint8Array(0),
            signature: isSet(object.signature)
                ? bytesFromBase64(object.signature)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.universe !== 0) {
            obj.universe = universeToJSON(message.universe);
        }
        if (message.address.length !== 0) {
            obj.address = base64FromBytes(message.address);
        }
        if (message.signature.length !== 0) {
            obj.signature = base64FromBytes(message.signature);
        }
        return obj;
    },
    create(base) {
        return exports.SolverAddress.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSolverAddress();
        message.universe = object.universe ?? 0;
        message.address = object.address ?? new Uint8Array(0);
        message.signature = object.signature ?? new Uint8Array(0);
        return message;
    },
};
function createBaseSolverData() {
    return { cosmosAddress: "", advertisedFees: [], addresses: [] };
}
exports.SolverData = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.cosmosAddress !== "") {
            writer.uint32(10).string(message.cosmosAddress);
        }
        for (const v of message.advertisedFees) {
            exports.RouteFee.encode(v, writer.uint32(18).fork()).join();
        }
        for (const v of message.addresses) {
            exports.SolverAddress.encode(v, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSolverData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.cosmosAddress = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.advertisedFees.push(exports.RouteFee.decode(reader, reader.uint32()));
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.addresses.push(exports.SolverAddress.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            cosmosAddress: isSet(object.cosmosAddress)
                ? globalThis.String(object.cosmosAddress)
                : "",
            advertisedFees: globalThis.Array.isArray(object?.advertisedFees)
                ? object.advertisedFees.map((e) => exports.RouteFee.fromJSON(e))
                : [],
            addresses: globalThis.Array.isArray(object?.addresses)
                ? object.addresses.map((e) => exports.SolverAddress.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.cosmosAddress !== "") {
            obj.cosmosAddress = message.cosmosAddress;
        }
        if (message.advertisedFees?.length) {
            obj.advertisedFees = message.advertisedFees.map((e) => exports.RouteFee.toJSON(e));
        }
        if (message.addresses?.length) {
            obj.addresses = message.addresses.map((e) => exports.SolverAddress.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.SolverData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSolverData();
        message.cosmosAddress = object.cosmosAddress ?? "";
        message.advertisedFees =
            object.advertisedFees?.map((e) => exports.RouteFee.fromPartial(e)) || [];
        message.addresses =
            object.addresses?.map((e) => exports.SolverAddress.fromPartial(e)) || [];
        return message;
    },
};
function createBaseQueryGetSolverDataRequest() {
    return { cosmosAddress: "" };
}
exports.QueryGetSolverDataRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.cosmosAddress !== "") {
            writer.uint32(10).string(message.cosmosAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryGetSolverDataRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.cosmosAddress = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            cosmosAddress: isSet(object.cosmosAddress)
                ? globalThis.String(object.cosmosAddress)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.cosmosAddress !== "") {
            obj.cosmosAddress = message.cosmosAddress;
        }
        return obj;
    },
    create(base) {
        return exports.QueryGetSolverDataRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryGetSolverDataRequest();
        message.cosmosAddress = object.cosmosAddress ?? "";
        return message;
    },
};
function createBaseQueryGetSolverDataResponse() {
    return { solverData: undefined };
}
exports.QueryGetSolverDataResponse = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.solverData !== undefined) {
            exports.SolverData.encode(message.solverData, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryGetSolverDataResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.solverData = exports.SolverData.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            solverData: isSet(object.solverData)
                ? exports.SolverData.fromJSON(object.solverData)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.solverData !== undefined) {
            obj.solverData = exports.SolverData.toJSON(message.solverData);
        }
        return obj;
    },
    create(base) {
        return exports.QueryGetSolverDataResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryGetSolverDataResponse();
        message.solverData =
            object.solverData !== undefined && object.solverData !== null
                ? exports.SolverData.fromPartial(object.solverData)
                : undefined;
        return message;
    },
};
function createBaseQueryAllSolverDataRequest() {
    return { pagination: undefined };
}
exports.QueryAllSolverDataRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.pagination !== undefined) {
            exports.PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllSolverDataRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.pagination = exports.PageRequest.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            pagination: isSet(object.pagination)
                ? exports.PageRequest.fromJSON(object.pagination)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.pagination !== undefined) {
            obj.pagination = exports.PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return exports.QueryAllSolverDataRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllSolverDataRequest();
        message.pagination =
            object.pagination !== undefined && object.pagination !== null
                ? exports.PageRequest.fromPartial(object.pagination)
                : undefined;
        return message;
    },
};
function createBaseQueryAllSolverDataResponse() {
    return { solverData: [], pagination: undefined };
}
exports.QueryAllSolverDataResponse = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.solverData) {
            exports.SolverData.encode(v, writer.uint32(10).fork()).join();
        }
        if (message.pagination !== undefined) {
            exports.PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllSolverDataResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.solverData.push(exports.SolverData.decode(reader, reader.uint32()));
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = exports.PageResponse.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            solverData: globalThis.Array.isArray(object?.solverData)
                ? object.solverData.map((e) => exports.SolverData.fromJSON(e))
                : [],
            pagination: isSet(object.pagination)
                ? exports.PageResponse.fromJSON(object.pagination)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.solverData?.length) {
            obj.solverData = message.solverData.map((e) => exports.SolverData.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = exports.PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return exports.QueryAllSolverDataResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllSolverDataResponse();
        message.solverData =
            object.solverData?.map((e) => exports.SolverData.fromPartial(e)) || [];
        message.pagination =
            object.pagination !== undefined && object.pagination !== null
                ? exports.PageResponse.fromPartial(object.pagination)
                : undefined;
        return message;
    },
};
function createBaseMsgCreateSolverData() {
    return { cosmosAddress: "", advertisedFees: [], addresses: [] };
}
exports.MsgCreateSolverData = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.cosmosAddress !== "") {
            writer.uint32(10).string(message.cosmosAddress);
        }
        for (const v of message.advertisedFees) {
            exports.RouteFee.encode(v, writer.uint32(18).fork()).join();
        }
        for (const v of message.addresses) {
            exports.SolverAddress.encode(v, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateSolverData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.cosmosAddress = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.advertisedFees.push(exports.RouteFee.decode(reader, reader.uint32()));
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.addresses.push(exports.SolverAddress.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            cosmosAddress: isSet(object.cosmosAddress)
                ? globalThis.String(object.cosmosAddress)
                : "",
            advertisedFees: globalThis.Array.isArray(object?.advertisedFees)
                ? object.advertisedFees.map((e) => exports.RouteFee.fromJSON(e))
                : [],
            addresses: globalThis.Array.isArray(object?.addresses)
                ? object.addresses.map((e) => exports.SolverAddress.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.cosmosAddress !== "") {
            obj.cosmosAddress = message.cosmosAddress;
        }
        if (message.advertisedFees?.length) {
            obj.advertisedFees = message.advertisedFees.map((e) => exports.RouteFee.toJSON(e));
        }
        if (message.addresses?.length) {
            obj.addresses = message.addresses.map((e) => exports.SolverAddress.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.MsgCreateSolverData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgCreateSolverData();
        message.cosmosAddress = object.cosmosAddress ?? "";
        message.advertisedFees =
            object.advertisedFees?.map((e) => exports.RouteFee.fromPartial(e)) || [];
        message.addresses =
            object.addresses?.map((e) => exports.SolverAddress.fromPartial(e)) || [];
        return message;
    },
};
function createBaseMsgCreateSolverDataResponse() {
    return {};
}
exports.MsgCreateSolverDataResponse = {
    encode(_, writer = new wire_1.BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateSolverDataResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.MsgCreateSolverDataResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgCreateSolverDataResponse();
        return message;
    },
};
function createBaseMsgUpdateSolverData() {
    return { cosmosAddress: "", advertisedFees: [], addresses: [] };
}
exports.MsgUpdateSolverData = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.cosmosAddress !== "") {
            writer.uint32(10).string(message.cosmosAddress);
        }
        for (const v of message.advertisedFees) {
            exports.RouteFee.encode(v, writer.uint32(18).fork()).join();
        }
        for (const v of message.addresses) {
            exports.SolverAddress.encode(v, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateSolverData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.cosmosAddress = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.advertisedFees.push(exports.RouteFee.decode(reader, reader.uint32()));
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.addresses.push(exports.SolverAddress.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            cosmosAddress: isSet(object.cosmosAddress)
                ? globalThis.String(object.cosmosAddress)
                : "",
            advertisedFees: globalThis.Array.isArray(object?.advertisedFees)
                ? object.advertisedFees.map((e) => exports.RouteFee.fromJSON(e))
                : [],
            addresses: globalThis.Array.isArray(object?.addresses)
                ? object.addresses.map((e) => exports.SolverAddress.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.cosmosAddress !== "") {
            obj.cosmosAddress = message.cosmosAddress;
        }
        if (message.advertisedFees?.length) {
            obj.advertisedFees = message.advertisedFees.map((e) => exports.RouteFee.toJSON(e));
        }
        if (message.addresses?.length) {
            obj.addresses = message.addresses.map((e) => exports.SolverAddress.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.MsgUpdateSolverData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgUpdateSolverData();
        message.cosmosAddress = object.cosmosAddress ?? "";
        message.advertisedFees =
            object.advertisedFees?.map((e) => exports.RouteFee.fromPartial(e)) || [];
        message.addresses =
            object.addresses?.map((e) => exports.SolverAddress.fromPartial(e)) || [];
        return message;
    },
};
function createBaseMsgUpdateSolverDataResponse() {
    return {};
}
exports.MsgUpdateSolverDataResponse = {
    encode(_, writer = new wire_1.BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateSolverDataResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.MsgUpdateSolverDataResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgUpdateSolverDataResponse();
        return message;
    },
};
function createBaseSettlement() {
    return {
        id: new Uint8Array(0),
        universe: 0,
        chainId: new Uint8Array(0),
        amounts: [],
        tokenAddress: [],
        filler: [],
        success: false,
    };
}
exports.Settlement = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id.length !== 0) {
            writer.uint32(10).bytes(message.id);
        }
        if (message.universe !== 0) {
            writer.uint32(16).int32(message.universe);
        }
        if (message.chainId.length !== 0) {
            writer.uint32(26).bytes(message.chainId);
        }
        for (const v of message.amounts) {
            writer.uint32(34).bytes(v);
        }
        for (const v of message.tokenAddress) {
            writer.uint32(42).bytes(v);
        }
        for (const v of message.filler) {
            writer.uint32(50).bytes(v);
        }
        if (message.success !== false) {
            writer.uint32(56).bool(message.success);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSettlement();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.universe = reader.int32();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.chainId = reader.bytes();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.amounts.push(reader.bytes());
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.tokenAddress.push(reader.bytes());
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.filler.push(reader.bytes());
                    continue;
                }
                case 7: {
                    if (tag !== 56) {
                        break;
                    }
                    message.success = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
            universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
            chainId: isSet(object.chainId)
                ? bytesFromBase64(object.chainId)
                : new Uint8Array(0),
            amounts: globalThis.Array.isArray(object?.amounts)
                ? object.amounts.map((e) => bytesFromBase64(e))
                : [],
            tokenAddress: globalThis.Array.isArray(object?.tokenAddress)
                ? object.tokenAddress.map((e) => bytesFromBase64(e))
                : [],
            filler: globalThis.Array.isArray(object?.filler)
                ? object.filler.map((e) => bytesFromBase64(e))
                : [],
            success: isSet(object.success)
                ? globalThis.Boolean(object.success)
                : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id.length !== 0) {
            obj.id = base64FromBytes(message.id);
        }
        if (message.universe !== 0) {
            obj.universe = universeToJSON(message.universe);
        }
        if (message.chainId.length !== 0) {
            obj.chainId = base64FromBytes(message.chainId);
        }
        if (message.amounts?.length) {
            obj.amounts = message.amounts.map((e) => base64FromBytes(e));
        }
        if (message.tokenAddress?.length) {
            obj.tokenAddress = message.tokenAddress.map((e) => base64FromBytes(e));
        }
        if (message.filler?.length) {
            obj.filler = message.filler.map((e) => base64FromBytes(e));
        }
        if (message.success !== false) {
            obj.success = message.success;
        }
        return obj;
    },
    create(base) {
        return exports.Settlement.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSettlement();
        message.id = object.id ?? new Uint8Array(0);
        message.universe = object.universe ?? 0;
        message.chainId = object.chainId ?? new Uint8Array(0);
        message.amounts = object.amounts?.map((e) => e) || [];
        message.tokenAddress = object.tokenAddress?.map((e) => e) || [];
        message.filler = object.filler?.map((e) => e) || [];
        message.success = object.success ?? false;
        return message;
    },
};
function createBaseQueryGetSettlementRequest() {
    return { id: long_1.default.UZERO };
}
exports.QueryGetSettlementRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (!message.id.equals(long_1.default.UZERO)) {
            writer.uint32(8).uint64(message.id.toString());
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryGetSettlementRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.id = long_1.default.fromString(reader.uint64().toString(), true);
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { id: isSet(object.id) ? long_1.default.fromValue(object.id) : long_1.default.UZERO };
    },
    toJSON(message) {
        const obj = {};
        if (!message.id.equals(long_1.default.UZERO)) {
            obj.id = (message.id || long_1.default.UZERO).toString();
        }
        return obj;
    },
    create(base) {
        return exports.QueryGetSettlementRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryGetSettlementRequest();
        message.id =
            object.id !== undefined && object.id !== null
                ? long_1.default.fromValue(object.id)
                : long_1.default.UZERO;
        return message;
    },
};
function createBaseQueryGetSettlementResponse() {
    return { Settlement: undefined };
}
exports.QueryGetSettlementResponse = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.Settlement !== undefined) {
            exports.Settlement.encode(message.Settlement, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryGetSettlementResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.Settlement = exports.Settlement.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            Settlement: isSet(object.Settlement)
                ? exports.Settlement.fromJSON(object.Settlement)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.Settlement !== undefined) {
            obj.Settlement = exports.Settlement.toJSON(message.Settlement);
        }
        return obj;
    },
    create(base) {
        return exports.QueryGetSettlementResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryGetSettlementResponse();
        message.Settlement =
            object.Settlement !== undefined && object.Settlement !== null
                ? exports.Settlement.fromPartial(object.Settlement)
                : undefined;
        return message;
    },
};
function createBaseQueryAllSettlementRequest() {
    return { pagination: undefined };
}
exports.QueryAllSettlementRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.pagination !== undefined) {
            exports.PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllSettlementRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.pagination = exports.PageRequest.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            pagination: isSet(object.pagination)
                ? exports.PageRequest.fromJSON(object.pagination)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.pagination !== undefined) {
            obj.pagination = exports.PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return exports.QueryAllSettlementRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllSettlementRequest();
        message.pagination =
            object.pagination !== undefined && object.pagination !== null
                ? exports.PageRequest.fromPartial(object.pagination)
                : undefined;
        return message;
    },
};
function createBaseQueryAllSettlementResponse() {
    return { Settlement: [], pagination: undefined };
}
exports.QueryAllSettlementResponse = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.Settlement) {
            exports.Settlement.encode(v, writer.uint32(10).fork()).join();
        }
        if (message.pagination !== undefined) {
            exports.PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllSettlementResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.Settlement.push(exports.Settlement.decode(reader, reader.uint32()));
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = exports.PageResponse.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            Settlement: globalThis.Array.isArray(object?.Settlement)
                ? object.Settlement.map((e) => exports.Settlement.fromJSON(e))
                : [],
            pagination: isSet(object.pagination)
                ? exports.PageResponse.fromJSON(object.pagination)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.Settlement?.length) {
            obj.Settlement = message.Settlement.map((e) => exports.Settlement.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = exports.PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return exports.QueryAllSettlementResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllSettlementResponse();
        message.Settlement =
            object.Settlement?.map((e) => exports.Settlement.fromPartial(e)) || [];
        message.pagination =
            object.pagination !== undefined && object.pagination !== null
                ? exports.PageResponse.fromPartial(object.pagination)
                : undefined;
        return message;
    },
};
function createBaseQueryRequestForFundsByAddressRequest() {
    return { account: "", pagination: undefined };
}
exports.QueryRequestForFundsByAddressRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.account !== "") {
            writer.uint32(10).string(message.account);
        }
        if (message.pagination !== undefined) {
            exports.PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryRequestForFundsByAddressRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.account = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = exports.PageRequest.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            account: isSet(object.account) ? globalThis.String(object.account) : "",
            pagination: isSet(object.pagination)
                ? exports.PageRequest.fromJSON(object.pagination)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.account !== "") {
            obj.account = message.account;
        }
        if (message.pagination !== undefined) {
            obj.pagination = exports.PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return exports.QueryRequestForFundsByAddressRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryRequestForFundsByAddressRequest();
        message.account = object.account ?? "";
        message.pagination =
            object.pagination !== undefined && object.pagination !== null
                ? exports.PageRequest.fromPartial(object.pagination)
                : undefined;
        return message;
    },
};
function createBaseFixedFeeTuple() {
    return {
        universe: 0,
        chainID: new Uint8Array(0),
        tokenAddress: new Uint8Array(0),
        fee: new Uint8Array(0),
    };
}
exports.FixedFeeTuple = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.universe !== 0) {
            writer.uint32(8).int32(message.universe);
        }
        if (message.chainID.length !== 0) {
            writer.uint32(18).bytes(message.chainID);
        }
        if (message.tokenAddress.length !== 0) {
            writer.uint32(26).bytes(message.tokenAddress);
        }
        if (message.fee.length !== 0) {
            writer.uint32(34).bytes(message.fee);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFixedFeeTuple();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.universe = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.chainID = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.tokenAddress = reader.bytes();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.fee = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
            chainID: isSet(object.chainID)
                ? bytesFromBase64(object.chainID)
                : new Uint8Array(0),
            tokenAddress: isSet(object.tokenAddress)
                ? bytesFromBase64(object.tokenAddress)
                : new Uint8Array(0),
            fee: isSet(object.fee) ? bytesFromBase64(object.fee) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.universe !== 0) {
            obj.universe = universeToJSON(message.universe);
        }
        if (message.chainID.length !== 0) {
            obj.chainID = base64FromBytes(message.chainID);
        }
        if (message.tokenAddress.length !== 0) {
            obj.tokenAddress = base64FromBytes(message.tokenAddress);
        }
        if (message.fee.length !== 0) {
            obj.fee = base64FromBytes(message.fee);
        }
        return obj;
    },
    create(base) {
        return exports.FixedFeeTuple.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFixedFeeTuple();
        message.universe = object.universe ?? 0;
        message.chainID = object.chainID ?? new Uint8Array(0);
        message.tokenAddress = object.tokenAddress ?? new Uint8Array(0);
        message.fee = object.fee ?? new Uint8Array(0);
        return message;
    },
};
function createBaseAdminFeeRecipient() {
    return { universe: 0, address: new Uint8Array(0) };
}
exports.AdminFeeRecipient = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.universe !== 0) {
            writer.uint32(8).int32(message.universe);
        }
        if (message.address.length !== 0) {
            writer.uint32(18).bytes(message.address);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAdminFeeRecipient();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.universe = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.address = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
            address: isSet(object.address)
                ? bytesFromBase64(object.address)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.universe !== 0) {
            obj.universe = universeToJSON(message.universe);
        }
        if (message.address.length !== 0) {
            obj.address = base64FromBytes(message.address);
        }
        return obj;
    },
    create(base) {
        return exports.AdminFeeRecipient.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAdminFeeRecipient();
        message.universe = object.universe ?? 0;
        message.address = object.address ?? new Uint8Array(0);
        return message;
    },
};
function createBaseProtocolFees() {
    return {
        feeBP: long_1.default.UZERO,
        collectionFees: [],
        fulfilmentFees: [],
        admin: "",
        feeRecipients: [],
    };
}
exports.ProtocolFees = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (!message.feeBP.equals(long_1.default.UZERO)) {
            writer.uint32(8).uint64(message.feeBP.toString());
        }
        for (const v of message.collectionFees) {
            exports.FixedFeeTuple.encode(v, writer.uint32(18).fork()).join();
        }
        for (const v of message.fulfilmentFees) {
            exports.FixedFeeTuple.encode(v, writer.uint32(26).fork()).join();
        }
        if (message.admin !== "") {
            writer.uint32(34).string(message.admin);
        }
        for (const v of message.feeRecipients) {
            exports.AdminFeeRecipient.encode(v, writer.uint32(42).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProtocolFees();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.feeBP = long_1.default.fromString(reader.uint64().toString(), true);
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.collectionFees.push(exports.FixedFeeTuple.decode(reader, reader.uint32()));
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.fulfilmentFees.push(exports.FixedFeeTuple.decode(reader, reader.uint32()));
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.admin = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.feeRecipients.push(exports.AdminFeeRecipient.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            feeBP: isSet(object.feeBP) ? long_1.default.fromValue(object.feeBP) : long_1.default.UZERO,
            collectionFees: globalThis.Array.isArray(object?.collectionFees)
                ? object.collectionFees.map((e) => exports.FixedFeeTuple.fromJSON(e))
                : [],
            fulfilmentFees: globalThis.Array.isArray(object?.fulfilmentFees)
                ? object.fulfilmentFees.map((e) => exports.FixedFeeTuple.fromJSON(e))
                : [],
            admin: isSet(object.admin) ? globalThis.String(object.admin) : "",
            feeRecipients: globalThis.Array.isArray(object?.feeRecipients)
                ? object.feeRecipients.map((e) => exports.AdminFeeRecipient.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (!message.feeBP.equals(long_1.default.UZERO)) {
            obj.feeBP = (message.feeBP || long_1.default.UZERO).toString();
        }
        if (message.collectionFees?.length) {
            obj.collectionFees = message.collectionFees.map((e) => exports.FixedFeeTuple.toJSON(e));
        }
        if (message.fulfilmentFees?.length) {
            obj.fulfilmentFees = message.fulfilmentFees.map((e) => exports.FixedFeeTuple.toJSON(e));
        }
        if (message.admin !== "") {
            obj.admin = message.admin;
        }
        if (message.feeRecipients?.length) {
            obj.feeRecipients = message.feeRecipients.map((e) => exports.AdminFeeRecipient.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.ProtocolFees.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProtocolFees();
        message.feeBP =
            object.feeBP !== undefined && object.feeBP !== null
                ? long_1.default.fromValue(object.feeBP)
                : long_1.default.UZERO;
        message.collectionFees =
            object.collectionFees?.map((e) => exports.FixedFeeTuple.fromPartial(e)) || [];
        message.fulfilmentFees =
            object.fulfilmentFees?.map((e) => exports.FixedFeeTuple.fromPartial(e)) || [];
        message.admin = object.admin ?? "";
        message.feeRecipients =
            object.feeRecipients?.map((e) => exports.AdminFeeRecipient.fromPartial(e)) || [];
        return message;
    },
};
function createBaseQueryGetProtocolFeesRequest() {
    return {};
}
exports.QueryGetProtocolFeesRequest = {
    encode(_, writer = new wire_1.BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryGetProtocolFeesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.QueryGetProtocolFeesRequest.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseQueryGetProtocolFeesRequest();
        return message;
    },
};
function createBaseQueryGetProtocolFeesResponse() {
    return { ProtocolFees: undefined };
}
exports.QueryGetProtocolFeesResponse = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.ProtocolFees !== undefined) {
            exports.ProtocolFees.encode(message.ProtocolFees, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryGetProtocolFeesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.ProtocolFees = exports.ProtocolFees.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            ProtocolFees: isSet(object.ProtocolFees)
                ? exports.ProtocolFees.fromJSON(object.ProtocolFees)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.ProtocolFees !== undefined) {
            obj.ProtocolFees = exports.ProtocolFees.toJSON(message.ProtocolFees);
        }
        return obj;
    },
    create(base) {
        return exports.QueryGetProtocolFeesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryGetProtocolFeesResponse();
        message.ProtocolFees =
            object.ProtocolFees !== undefined && object.ProtocolFees !== null
                ? exports.ProtocolFees.fromPartial(object.ProtocolFees)
                : undefined;
        return message;
    },
};
function createBaseMsgCreateProtocolFees() {
    return {
        creator: "",
        feeBP: long_1.default.UZERO,
        collectionFees: [],
        fulfilmentFees: [],
        feeRecipients: [],
    };
}
exports.MsgCreateProtocolFees = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (!message.feeBP.equals(long_1.default.UZERO)) {
            writer.uint32(16).uint64(message.feeBP.toString());
        }
        for (const v of message.collectionFees) {
            exports.FixedFeeTuple.encode(v, writer.uint32(26).fork()).join();
        }
        for (const v of message.fulfilmentFees) {
            exports.FixedFeeTuple.encode(v, writer.uint32(34).fork()).join();
        }
        for (const v of message.feeRecipients) {
            exports.AdminFeeRecipient.encode(v, writer.uint32(42).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateProtocolFees();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.feeBP = long_1.default.fromString(reader.uint64().toString(), true);
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.collectionFees.push(exports.FixedFeeTuple.decode(reader, reader.uint32()));
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.fulfilmentFees.push(exports.FixedFeeTuple.decode(reader, reader.uint32()));
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.feeRecipients.push(exports.AdminFeeRecipient.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
            feeBP: isSet(object.feeBP) ? long_1.default.fromValue(object.feeBP) : long_1.default.UZERO,
            collectionFees: globalThis.Array.isArray(object?.collectionFees)
                ? object.collectionFees.map((e) => exports.FixedFeeTuple.fromJSON(e))
                : [],
            fulfilmentFees: globalThis.Array.isArray(object?.fulfilmentFees)
                ? object.fulfilmentFees.map((e) => exports.FixedFeeTuple.fromJSON(e))
                : [],
            feeRecipients: globalThis.Array.isArray(object?.feeRecipients)
                ? object.feeRecipients.map((e) => exports.AdminFeeRecipient.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (!message.feeBP.equals(long_1.default.UZERO)) {
            obj.feeBP = (message.feeBP || long_1.default.UZERO).toString();
        }
        if (message.collectionFees?.length) {
            obj.collectionFees = message.collectionFees.map((e) => exports.FixedFeeTuple.toJSON(e));
        }
        if (message.fulfilmentFees?.length) {
            obj.fulfilmentFees = message.fulfilmentFees.map((e) => exports.FixedFeeTuple.toJSON(e));
        }
        if (message.feeRecipients?.length) {
            obj.feeRecipients = message.feeRecipients.map((e) => exports.AdminFeeRecipient.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.MsgCreateProtocolFees.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgCreateProtocolFees();
        message.creator = object.creator ?? "";
        message.feeBP =
            object.feeBP !== undefined && object.feeBP !== null
                ? long_1.default.fromValue(object.feeBP)
                : long_1.default.UZERO;
        message.collectionFees =
            object.collectionFees?.map((e) => exports.FixedFeeTuple.fromPartial(e)) || [];
        message.fulfilmentFees =
            object.fulfilmentFees?.map((e) => exports.FixedFeeTuple.fromPartial(e)) || [];
        message.feeRecipients =
            object.feeRecipients?.map((e) => exports.AdminFeeRecipient.fromPartial(e)) || [];
        return message;
    },
};
function createBaseMsgCreateProtocolFeesResponse() {
    return {};
}
exports.MsgCreateProtocolFeesResponse = {
    encode(_, writer = new wire_1.BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateProtocolFeesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.MsgCreateProtocolFeesResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgCreateProtocolFeesResponse();
        return message;
    },
};
function createBaseMsgUpdateProtocolFees() {
    return {
        creator: "",
        feeBP: long_1.default.UZERO,
        collectionFees: [],
        fulfilmentFees: [],
        feeRecipients: [],
    };
}
exports.MsgUpdateProtocolFees = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (!message.feeBP.equals(long_1.default.UZERO)) {
            writer.uint32(16).uint64(message.feeBP.toString());
        }
        for (const v of message.collectionFees) {
            exports.FixedFeeTuple.encode(v, writer.uint32(26).fork()).join();
        }
        for (const v of message.fulfilmentFees) {
            exports.FixedFeeTuple.encode(v, writer.uint32(34).fork()).join();
        }
        for (const v of message.feeRecipients) {
            exports.AdminFeeRecipient.encode(v, writer.uint32(42).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateProtocolFees();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.feeBP = long_1.default.fromString(reader.uint64().toString(), true);
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.collectionFees.push(exports.FixedFeeTuple.decode(reader, reader.uint32()));
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.fulfilmentFees.push(exports.FixedFeeTuple.decode(reader, reader.uint32()));
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.feeRecipients.push(exports.AdminFeeRecipient.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
            feeBP: isSet(object.feeBP) ? long_1.default.fromValue(object.feeBP) : long_1.default.UZERO,
            collectionFees: globalThis.Array.isArray(object?.collectionFees)
                ? object.collectionFees.map((e) => exports.FixedFeeTuple.fromJSON(e))
                : [],
            fulfilmentFees: globalThis.Array.isArray(object?.fulfilmentFees)
                ? object.fulfilmentFees.map((e) => exports.FixedFeeTuple.fromJSON(e))
                : [],
            feeRecipients: globalThis.Array.isArray(object?.feeRecipients)
                ? object.feeRecipients.map((e) => exports.AdminFeeRecipient.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (!message.feeBP.equals(long_1.default.UZERO)) {
            obj.feeBP = (message.feeBP || long_1.default.UZERO).toString();
        }
        if (message.collectionFees?.length) {
            obj.collectionFees = message.collectionFees.map((e) => exports.FixedFeeTuple.toJSON(e));
        }
        if (message.fulfilmentFees?.length) {
            obj.fulfilmentFees = message.fulfilmentFees.map((e) => exports.FixedFeeTuple.toJSON(e));
        }
        if (message.feeRecipients?.length) {
            obj.feeRecipients = message.feeRecipients.map((e) => exports.AdminFeeRecipient.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.MsgUpdateProtocolFees.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgUpdateProtocolFees();
        message.creator = object.creator ?? "";
        message.feeBP =
            object.feeBP !== undefined && object.feeBP !== null
                ? long_1.default.fromValue(object.feeBP)
                : long_1.default.UZERO;
        message.collectionFees =
            object.collectionFees?.map((e) => exports.FixedFeeTuple.fromPartial(e)) || [];
        message.fulfilmentFees =
            object.fulfilmentFees?.map((e) => exports.FixedFeeTuple.fromPartial(e)) || [];
        message.feeRecipients =
            object.feeRecipients?.map((e) => exports.AdminFeeRecipient.fromPartial(e)) || [];
        return message;
    },
};
function createBaseMsgUpdateProtocolFeesResponse() {
    return {};
}
exports.MsgUpdateProtocolFeesResponse = {
    encode(_, writer = new wire_1.BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateProtocolFeesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.MsgUpdateProtocolFeesResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgUpdateProtocolFeesResponse();
        return message;
    },
};
function createBasePriceOracleDatum() {
    return {
        universe: 0,
        chainID: new Uint8Array(0),
        tokenAddress: new Uint8Array(0),
        price: new Uint8Array(0),
        decimals: 0,
    };
}
exports.PriceOracleDatum = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.universe !== 0) {
            writer.uint32(8).int32(message.universe);
        }
        if (message.chainID.length !== 0) {
            writer.uint32(18).bytes(message.chainID);
        }
        if (message.tokenAddress.length !== 0) {
            writer.uint32(26).bytes(message.tokenAddress);
        }
        if (message.price.length !== 0) {
            writer.uint32(34).bytes(message.price);
        }
        if (message.decimals !== 0) {
            writer.uint32(40).uint32(message.decimals);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePriceOracleDatum();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.universe = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.chainID = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.tokenAddress = reader.bytes();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.price = reader.bytes();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.decimals = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
            chainID: isSet(object.chainID)
                ? bytesFromBase64(object.chainID)
                : new Uint8Array(0),
            tokenAddress: isSet(object.tokenAddress)
                ? bytesFromBase64(object.tokenAddress)
                : new Uint8Array(0),
            price: isSet(object.price)
                ? bytesFromBase64(object.price)
                : new Uint8Array(0),
            decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.universe !== 0) {
            obj.universe = universeToJSON(message.universe);
        }
        if (message.chainID.length !== 0) {
            obj.chainID = base64FromBytes(message.chainID);
        }
        if (message.tokenAddress.length !== 0) {
            obj.tokenAddress = base64FromBytes(message.tokenAddress);
        }
        if (message.price.length !== 0) {
            obj.price = base64FromBytes(message.price);
        }
        if (message.decimals !== 0) {
            obj.decimals = Math.round(message.decimals);
        }
        return obj;
    },
    create(base) {
        return exports.PriceOracleDatum.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePriceOracleDatum();
        message.universe = object.universe ?? 0;
        message.chainID = object.chainID ?? new Uint8Array(0);
        message.tokenAddress = object.tokenAddress ?? new Uint8Array(0);
        message.price = object.price ?? new Uint8Array(0);
        message.decimals = object.decimals ?? 0;
        return message;
    },
};
function createBasePriceOracleData() {
    return { priceData: [] };
}
exports.PriceOracleData = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.priceData) {
            exports.PriceOracleDatum.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePriceOracleData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.priceData.push(exports.PriceOracleDatum.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            priceData: globalThis.Array.isArray(object?.priceData)
                ? object.priceData.map((e) => exports.PriceOracleDatum.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.priceData?.length) {
            obj.priceData = message.priceData.map((e) => exports.PriceOracleDatum.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.PriceOracleData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePriceOracleData();
        message.priceData =
            object.priceData?.map((e) => exports.PriceOracleDatum.fromPartial(e)) || [];
        return message;
    },
};
function createBaseQueryGetPriceOracleDataRequest() {
    return {};
}
exports.QueryGetPriceOracleDataRequest = {
    encode(_, writer = new wire_1.BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryGetPriceOracleDataRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.QueryGetPriceOracleDataRequest.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseQueryGetPriceOracleDataRequest();
        return message;
    },
};
function createBaseQueryGetPriceOracleDataResponse() {
    return { PriceOracleData: undefined };
}
exports.QueryGetPriceOracleDataResponse = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.PriceOracleData !== undefined) {
            exports.PriceOracleData.encode(message.PriceOracleData, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryGetPriceOracleDataResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.PriceOracleData = exports.PriceOracleData.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            PriceOracleData: isSet(object.PriceOracleData)
                ? exports.PriceOracleData.fromJSON(object.PriceOracleData)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.PriceOracleData !== undefined) {
            obj.PriceOracleData = exports.PriceOracleData.toJSON(message.PriceOracleData);
        }
        return obj;
    },
    create(base) {
        return exports.QueryGetPriceOracleDataResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryGetPriceOracleDataResponse();
        message.PriceOracleData =
            object.PriceOracleData !== undefined && object.PriceOracleData !== null
                ? exports.PriceOracleData.fromPartial(object.PriceOracleData)
                : undefined;
        return message;
    },
};
function createBaseMsgRefundReq() {
    return { creator: "", rffID: long_1.default.UZERO };
}
exports.MsgRefundReq = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (!message.rffID.equals(long_1.default.UZERO)) {
            writer.uint32(16).uint64(message.rffID.toString());
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRefundReq();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.rffID = long_1.default.fromString(reader.uint64().toString(), true);
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
            rffID: isSet(object.rffID) ? long_1.default.fromValue(object.rffID) : long_1.default.UZERO,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (!message.rffID.equals(long_1.default.UZERO)) {
            obj.rffID = (message.rffID || long_1.default.UZERO).toString();
        }
        return obj;
    },
    create(base) {
        return exports.MsgRefundReq.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgRefundReq();
        message.creator = object.creator ?? "";
        message.rffID =
            object.rffID !== undefined && object.rffID !== null
                ? long_1.default.fromValue(object.rffID)
                : long_1.default.UZERO;
        return message;
    },
};
function createBaseMsgRefundReqResponse() {
    return {};
}
exports.MsgRefundReqResponse = {
    encode(_, writer = new wire_1.BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRefundReqResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.MsgRefundReqResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgRefundReqResponse();
        return message;
    },
};
function createBaseDepositVEPacket() {
    return { id: long_1.default.UZERO, gasRefunded: false };
}
exports.DepositVEPacket = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (!message.id.equals(long_1.default.UZERO)) {
            writer.uint32(8).uint64(message.id.toString());
        }
        if (message.gasRefunded !== false) {
            writer.uint32(16).bool(message.gasRefunded);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDepositVEPacket();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.id = long_1.default.fromString(reader.uint64().toString(), true);
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.gasRefunded = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? long_1.default.fromValue(object.id) : long_1.default.UZERO,
            gasRefunded: isSet(object.gasRefunded)
                ? globalThis.Boolean(object.gasRefunded)
                : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (!message.id.equals(long_1.default.UZERO)) {
            obj.id = (message.id || long_1.default.UZERO).toString();
        }
        if (message.gasRefunded !== false) {
            obj.gasRefunded = message.gasRefunded;
        }
        return obj;
    },
    create(base) {
        return exports.DepositVEPacket.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDepositVEPacket();
        message.id =
            object.id !== undefined && object.id !== null
                ? long_1.default.fromValue(object.id)
                : long_1.default.UZERO;
        message.gasRefunded = object.gasRefunded ?? false;
        return message;
    },
};
function createBaseFillVEPacket() {
    return {
        id: long_1.default.UZERO,
        fillerAddress: new Uint8Array(0),
        transactionHash: new Uint8Array(0),
    };
}
exports.FillVEPacket = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (!message.id.equals(long_1.default.UZERO)) {
            writer.uint32(8).uint64(message.id.toString());
        }
        if (message.fillerAddress.length !== 0) {
            writer.uint32(18).bytes(message.fillerAddress);
        }
        if (message.transactionHash.length !== 0) {
            writer.uint32(26).bytes(message.transactionHash);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFillVEPacket();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.id = long_1.default.fromString(reader.uint64().toString(), true);
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.fillerAddress = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.transactionHash = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? long_1.default.fromValue(object.id) : long_1.default.UZERO,
            fillerAddress: isSet(object.fillerAddress)
                ? bytesFromBase64(object.fillerAddress)
                : new Uint8Array(0),
            transactionHash: isSet(object.transactionHash)
                ? bytesFromBase64(object.transactionHash)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (!message.id.equals(long_1.default.UZERO)) {
            obj.id = (message.id || long_1.default.UZERO).toString();
        }
        if (message.fillerAddress.length !== 0) {
            obj.fillerAddress = base64FromBytes(message.fillerAddress);
        }
        if (message.transactionHash.length !== 0) {
            obj.transactionHash = base64FromBytes(message.transactionHash);
        }
        return obj;
    },
    create(base) {
        return exports.FillVEPacket.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFillVEPacket();
        message.id =
            object.id !== undefined && object.id !== null
                ? long_1.default.fromValue(object.id)
                : long_1.default.UZERO;
        message.fillerAddress = object.fillerAddress ?? new Uint8Array(0);
        message.transactionHash = object.transactionHash ?? new Uint8Array(0);
        return message;
    },
};
function createBaseMsgDoubleCheckTx() {
    return {
        creator: "",
        txUniverse: 0,
        txChainID: new Uint8Array(0),
        packet: undefined,
    };
}
exports.MsgDoubleCheckTx = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.txUniverse !== 0) {
            writer.uint32(16).int32(message.txUniverse);
        }
        if (message.txChainID.length !== 0) {
            writer.uint32(26).bytes(message.txChainID);
        }
        switch (message.packet?.$case) {
            case "depositPacket":
                exports.DepositVEPacket.encode(message.packet.value, writer.uint32(42).fork()).join();
                break;
            case "fillPacket":
                exports.FillVEPacket.encode(message.packet.value, writer.uint32(50).fork()).join();
                break;
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDoubleCheckTx();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.txUniverse = reader.int32();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.txChainID = reader.bytes();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.packet = {
                        $case: "depositPacket",
                        value: exports.DepositVEPacket.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.packet = {
                        $case: "fillPacket",
                        value: exports.FillVEPacket.decode(reader, reader.uint32()),
                    };
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
            txUniverse: isSet(object.txUniverse)
                ? universeFromJSON(object.txUniverse)
                : 0,
            txChainID: isSet(object.txChainID)
                ? bytesFromBase64(object.txChainID)
                : new Uint8Array(0),
            packet: isSet(object.depositPacket)
                ? {
                    $case: "depositPacket",
                    value: exports.DepositVEPacket.fromJSON(object.depositPacket),
                }
                : isSet(object.fillPacket)
                    ? {
                        $case: "fillPacket",
                        value: exports.FillVEPacket.fromJSON(object.fillPacket),
                    }
                    : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.txUniverse !== 0) {
            obj.txUniverse = universeToJSON(message.txUniverse);
        }
        if (message.txChainID.length !== 0) {
            obj.txChainID = base64FromBytes(message.txChainID);
        }
        if (message.packet?.$case === "depositPacket") {
            obj.depositPacket = exports.DepositVEPacket.toJSON(message.packet.value);
        }
        else if (message.packet?.$case === "fillPacket") {
            obj.fillPacket = exports.FillVEPacket.toJSON(message.packet.value);
        }
        return obj;
    },
    create(base) {
        return exports.MsgDoubleCheckTx.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgDoubleCheckTx();
        message.creator = object.creator ?? "";
        message.txUniverse = object.txUniverse ?? 0;
        message.txChainID = object.txChainID ?? new Uint8Array(0);
        switch (object.packet?.$case) {
            case "depositPacket": {
                if (object.packet?.value !== undefined &&
                    object.packet?.value !== null) {
                    message.packet = {
                        $case: "depositPacket",
                        value: exports.DepositVEPacket.fromPartial(object.packet.value),
                    };
                }
                break;
            }
            case "fillPacket": {
                if (object.packet?.value !== undefined &&
                    object.packet?.value !== null) {
                    message.packet = {
                        $case: "fillPacket",
                        value: exports.FillVEPacket.fromPartial(object.packet.value),
                    };
                }
                break;
            }
        }
        return message;
    },
};
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
