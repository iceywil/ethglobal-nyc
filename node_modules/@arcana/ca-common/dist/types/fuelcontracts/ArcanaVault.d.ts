import type { Account, Address, BigNumberish, BN, FunctionFragment, InvokeFunction, Provider, StorageSlot } from "fuels";
import { Contract, Interface } from "fuels";
import type { Enum, Option, Vec } from "./common";
export declare enum AccessErrorInput {
    NotOwner = "NotOwner"
}
export declare enum AccessErrorOutput {
    NotOwner = "NotOwner"
}
export type IdentityInput = Enum<{
    Address: AddressInput;
    ContractId: ContractIdInput;
}>;
export type IdentityOutput = Enum<{
    Address: AddressOutput;
    ContractId: ContractIdOutput;
}>;
export declare enum InitializationErrorInput {
    CannotReinitialized = "CannotReinitialized"
}
export declare enum InitializationErrorOutput {
    CannotReinitialized = "CannotReinitialized"
}
export declare enum ReentrancyErrorInput {
    NonReentrant = "NonReentrant"
}
export declare enum ReentrancyErrorOutput {
    NonReentrant = "NonReentrant"
}
export declare enum RoleAccessErrorInput {
    NotSettlementVerifier = "NotSettlementVerifier",
    NotRefundEligible = "NotRefundEligible"
}
export declare enum RoleAccessErrorOutput {
    NotSettlementVerifier = "NotSettlementVerifier",
    NotRefundEligible = "NotRefundEligible"
}
export type StateInput = Enum<{
    Uninitialized: undefined;
    Initialized: IdentityInput;
    Revoked: undefined;
}>;
export type StateOutput = Enum<{
    Uninitialized: void;
    Initialized: IdentityOutput;
    Revoked: void;
}>;
export declare enum UniverseInput {
    ETHEREUM = "ETHEREUM",
    FUEL = "FUEL",
    SOLANA = "SOLANA"
}
export declare enum UniverseOutput {
    ETHEREUM = "ETHEREUM",
    FUEL = "FUEL",
    SOLANA = "SOLANA"
}
export type VaultErrorInput = Enum<{
    AssetMismatch: undefined;
    ChainIdMismatch: undefined;
    DestinationPairsNotFilled: Vec<DestinationPairInput>;
    InvalidFillOutputs: undefined;
    InvalidSignature: undefined;
    NonceAlreadyUsed: undefined;
    RequestExpired: undefined;
    RequestUnverified: undefined;
    SolversAndAmountsLengthMismatch: undefined;
    SolversAndAssetsLengthMismatch: undefined;
    ValueMismatch: undefined;
    AddressNotFound: undefined;
}>;
export type VaultErrorOutput = Enum<{
    AssetMismatch: void;
    ChainIdMismatch: void;
    DestinationPairsNotFilled: Vec<DestinationPairOutput>;
    InvalidFillOutputs: void;
    InvalidSignature: void;
    NonceAlreadyUsed: void;
    RequestExpired: void;
    RequestUnverified: void;
    SolversAndAmountsLengthMismatch: void;
    SolversAndAssetsLengthMismatch: void;
    ValueMismatch: void;
    AddressNotFound: void;
}>;
export type AddressInput = {
    bits: string;
};
export type AddressOutput = AddressInput;
export type AssetIdInput = {
    bits: string;
};
export type AssetIdOutput = AssetIdInput;
export type ContractIdInput = {
    bits: string;
};
export type ContractIdOutput = ContractIdInput;
export type DepositInput = {
    from: AddressInput;
    signed_message_hash: string;
};
export type DepositOutput = {
    from: AddressOutput;
    signed_message_hash: string;
};
export type DestinationPairInput = {
    asset_id: AssetIdInput;
    value: BigNumberish;
};
export type DestinationPairOutput = {
    asset_id: AssetIdOutput;
    value: BN;
};
export type FillInput = {
    from: AddressInput;
    signed_message_hash: string;
    solver: AddressInput;
};
export type FillOutput = {
    from: AddressOutput;
    signed_message_hash: string;
    solver: AddressOutput;
};
export type OwnershipRenouncedInput = {
    previous_owner: IdentityInput;
};
export type OwnershipRenouncedOutput = {
    previous_owner: IdentityOutput;
};
export type OwnershipSetInput = {
    new_owner: IdentityInput;
};
export type OwnershipSetOutput = {
    new_owner: IdentityOutput;
};
export type OwnershipTransferredInput = {
    new_owner: IdentityInput;
    previous_owner: IdentityInput;
};
export type OwnershipTransferredOutput = {
    new_owner: IdentityOutput;
    previous_owner: IdentityOutput;
};
export type PartyInput = {
    universe: UniverseInput;
    address: AddressInput;
};
export type PartyOutput = {
    universe: UniverseOutput;
    address: AddressOutput;
};
export type RefundEligibleRoleSetInput = {
    identity: IdentityInput;
    has_role: boolean;
};
export type RefundEligibleRoleSetOutput = {
    identity: IdentityOutput;
    has_role: boolean;
};
export type RefundEligibleRoleTransferInput = {
    old_identity: IdentityInput;
    new_identity: IdentityInput;
};
export type RefundEligibleRoleTransferOutput = {
    old_identity: IdentityOutput;
    new_identity: IdentityOutput;
};
export type RequestInput = {
    sources: Vec<SourcePairInput>;
    destination_universe: UniverseInput;
    destination_chain_id: BigNumberish;
    destinations: Vec<DestinationPairInput>;
    nonce: BigNumberish;
    expiry: BigNumberish;
    parties: Vec<PartyInput>;
};
export type RequestOutput = {
    sources: Vec<SourcePairOutput>;
    destination_universe: UniverseOutput;
    destination_chain_id: BN;
    destinations: Vec<DestinationPairOutput>;
    nonce: BN;
    expiry: BN;
    parties: Vec<PartyOutput>;
};
export type SettleInput = {
    solver: AddressInput;
    asset_id: AssetIdInput;
    amount: BigNumberish;
    nonce: BigNumberish;
};
export type SettleOutput = {
    solver: AddressOutput;
    asset_id: AssetIdOutput;
    amount: BN;
    nonce: BN;
};
export type SettleDataInput = {
    universe: UniverseInput;
    chain_id: BigNumberish;
    solvers: Vec<AddressInput>;
    assets: Vec<AssetIdInput>;
    amounts: Vec<BigNumberish>;
    nonce: BigNumberish;
};
export type SettleDataOutput = {
    universe: UniverseOutput;
    chain_id: BN;
    solvers: Vec<AddressOutput>;
    assets: Vec<AssetIdOutput>;
    amounts: Vec<BN>;
    nonce: BN;
};
export type SettlementVerifierRoleSetInput = {
    identity: IdentityInput;
    has_role: boolean;
};
export type SettlementVerifierRoleSetOutput = {
    identity: IdentityOutput;
    has_role: boolean;
};
export type SettlementVerifierRoleTransferInput = {
    old_identity: IdentityInput;
    new_identity: IdentityInput;
};
export type SettlementVerifierRoleTransferOutput = {
    old_identity: IdentityOutput;
    new_identity: IdentityOutput;
};
export type SourcePairInput = {
    universe: UniverseInput;
    chain_id: BigNumberish;
    asset_id: AssetIdInput;
    value: BigNumberish;
};
export type SourcePairOutput = {
    universe: UniverseOutput;
    chain_id: BN;
    asset_id: AssetIdOutput;
    value: BN;
};
export type WithdrawInput = {
    to: IdentityInput;
    asset_id: AssetIdInput;
    amount: BigNumberish;
};
export type WithdrawOutput = {
    to: IdentityOutput;
    asset_id: AssetIdOutput;
    amount: BN;
};
export type ArcanaVaultConfigurables = Partial<{
    INITIAL_OWNER: IdentityInput;
    FUEL_IGNITION_CHAIN_ID: BigNumberish;
}>;
export declare class ArcanaVaultInterface extends Interface {
    functions: {
        owner: FunctionFragment;
        deposit: FunctionFragment;
        deposit_nonce: FunctionFragment;
        fill: FunctionFragment;
        fill_nonce: FunctionFragment;
        hash_request: FunctionFragment;
        hash_settle_data: FunctionFragment;
        initialize_vault: FunctionFragment;
        refund_eligible_role: FunctionFragment;
        renounce_ownership: FunctionFragment;
        requests: FunctionFragment;
        set_refund_eligible_role: FunctionFragment;
        set_settlement_verifier_role: FunctionFragment;
        settle: FunctionFragment;
        settle_nonce: FunctionFragment;
        settlement_verifier_role: FunctionFragment;
        transfer_ownership: FunctionFragment;
        transfer_refund_eligible_role: FunctionFragment;
        transfer_settlement_verifier_role: FunctionFragment;
        verify_request_signature: FunctionFragment;
        withdraw: FunctionFragment;
    };
    constructor();
}
export declare class ArcanaVault extends Contract {
    static readonly abi: {
        programType: string;
        specVersion: string;
        encodingVersion: string;
        concreteTypes: ({
            type: string;
            concreteTypeId: string;
            metadataTypeId?: undefined;
            typeArguments?: undefined;
        } | {
            type: string;
            concreteTypeId: string;
            metadataTypeId: number;
            typeArguments?: undefined;
        } | {
            type: string;
            concreteTypeId: string;
            metadataTypeId: number;
            typeArguments: string[];
        })[];
        metadataTypes: ({
            type: string;
            metadataTypeId: number;
            components: ({
                name: string;
                typeId: string;
            } | {
                name: string;
                typeId: number;
            })[];
            typeParameters: number[];
        } | {
            type: string;
            metadataTypeId: number;
            components?: undefined;
            typeParameters?: undefined;
        } | {
            type: string;
            metadataTypeId: number;
            components: ({
                name: string;
                typeId: number;
                typeArguments?: undefined;
            } | {
                name: string;
                typeId: string;
                typeArguments?: undefined;
            } | {
                name: string;
                typeId: number;
                typeArguments: {
                    name: string;
                    typeId: number;
                }[];
            } | {
                name: string;
                typeId: number;
                typeArguments: {
                    name: string;
                    typeId: string;
                }[];
            })[];
            typeParameters?: undefined;
        } | {
            type: string;
            metadataTypeId: number;
            components: ({
                name: string;
                typeId: number;
                typeArguments: {
                    name: string;
                    typeId: number;
                }[];
            } | {
                name: string;
                typeId: string;
                typeArguments?: undefined;
            })[];
            typeParameters: number[];
        })[];
        functions: ({
            inputs: {
                name: string;
                concreteTypeId: string;
            }[];
            name: string;
            output: string;
            attributes: {
                name: string;
                arguments: string[];
            }[];
        } | {
            inputs: {
                name: string;
                concreteTypeId: string;
            }[];
            name: string;
            output: string;
            attributes: null;
        })[];
        loggedTypes: {
            logId: string;
            concreteTypeId: string;
        }[];
        messagesTypes: never[];
        configurables: {
            name: string;
            concreteTypeId: string;
            offset: number;
        }[];
    };
    static readonly storageSlots: StorageSlot[];
    interface: ArcanaVaultInterface;
    functions: {
        owner: InvokeFunction<[], StateOutput>;
        deposit: InvokeFunction<[
            request: RequestInput,
            signature: string,
            chain_index: BigNumberish
        ], void>;
        deposit_nonce: InvokeFunction<[nonce: BigNumberish], Option<boolean>>;
        fill: InvokeFunction<[request: RequestInput, signature: string], void>;
        fill_nonce: InvokeFunction<[nonce: BigNumberish], Option<boolean>>;
        hash_request: InvokeFunction<[request: RequestInput], string>;
        hash_settle_data: InvokeFunction<[settle_data: SettleDataInput], string>;
        initialize_vault: InvokeFunction<[], void>;
        refund_eligible_role: InvokeFunction<[identity: IdentityInput], boolean>;
        renounce_ownership: InvokeFunction<[], void>;
        requests: InvokeFunction<[
            signed_message_hash: string
        ], Option<RequestOutput>>;
        set_refund_eligible_role: InvokeFunction<[
            identity: IdentityInput,
            has_role: boolean
        ], void>;
        set_settlement_verifier_role: InvokeFunction<[
            identity: IdentityInput,
            has_role: boolean
        ], void>;
        settle: InvokeFunction<[
            settle_data: SettleDataInput,
            signature: string
        ], void>;
        settle_nonce: InvokeFunction<[nonce: BigNumberish], Option<boolean>>;
        settlement_verifier_role: InvokeFunction<[
            identity: IdentityInput
        ], boolean>;
        transfer_ownership: InvokeFunction<[new_owner: IdentityInput], void>;
        transfer_refund_eligible_role: InvokeFunction<[
            new_identity: IdentityInput
        ], void>;
        transfer_settlement_verifier_role: InvokeFunction<[
            new_identity: IdentityInput
        ], void>;
        verify_request_signature: InvokeFunction<[
            request: RequestInput,
            signature: string
        ], string>;
        withdraw: InvokeFunction<[
            to: IdentityInput,
            asset_id: AssetIdInput,
            amount: BigNumberish
        ], void>;
    };
    constructor(id: string | Address, accountOrProvider: Account | Provider);
}
