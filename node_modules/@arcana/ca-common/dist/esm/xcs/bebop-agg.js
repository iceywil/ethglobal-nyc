import axios, { AxiosError } from "axios";
import { bytesToHex, getAddress } from "viem";
import { QuoteType, } from "./iface";
import { Universe } from "../proto/definition";
import { encodeChainID36 } from "../data";
// https://api.bebop.xyz/{jam|pmm}/chains
const ChainNameMapping = new Map(Object.entries({
    ethereum: 1,
    arbitrum: 42161,
    optimism: 10,
    base: 8453,
    taiko: 167000,
    bsc: 56,
    monadtestnet: 10143,
    megaethtestnet: 6342,
    berachain: 80094,
    polygon: 137,
    zksync: 324,
    blast: 81457,
    mode: 34443,
    scroll: 534352,
    superseed: 5330,
}).map(([k, v]) => [bytesToHex(encodeChainID36(Universe.ETHEREUM, v)), k]));
export class BebopAggregator {
    static BASE_URL = "https://api.bebop.xyz/router";
    static COMMON_OPTIONS = {
        approval_type: "Standard",
        skip_validation: "true",
        gasless: false,
    };
    axios;
    constructor(apiKey) {
        this.axios = axios.create({
            baseURL: BebopAggregator.BASE_URL,
            headers: {
                "Source-Auth": apiKey,
            },
            params: {
                source: "arcana",
            },
        });
    }
    async getQuotes(requests) {
        const list = await Promise.allSettled(requests.map(async (r) => {
            const chainName = ChainNameMapping.get(bytesToHex(r.chain.toBytes()));
            if (chainName == null) {
                return null;
            }
            let respPromise;
            const inputTokenAddr = getAddress(bytesToHex(r.inputToken.subarray(12)));
            const outputTokenAddr = getAddress(bytesToHex(r.outputToken.subarray(12)));
            const userAddrHex = getAddress(bytesToHex(r.userAddress.subarray(12)));
            const receiverAddrHex = r.receiverAddress != null
                ? getAddress(bytesToHex(r.receiverAddress.subarray(12)))
                : userAddrHex;
            switch (r.type) {
                case QuoteType.ExactIn: {
                    respPromise = this.axios({
                        method: "GET",
                        url: `/${chainName}/v1/quote`,
                        params: {
                            sell_tokens: inputTokenAddr,
                            buy_tokens: outputTokenAddr,
                            taker_address: userAddrHex,
                            receiver_address: receiverAddrHex,
                            sell_amounts: r.inputAmount.toString(),
                            ...BebopAggregator.COMMON_OPTIONS,
                        },
                    });
                    break;
                }
                case QuoteType.ExactOut: {
                    respPromise = this.axios({
                        method: "GET",
                        url: `/${chainName}/v1/quote`,
                        params: {
                            sell_tokens: inputTokenAddr,
                            buy_tokens: outputTokenAddr,
                            taker_address: userAddrHex,
                            receiver_address: receiverAddrHex,
                            buy_amounts: r.outputAmount.toString(),
                            ...BebopAggregator.COMMON_OPTIONS,
                        },
                    });
                    break;
                }
            }
            let resp;
            try {
                resp = await respPromise;
            }
            catch (e) {
                if (e instanceof AxiosError && e.isAxiosError) {
                    if (e.response?.status === 404 &&
                        e.response.data.code === 1002 &&
                        e.response.data.message ===
                            "No available quotes for the requested transfer") {
                        return null;
                    }
                }
                throw e;
            }
            const bestRoute = resp.data.routes?.at(0);
            if (bestRoute == null) {
                return null;
            }
            const buyT = bestRoute.quote.buyTokens[outputTokenAddr];
            return {
                type: r.type,
                inputAmount: BigInt(bestRoute.quote.sellTokens[inputTokenAddr].amount),
                outputAmountMinimum: BigInt(buyT.minimumAmount),
                outputAmountLikely: BigInt(buyT.amount),
                originalResponse: bestRoute,
            };
        }));
        return list.map((item) => {
            switch (item.status) {
                case "fulfilled": {
                    return item.value;
                }
                case "rejected": {
                    console.error("Caught error in fetching Bebop quotes:", item.reason);
                    return null;
                }
            }
        });
    }
}
