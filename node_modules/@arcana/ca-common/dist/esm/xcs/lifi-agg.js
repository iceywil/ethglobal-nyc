import axios, { AxiosError } from "axios";
import { bytesToHex, getAddress } from "viem";
import { QuoteType, } from "./iface";
import { Universe } from "../proto/definition";
export class LiFiAggregator {
    static BASE_URL_V1 = "https://li.quest/v1";
    static COMMON_OPTIONS = {
        denyExchanges: "openocean",
        slippage: "0.01",
    };
    axios;
    constructor(apiKey) {
        this.axios = axios.create({
            baseURL: LiFiAggregator.BASE_URL_V1,
            headers: {
                "x-lifi-api-key": apiKey,
            },
        });
    }
    async getQuotes(requests) {
        const list = await Promise.allSettled(requests.map(async (r) => {
            if (r.chain.universe !== Universe.ETHEREUM) {
                return null;
            }
            let respPromise;
            const chIDStr = r.chain.chainID.toString();
            const inputTokenAddr = getAddress(bytesToHex(r.inputToken.subarray(12)));
            const outputTokenAddr = getAddress(bytesToHex(r.outputToken.subarray(12)));
            const userAddrHex = getAddress(bytesToHex(r.userAddress.subarray(12)));
            const receiverAddrHex = r.receiverAddress != null
                ? getAddress(bytesToHex(r.receiverAddress.subarray(12)))
                : userAddrHex;
            switch (r.type) {
                case QuoteType.ExactIn: {
                    respPromise = this.axios({
                        method: "GET",
                        url: "/quote",
                        params: {
                            fromChain: chIDStr,
                            toChain: chIDStr,
                            fromToken: inputTokenAddr,
                            toToken: outputTokenAddr,
                            fromAddress: userAddrHex,
                            toAddress: receiverAddrHex,
                            fromAmount: r.inputAmount.toString(),
                            ...LiFiAggregator.COMMON_OPTIONS,
                        },
                    });
                    break;
                }
                case QuoteType.ExactOut: {
                    respPromise = this.axios({
                        method: "GET",
                        url: "/quote/toAmount",
                        params: {
                            fromChain: chIDStr,
                            toChain: chIDStr,
                            fromToken: inputTokenAddr,
                            toToken: outputTokenAddr,
                            fromAddress: userAddrHex,
                            toAddress: receiverAddrHex,
                            toAmount: r.outputAmount.toString(),
                            ...LiFiAggregator.COMMON_OPTIONS,
                        },
                    });
                    break;
                }
            }
            let resp;
            try {
                resp = await respPromise;
            }
            catch (e) {
                if (e instanceof AxiosError && e.isAxiosError) {
                    if (e.response?.status === 404 &&
                        e.response.data.code === 1002 &&
                        e.response.data.message ===
                            "No available quotes for the requested transfer") {
                        return null;
                    }
                }
                throw e;
            }
            return {
                type: r.type,
                inputAmount: BigInt(resp.data.estimate.fromAmount),
                outputAmountMinimum: BigInt(resp.data.estimate.toAmountMin),
                outputAmountLikely: BigInt(resp.data.estimate.toAmount),
                originalResponse: resp.data,
            };
        }));
        return list.map((item) => {
            switch (item.status) {
                case "fulfilled": {
                    return item.value;
                }
                case "rejected": {
                    console.error("Caught error in fetching LiFi quotes:", item.reason);
                    return null;
                }
            }
        });
    }
}
