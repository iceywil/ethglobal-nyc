import { bytesToBigInt, hexToBigInt, toBytes, toHex } from "viem";
import { universeFromJSON, universeToJSON } from "../proto/definition";
import { convertToBufferIfNecessary } from "./utils";
export function encodeChainID36(universe, chainID) {
    let chainIDB;
    if (Buffer.isBuffer(chainID) || chainID instanceof Uint8Array) {
        chainIDB = chainID;
    }
    else {
        chainIDB = toBytes(chainID);
    }
    const buf = Buffer.alloc(36);
    buf.writeUint32BE(universe);
    buf.set(chainIDB, 4 + (32 - chainIDB.length));
    return buf;
}
export class OmniversalChainID {
    universe;
    chainID;
    binaryForm;
    constructor(universe, chainID) {
        this.universe = universe;
        if (typeof chainID === 'bigint') {
            this.chainID = chainID;
        }
        else if (typeof chainID === 'number' || typeof chainID === 'string') {
            this.chainID = BigInt(chainID);
        }
        else if (chainID instanceof Uint8Array) {
            this.chainID = bytesToBigInt(chainID);
        }
        this.binaryForm = encodeChainID36(this.universe, this.chainID);
    }
    toString() {
        return universeToJSON(this.universe) + '_' + this.chainID.toString(10);
    }
    toJSON() {
        return {
            universe: universeToJSON(this.universe),
            chainID: toHex(this.chainID)
        };
    }
    static fromJSON(input) {
        return new OmniversalChainID(universeFromJSON(input.universe), hexToBigInt(input.chainID));
    }
    static fromChainID36(_input) {
        const input = convertToBufferIfNecessary(_input);
        const univID = input.readUint32BE(0);
        const rest = input.subarray(4);
        return new OmniversalChainID(univID, rest);
    }
    // Do not modify the returned buffer. Make a copy if necessary.
    toBytes() {
        return this.binaryForm;
    }
    equals(rhs) {
        return this.universe === rhs.universe && this.chainID === rhs.chainID;
    }
    static equals(lhs, rhs) {
        return lhs.equals(rhs);
    }
}
