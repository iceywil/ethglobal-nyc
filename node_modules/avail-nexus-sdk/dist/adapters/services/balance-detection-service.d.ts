import type { EthereumProvider, SUPPORTED_TOKENS } from '../../types';
/**
 * Minimal interface for what BalanceDetectionService needs
 */
interface BalanceDetectionAdapter {
    isInitialized(): boolean;
    evmProvider: EthereumProvider;
}
/**
 * Detailed balance information for a user
 */
export interface DetailedBalanceInfo {
    token: SUPPORTED_TOKENS;
    chainId: number;
    userAddress: string;
    tokenAddress: string;
    balance: string;
    balanceFormatted: string;
    sufficient: boolean;
    shortfall: string;
    shortfallFormatted: string;
    decimals: number;
    isNative: boolean;
    lastChecked: string;
}
/**
 * Multi-token balance check result
 */
export interface MultiTokenBalanceResult {
    userAddress: string;
    chainId: number;
    balances: DetailedBalanceInfo[];
    totalSufficient: boolean;
    insufficientTokens: SUPPORTED_TOKENS[];
    lastChecked: string;
}
/**
 * Balance requirement specification
 */
export interface BalanceRequirement {
    token: SUPPORTED_TOKENS;
    amount: string;
    allowPartial?: boolean;
}
/**
 * Smart balance detection and analysis service
 */
export declare class BalanceDetectionService {
    private adapter;
    constructor(adapter: BalanceDetectionAdapter);
    private ensureInitialized;
    private get evmProvider();
    /**
     * Check detailed balance for a single token
     */
    getDetailedBalance(userAddress: string, token: SUPPORTED_TOKENS, chainId: number, requiredAmount?: string): Promise<DetailedBalanceInfo>;
    /**
     * Check balances for multiple tokens
     */
    getMultiTokenBalances(userAddress: string, chainId: number, requirements: BalanceRequirement[]): Promise<MultiTokenBalanceResult>;
    /**
     * Get ERC20 token balance using balanceOf call
     */
    private getERC20Balance;
    /**
     * Format token amount from wei to human readable
     */
    private formatTokenAmount;
    /**
     * Analyze balance gaps and suggest funding strategies
     */
    analyzeBalanceGaps(userAddress: string, chainId: number, requirements: BalanceRequirement[]): Promise<{
        analysis: MultiTokenBalanceResult;
        fundingStrategy: {
            totalFundingNeeded: boolean;
            tokenFunding: Array<{
                token: SUPPORTED_TOKENS;
                shortfall: string;
                shortfallFormatted: string;
                priority: 'high' | 'medium' | 'low';
                suggestionType: 'bridge' | 'swap' | 'acquire';
            }>;
        };
    }>;
    /**
     * Calculate funding priority based on shortfall amount and token importance
     */
    private calculateFundingPriority;
    /**
     * Suggest the best funding method for a token on a specific chain
     */
    private suggestFundingMethod;
    /**
     * Check if user can afford a transaction including gas
     */
    canAffordTransaction(userAddress: string, chainId: number, tokenRequirements: BalanceRequirement[], estimatedGasCost: string): Promise<{
        canAfford: boolean;
        tokenDeficits: DetailedBalanceInfo[];
        gasDeficit: string;
        totalDeficitValue?: string;
    }>;
}
export {};
