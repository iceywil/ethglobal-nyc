import { Abi, TransactionReceipt, Address } from 'viem';
export { TransactionReceipt } from 'viem';
import * as _arcana_ca_sdk from '@arcana/ca-sdk';
import { Intent, onAllowanceHookSource, CA, EthereumProvider, SDKConfig, UserAsset, OnIntentHook, OnAllowanceHook, RequestForFunds, Network, RequestArguments } from '@arcana/ca-sdk';
export { onAllowanceHookSource as AllowanceHookSource, EthereumProvider, Intent, Network, OnAllowanceHook, OnIntentHook, ProgressStep, ProgressSteps, RFF, RequestArguments, RequestForFunds, SDKConfig, UserAsset } from '@arcana/ca-sdk';
import SafeEventEmitter from '@metamask/safe-event-emitter';
import React, { ReactNode } from 'react';

declare const SUPPORTED_CHAINS: {
    readonly ETHEREUM: 1;
    readonly BASE: 8453;
    readonly ARBITRUM: 42161;
    readonly OPTIMISM: 10;
    readonly POLYGON: 137;
    readonly AVALANCHE: 43114;
    readonly SCROLL: 534352;
    readonly BASE_SEPOLIA: 84532;
    readonly ARBITRUM_SEPOLIA: 421614;
    readonly OPTIMISM_SEPOLIA: 11155420;
    readonly POLYGON_AMOY: 80002;
};
declare const chainIcons: Record<number, string>;
declare const TOKEN_METADATA: Record<string, TokenMetadata>;
declare const TESTNET_TOKEN_METADATA: Record<string, TokenMetadata>;
declare const CHAIN_METADATA: Record<number, ChainMetadata>;
declare const NEXUS_EVENTS: {
    readonly STEP_COMPLETE: "step_complete";
    readonly EXPECTED_STEPS: "expected_steps";
    readonly ACCOUNTS_CHANGED: "accountsChanged";
    readonly CHAIN_CHANGED: "chainChanged";
    readonly BRIDGE_EXECUTE_EXPECTED_STEPS: "bridge_execute_expected_steps";
    readonly BRIDGE_EXECUTE_COMPLETED_STEPS: "bridge_execute_completed_steps";
};
declare const MAINNET_CHAINS: readonly [1, 8453, 42161, 10, 137, 43114, 534352];
declare const TESTNET_CHAINS: readonly [84532, 421614, 11155420, 80002];
/**
 * Token contract addresses per chain
 * This registry contains the contract addresses for supported tokens across different chains
 */
declare const TOKEN_CONTRACT_ADDRESSES: Record<string, Record<number, string>>;
/**
 * Testnet token contract addresses per chain
 * Note: Most testnets use different contract addresses than mainnet
 */
declare const TESTNET_TOKEN_CONTRACT_ADDRESSES: Record<string, Record<number, string>>;

type TokenInfo = {
    contractAddress: `0x${string}`;
    decimals: number;
    logo?: string;
    name: string;
    platform?: string;
    symbol: string;
};
type NexusNetwork = 'mainnet' | 'testnet';
interface BlockTransaction {
    hash?: string;
    from?: string;
}
interface Block {
    transactions?: BlockTransaction[];
}
interface ChainMetadata {
    id: number;
    name: string;
    shortName: string;
    logo: string;
    nativeCurrency: {
        name: string;
        symbol: string;
        decimals: number;
    };
    rpcUrls: string[];
    blockExplorerUrls: string[];
}
interface TokenMetadata {
    symbol: string;
    name: string;
    decimals: number;
    icon: string;
    coingeckoId: string;
    isNative?: boolean;
}
type OnIntentHookData = {
    intent: Intent;
    allow: () => void;
    deny: () => void;
    refresh: () => Promise<Intent>;
};
type OnAllowanceHookData = {
    allow: (s: Array<'min' | 'max' | bigint | string>) => void;
    deny: () => void;
    sources: Array<onAllowanceHookSource>;
};
/**
 * Generic event listener type for CA SDK events
 */
type EventListener = (...args: unknown[]) => void;
/**
 * Parameters for checking or setting token allowance.
 */
interface AllowanceParams {
    tokens: string[];
    amount: number;
    chainId: (typeof SUPPORTED_CHAINS)[keyof typeof SUPPORTED_CHAINS];
}
/**
 * Response structure for token allowance.
 */
interface AllowanceResponse {
    chainID: number;
    allowance: bigint;
    token: string;
}
type SUPPORTED_TOKENS = 'ETH' | 'USDC' | 'USDT';
type SUPPORTED_CHAINS_IDS = (typeof SUPPORTED_CHAINS)[keyof typeof SUPPORTED_CHAINS];
/**
 * Parameters for bridging tokens between chains.
 */
interface BridgeParams {
    token: SUPPORTED_TOKENS;
    amount: number | string;
    chainId: SUPPORTED_CHAINS_IDS;
    gas?: bigint;
}
/**
 * Result structure for bridge transactions.
 */
interface BridgeResult {
    success: boolean;
    error?: string;
    explorerUrl?: string;
}
/**
 * Result structure for transfer transactions.
 */
interface TransferResult {
    success: boolean;
    error?: string;
    explorerUrl?: string;
}
interface SimulationResult {
    intent: Intent;
    token: TokenInfo;
}
/**
 * Parameters for transferring tokens.
 */
interface TransferParams {
    token: SUPPORTED_TOKENS;
    amount: number | string;
    chainId: SUPPORTED_CHAINS_IDS;
    recipient: `0x${string}`;
}
/**
 * Enhanced token balance information
 */
interface TokenBalance {
    symbol: string;
    balance: string;
    formattedBalance: string;
    balanceInFiat?: number;
    chainId: number;
    contractAddress?: `0x${string}`;
    isNative?: boolean;
}
interface ExecuteParams {
    toChainId: number;
    contractAddress: string;
    contractAbi: Abi;
    functionName: string;
    functionParams: readonly unknown[];
    value?: string;
    enableTransactionPolling?: boolean;
    transactionTimeout?: number;
    waitForReceipt?: boolean;
    receiptTimeout?: number;
    requiredConfirmations?: number;
    tokenApproval: {
        token: SUPPORTED_TOKENS;
        amount: string;
    };
}
interface ExecuteResult {
    transactionHash: string;
    explorerUrl: string;
    chainId: number;
    receipt?: TransactionReceipt;
    confirmations?: number;
    gasUsed?: string;
    effectiveGasPrice?: string;
}
interface ExecuteSimulation {
    gasUsed: string;
    success: boolean;
    error?: string;
    gasCostEth?: string;
}
interface ApprovalInfo {
    needsApproval: boolean;
    currentAllowance: bigint;
    requiredAmount: bigint;
    tokenAddress?: string;
    spenderAddress: string;
    token: SUPPORTED_TOKENS;
    chainId: number;
    hasPendingApproval?: boolean;
}
interface ApprovalSimulation {
    gasUsed: string;
    gasPrice: string;
    totalFee: string;
    success: boolean;
    error?: string;
}
interface SimulationStep {
    type: 'bridge' | 'approval' | 'execute';
    required: boolean;
    simulation: SimulationResult | ApprovalSimulation | ExecuteSimulation;
    description: string;
}
interface BridgeAndExecuteSimulationResult {
    steps: SimulationStep[];
    bridgeSimulation: SimulationResult | null;
    executeSimulation?: ExecuteSimulation;
    totalEstimatedCost?: {
        total: string;
        breakdown: {
            bridge: string;
            execute: string;
        };
    };
    success: boolean;
    error?: string;
    metadata?: {
        bridgeReceiveAmount: string;
        bridgeFee: string;
        inputAmount: string;
        targetChain: number;
        approvalRequired: boolean;
    };
}
interface BridgeAndExecuteParams {
    toChainId: SUPPORTED_CHAINS_IDS;
    token: SUPPORTED_TOKENS;
    amount: number | string;
    recipient?: `0x${string}`;
    execute?: Omit<ExecuteParams, 'toChainId'>;
    enableTransactionPolling?: boolean;
    transactionTimeout?: number;
    waitForReceipt?: boolean;
    receiptTimeout?: number;
    requiredConfirmations?: number;
    recentApprovalTxHash?: string;
}
interface BridgeAndExecuteResult {
    executeTransactionHash?: string;
    executeExplorerUrl?: string;
    approvalTransactionHash?: string;
    toChainId: number;
    success: boolean;
    error?: string;
}
/**
 * Smart contract call parameters
 */
interface ContractCallParams {
    to: `0x${string}`;
    data: `0x${string}`;
    value?: bigint;
    gas?: bigint;
    gasPrice?: bigint;
}

/**
 * Format a balance string to a human-readable format using Decimal.js
 */
declare function formatBalance(balance: string, decimals: number, precision?: number): string;
/**
 * Parse units from a human-readable string to wei/smallest unit using Decimal.js
 */
declare function parseUnits(value: string, decimals: number): bigint;
/**
 * Format units from wei/smallest unit to human-readable string using Decimal.js
 */
declare function formatUnits(value: bigint, decimals: number): string;
/**
 * Validate if a string is a valid Ethereum address using viem
 */
declare function isValidAddress(address: string): address is Address;
/**
 * Get chain metadata by chain ID
 */
declare function getChainMetadata(chainId: SUPPORTED_CHAINS_IDS): ChainMetadata;
/**
 * Format a mainnet token amount with proper decimals and symbol
 */
declare function formatTokenAmount(amount: string | bigint, tokenSymbol: SUPPORTED_TOKENS, precision?: number): string;
/**
 * Format a testnet token amount with proper decimals and symbol
 */
declare function formatTestnetTokenAmount(amount: string | bigint, tokenSymbol: SUPPORTED_TOKENS, precision?: number): string;
/**
 * Truncate an address for display purposes
 */
declare function truncateAddress(address: string, startLength?: number, endLength?: number): string;
/**
 * Convert chain ID to hex format
 */
declare function chainIdToHex(chainId: number): string;
/**
 * Convert hex chain ID to number
 */
declare function hexToChainId(hex: string): number;

/**
 * Approval transaction result
 */
interface ApprovalResult {
    transactionHash?: string;
    wasNeeded: boolean;
    error?: string;
    confirmed?: boolean;
}

/**
 * Refactored Adapter class that wraps CA SDK and provides a unified interface for chain abstraction operations.
 * Now uses a service-based architecture for better organization and maintainability.
 */
declare class ChainAbstractionAdapter {
    readonly ca: CA;
    evmProvider: EthereumProvider | null;
    readonly caEvents: SafeEventEmitter;
    private initialized;
    private bridgeService;
    private transferService;
    private executeService;
    private approvalService;
    private bridgeExecuteService;
    constructor(config?: SDKConfig);
    /**
     * Initialize the CA SDK with an EVM provider.
     */
    initialize(provider: EthereumProvider): Promise<void>;
    /**
     * Check if the adapter has been initialized
     */
    isInitialized(): boolean;
    /**
     * Get the EVM provider enhanced with CA functionality
     */
    getEVMProviderWithCA(): EthereumProvider;
    /**
     * Get unified balances for all supported tokens across all chains.
     */
    getUnifiedBalances(): Promise<UserAsset[]>;
    /**
     * Get unified balance for a specific token symbol.
     */
    getUnifiedBalance(symbol: string): Promise<UserAsset | undefined>;
    /**
     * Get allowance information for tokens.
     */
    getAllowance(chainId?: number, tokens?: string[]): Promise<AllowanceResponse[]>;
    /**
     * Set allowance for tokens.
     */
    setAllowance(chainId: number, tokens: string[], amount: bigint): Promise<void>;
    /**
     * Revoke allowance for tokens.
     */
    revokeAllowance(chainId: number, tokens: string[]): Promise<void>;
    /**
     * Set intent hook callback.
     */
    setOnIntentHook(callback: OnIntentHook): void;
    /**
     * Set allowance hook callback.
     */
    setOnAllowanceHook(callback: OnAllowanceHook): void;
    /**
     * Bridge tokens between chains using the bridge service.
     */
    bridge(params: BridgeParams): Promise<BridgeResult>;
    /**
     * Simulate bridge transaction using the bridge service.
     */
    simulateBridge(params: BridgeParams): Promise<SimulationResult>;
    /**
     * Transfer tokens to a recipient using the transfer service.
     */
    transfer(params: TransferParams): Promise<TransferResult>;
    /**
     * Simulate transfer transaction using the transfer service.
     */
    simulateTransfer(params: TransferParams): Promise<SimulationResult>;
    /**
     * Execute a contract call using the execute service.
     */
    execute(params: ExecuteParams): Promise<ExecuteResult>;
    /**
     * Simulate contract execution using the execute service.
     */
    simulateExecute(params: ExecuteParams): Promise<ExecuteSimulation>;
    /**
     * Ensure contract approval using the approval service.
     */
    ensureContractApproval(tokenApproval: {
        token: SUPPORTED_TOKENS;
        amount: string;
    }, spenderAddress: string, chainId: number, waitForConfirmation?: boolean): Promise<ApprovalResult>;
    /**
     * Get user's intents with pagination.
     */
    getMyIntents(page?: number): Promise<RequestForFunds[]>;
    /**
     * Subscribe to account change events.
     */
    onAccountChanged(callback: (account: string) => void): void;
    /**
     * Subscribe to chain change events.
     */
    onChainChanged(callback: (chainId: number) => void): void;
    /**
     * Remove all listeners for all events.
     */
    removeAllListeners(): void;
    /**
     * Get the list of supported chains from the CA SDK.
     */
    getSupportedChains(env?: Network): Array<{
        id: number;
        name: string;
        logo: string;
    }>;
    /**
     * Check if a chain is supported by the adapter.
     */
    isSupportedChain(chainId: SUPPORTED_CHAINS_IDS): boolean;
    /**
     * Check if a token is supported by the adapter.
     */
    isSupportedToken(token: string): boolean;
    /**
     * Deinitialize the CA SDK and clean up resources.
     */
    deinit(): Promise<void>;
    /**
     * Make a generic EIP-1193 request using the enhanced provider.
     */
    request(args: RequestArguments): Promise<unknown>;
    /**
     * Subscribe to any event emitted by the CA SDK.
     */
    on(eventName: string, listener: EventListener): void;
    /**
     * Remove a specific event listener.
     */
    removeListener(eventName: string, listener: EventListener): void;
    /**
     * Remove all CA event listeners.
     */
    removeAllCaEventListeners(eventName?: string): void;
    /**
     * Bridge and execute operation - uses the BridgeExecuteService
     */
    bridgeAndExecute(params: BridgeAndExecuteParams): Promise<BridgeAndExecuteResult>;
    /**
     * Simulate bridge and execute operation
     */
    simulateBridgeAndExecute(params: BridgeAndExecuteParams): Promise<BridgeAndExecuteSimulationResult>;
    /**
     * Helper method for common initialization validation
     */
    private ensureInitialized;
    /**
     * Enable or disable gas estimation for transactions
     * When enabled, gas estimation will run before each transaction execution
     * This helps identify potential failures early and provides cost estimates
     */
    private setGasEstimationEnabled;
}

declare class NexusUtils {
    private readonly adapter;
    private readonly isReady;
    constructor(adapter: ChainAbstractionAdapter, isReady: () => boolean);
    private ensureInitialized;
    formatBalance: typeof formatBalance;
    parseUnits: typeof parseUnits;
    formatUnits: typeof formatUnits;
    isValidAddress: typeof isValidAddress;
    truncateAddress: typeof truncateAddress;
    chainIdToHex: typeof chainIdToHex;
    hexToChainId: typeof hexToChainId;
    getMainnetTokenMetadata: (symbol: SUPPORTED_TOKENS) => TokenMetadata | undefined;
    getTestnetTokenMetadata: (symbol: SUPPORTED_TOKENS) => TokenMetadata | undefined;
    getTokenMetadata: (symbol: SUPPORTED_TOKENS) => TokenMetadata | undefined;
    getChainMetadata: typeof getChainMetadata;
    formatTokenAmount: typeof formatTokenAmount;
    formatTestnetTokenAmount: typeof formatTestnetTokenAmount;
    getSupportedChains(): Array<{
        id: number;
        name: string;
        logo: string;
    }>;
    isSupportedChain(chainId: (typeof SUPPORTED_CHAINS)[keyof typeof SUPPORTED_CHAINS]): boolean;
    isSupportedToken(token: string): boolean;
}

declare class NexusSDK {
    readonly nexusAdapter: ChainAbstractionAdapter;
    readonly nexusEvents: SafeEventEmitter;
    readonly utils: NexusUtils;
    constructor(config?: Omit<SDKConfig, 'siweStatement' | 'network'> & {
        network?: NexusNetwork;
        debug?: boolean;
    });
    /**
     * Initialize logger based on debug configuration
     * @private
     */
    private initializeLogger;
    /**
     * Initialize the SDK with a provider
     */
    initialize(provider: EthereumProvider): Promise<void>;
    /**
     * Get unified balances across all chains
     */
    getUnifiedBalances(): Promise<UserAsset[]>;
    /**
     * Get unified balance for a specific token
     */
    getUnifiedBalance(symbol: string): Promise<UserAsset | undefined>;
    /**
     * Bridge tokens between chains
     */
    bridge(params: BridgeParams): Promise<BridgeResult>;
    /**
     * Transfer tokens
     */
    transfer(params: TransferParams): Promise<TransferResult>;
    getEVMProviderWithCA(): EthereumProvider;
    /**
     * Simulate bridge transaction to get costs and fees
     */
    simulateBridge(params: BridgeParams): Promise<SimulationResult>;
    /**
     * Simulate transfer transaction to get costs and fees
     */
    simulateTransfer(params: TransferParams): Promise<SimulationResult>;
    /**
     * Get user's intents with pagination
     */
    getMyIntents(page?: number): Promise<RequestForFunds[]>;
    /**
     * Check allowance for tokens on a specific chain
     */
    getAllowance(chainId?: number, tokens?: string[]): Promise<AllowanceResponse[]>;
    /**
     * Set allowance for a token on a specific chain
     */
    setAllowance(chainId: number, tokens: string[], amount: bigint): Promise<void>;
    /**
     * Revoke allowance for a token on a specific chain
     */
    revokeAllowance(chainId: number, tokens: string[]): Promise<void>;
    /**
     * Set callback for intent status updates
     */
    setOnIntentHook(callback: OnIntentHook): void;
    /**
     * Set callback for allowance approval events
     */
    setOnAllowanceHook(callback: OnAllowanceHook): void;
    /**
     * Subscribe to account changes
     */
    onAccountChanged(callback: (account: string) => void): void;
    /**
     * Subscribe to chain changes
     */
    onChainChanged(callback: (chainId: number) => void): void;
    /**
     * Remove all event listeners
     */
    removeAllListeners(): void;
    deinit(): Promise<void>;
    request(args: RequestArguments): Promise<unknown>;
    on(eventName: string, listener: EventListener): void;
    removeListener(eventName: string, listener: EventListener): void;
    removeAllCaEventListeners(eventName?: string): void;
    /**
     * Standalone function to execute funds into a smart contract
     * @param params execute parameters including contract details and transaction settings
     * @returns Promise resolving to execute result with transaction hash and explorer URL
     */
    execute(params: ExecuteParams): Promise<ExecuteResult>;
    /**
     * Simulate a standalone execute to estimate gas costs and validate parameters
     * @param params execute parameters for simulation
     * @returns Promise resolving to simulation result with gas estimates
     */
    simulateExecute(params: ExecuteParams): Promise<ExecuteSimulation>;
    /**
     * Enhanced bridge and execute function with optional execute step and improved error handling
     * @param params Enhanced bridge and execute parameters
     * @returns Promise resolving to comprehensive operation result
     */
    bridgeAndExecute(params: BridgeAndExecuteParams): Promise<BridgeAndExecuteResult>;
    /**
     * Simulate bridge and execute operation using bridge output amounts for realistic execute cost estimation
     * This method provides more accurate gas estimates by using the actual amount that will be
     * received on the destination chain after bridging (accounting for fees, slippage, etc.)
     * Includes detailed step-by-step breakdown with approval handling.
     */
    simulateBridgeAndExecute(params: BridgeAndExecuteParams): Promise<BridgeAndExecuteSimulationResult>;
}

declare const NexusProvider: ({ config, children }: {
    config?: SDKConfig;
    children: React.ReactNode;
}) => React.JSX.Element;

declare const useNexus: () => {
    setProvider: (provider: _arcana_ca_sdk.EthereumProvider) => void;
    sdk: NexusSDK;
    isSdkInitialized: boolean;
    provider: _arcana_ca_sdk.EthereumProvider | null;
};

interface BaseComponentProps {
    className?: string;
}
interface BridgeConfig extends Partial<BridgeParams> {
}
interface BridgeButtonProps extends BaseComponentProps {
    prefill?: BridgeConfig;
    children: (props: {
        onClick: () => void;
        isLoading: boolean;
    }) => ReactNode;
}
interface TransferConfig extends Partial<TransferParams> {
}
interface TransferButtonProps extends BaseComponentProps {
    prefill?: TransferConfig;
    children: (props: {
        onClick: () => void;
        isLoading: boolean;
    }) => ReactNode;
}
type DynamicParamBuilder = (token: SUPPORTED_TOKENS, amount: string, chainId: SUPPORTED_CHAINS_IDS, userAddress: `0x${string}`) => {
    functionParams: readonly unknown[];
    /** ETH value in wei (string). Omit or '0' for ERC-20 calls */
    value?: string;
};
interface BridgeAndExecuteButtonProps extends BaseComponentProps {
    contractAddress: `0x${string}`;
    contractAbi: Abi;
    functionName: string;
    buildFunctionParams: DynamicParamBuilder;
    prefill?: {
        toChainId?: SUPPORTED_CHAINS_IDS;
        token?: SUPPORTED_TOKENS;
        amount?: string;
    };
    children: (props: {
        onClick: () => void;
        isLoading: boolean;
        disabled: boolean;
    }) => ReactNode;
}

declare function BridgeButton({ prefill, children, className }: BridgeButtonProps): React.JSX.Element;

declare function TransferButton({ prefill, children, className }: TransferButtonProps): React.JSX.Element;

declare function BridgeAndExecuteButton({ contractAddress, contractAbi, functionName, buildFunctionParams, prefill, children, className, }: BridgeAndExecuteButtonProps): React.JSX.Element | null;

export { BridgeAndExecuteButton, BridgeButton, CHAIN_METADATA, MAINNET_CHAINS, NEXUS_EVENTS, NexusProvider, NexusSDK, SUPPORTED_CHAINS, TESTNET_CHAINS, TESTNET_TOKEN_CONTRACT_ADDRESSES, TESTNET_TOKEN_METADATA, TOKEN_CONTRACT_ADDRESSES, TOKEN_METADATA, TransferButton, chainIcons, useNexus };
export type { AllowanceParams, AllowanceResponse, ApprovalInfo, ApprovalSimulation, Block, BlockTransaction, BridgeAndExecuteParams, BridgeAndExecuteResult, BridgeAndExecuteSimulationResult, BridgeParams, BridgeResult, ChainMetadata, ContractCallParams, EventListener, ExecuteParams, ExecuteResult, ExecuteSimulation, NexusNetwork, OnAllowanceHookData, OnIntentHookData, SUPPORTED_CHAINS_IDS, SUPPORTED_TOKENS, SimulationResult, SimulationStep, TokenBalance, TokenInfo, TokenMetadata, TransferParams, TransferResult };
