'use strict';

let wasm$1;

const cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );

if (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); }
let cachedUint8ArrayMemory0 = null;

function getUint8ArrayMemory0() {
    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
        cachedUint8ArrayMemory0 = new Uint8Array(wasm$1.memory.buffer);
    }
    return cachedUint8ArrayMemory0;
}

function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}

function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
}
/**
 * Construct a `GM` instruction from its arguments.
 * @param {number} ra
 * @param {GMArgs} args
 * @returns {Instruction}
 */
function gm_args(ra, args) {
    const ret = wasm$1.gm_args(ra, args);
    return Instruction.__wrap(ret);
}

/**
 * Construct a `GM` instruction from its arguments.
 * @param {number} ra
 * @param {number} rb
 * @param {GTFArgs} args
 * @returns {Instruction}
 */
function gtf_args(ra, rb, args) {
    const ret = wasm$1.gtf_args(ra, rb, args);
    return Instruction.__wrap(ret);
}

/**
 * Construct a `WDCM` instruction from its arguments.
 * @param {number} ra
 * @param {number} rb
 * @param {number} rc
 * @param {CompareArgs} args
 * @returns {Instruction}
 */
function wdcm_args(ra, rb, rc, args) {
    _assertClass(args, CompareArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wdcm_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
 * Construct a `WQCM` instruction from its arguments.
 * @param {number} ra
 * @param {number} rb
 * @param {number} rc
 * @param {CompareArgs} args
 * @returns {Instruction}
 */
function wqcm_args(ra, rb, rc, args) {
    _assertClass(args, CompareArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wqcm_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
 * Construct a `WDOP` instruction from its arguments.
 * @param {number} ra
 * @param {number} rb
 * @param {number} rc
 * @param {MathArgs} args
 * @returns {Instruction}
 */
function wdop_args(ra, rb, rc, args) {
    _assertClass(args, MathArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wdop_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
 * Construct a `WQOP` instruction from its arguments.
 * @param {number} ra
 * @param {number} rb
 * @param {number} rc
 * @param {MathArgs} args
 * @returns {Instruction}
 */
function wqop_args(ra, rb, rc, args) {
    _assertClass(args, MathArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wqop_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
 * Construct a `WDML` instruction from its arguments.
 * @param {number} ra
 * @param {number} rb
 * @param {number} rc
 * @param {MulArgs} args
 * @returns {Instruction}
 */
function wdml_args(ra, rb, rc, args) {
    _assertClass(args, MulArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wdml_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
 * Construct a `WQML` instruction from its arguments.
 * @param {number} ra
 * @param {number} rb
 * @param {number} rc
 * @param {MulArgs} args
 * @returns {Instruction}
 */
function wqml_args(ra, rb, rc, args) {
    _assertClass(args, MulArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wqml_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
 * Construct a `WDDV` instruction from its arguments.
 * @param {number} ra
 * @param {number} rb
 * @param {number} rc
 * @param {DivArgs} args
 * @returns {Instruction}
 */
function wddv_args(ra, rb, rc, args) {
    _assertClass(args, DivArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wddv_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
 * Construct a `WQDV` instruction from its arguments.
 * @param {number} ra
 * @param {number} rb
 * @param {number} rc
 * @param {DivArgs} args
 * @returns {Instruction}
 */
function wqdv_args(ra, rb, rc, args) {
    _assertClass(args, DivArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wqdv_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
 * Adds two registers.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function add(dst, lhs, rhs) {
    const ret = wasm$1.add(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Bitwise ANDs two registers.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function and(dst, lhs, rhs) {
    const ret = wasm$1.and(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Divides two registers.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function div(dst, lhs, rhs) {
    const ret = wasm$1.div(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Compares two registers for equality.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function eq(dst, lhs, rhs) {
    const ret = wasm$1.eq(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Raises one register to the power of another.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function exp(dst, lhs, rhs) {
    const ret = wasm$1.exp(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Compares two registers for greater-than.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function gt(dst, lhs, rhs) {
    const ret = wasm$1.gt(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Compares two registers for less-than.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function lt(dst, lhs, rhs) {
    const ret = wasm$1.lt(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * The integer logarithm of a register.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function mlog(dst, lhs, rhs) {
    const ret = wasm$1.mlog(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * The integer root of a register.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function mroo(dst, lhs, rhs) {
    const ret = wasm$1.mroo(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Modulo remainder of two registers.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function mod_(dst, lhs, rhs) {
    const ret = wasm$1.mod_(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Copy from one register to another.
 * @param {number} dst
 * @param {number} src
 * @returns {Instruction}
 */
function move_(dst, src) {
    const ret = wasm$1.move_(dst, src);
    return Instruction.__wrap(ret);
}

/**
 * Multiplies two registers.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function mul(dst, lhs, rhs) {
    const ret = wasm$1.mul(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Bitwise NOT a register.
 * @param {number} dst
 * @param {number} arg
 * @returns {Instruction}
 */
function not(dst, arg) {
    const ret = wasm$1.not(dst, arg);
    return Instruction.__wrap(ret);
}

/**
 * Bitwise ORs two registers.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function or(dst, lhs, rhs) {
    const ret = wasm$1.or(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Left shifts a register by a register.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function sll(dst, lhs, rhs) {
    const ret = wasm$1.sll(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Right shifts a register by a register.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function srl(dst, lhs, rhs) {
    const ret = wasm$1.srl(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Subtracts two registers.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function sub(dst, lhs, rhs) {
    const ret = wasm$1.sub(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Bitwise XORs two registers.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function xor(dst, lhs, rhs) {
    const ret = wasm$1.xor(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Fused multiply-divide with arbitrary precision intermediate step.
 * @param {number} dst
 * @param {number} mul_lhs
 * @param {number} mul_rhs
 * @param {number} divisor
 * @returns {Instruction}
 */
function mldv(dst, mul_lhs, mul_rhs, divisor) {
    const ret = wasm$1.mldv(dst, mul_lhs, mul_rhs, divisor);
    return Instruction.__wrap(ret);
}

/**
 * Return from context.
 * @param {number} value
 * @returns {Instruction}
 */
function ret(value) {
    const ret = wasm$1.ret(value);
    return Instruction.__wrap(ret);
}

/**
 * Return from context with data.
 * @param {number} addr
 * @param {number} len
 * @returns {Instruction}
 */
function retd(addr, len) {
    const ret = wasm$1.retd(addr, len);
    return Instruction.__wrap(ret);
}

/**
 * Allocate a number of bytes from the heap.
 * @param {number} bytes
 * @returns {Instruction}
 */
function aloc(bytes) {
    const ret = wasm$1.aloc(bytes);
    return Instruction.__wrap(ret);
}

/**
 * Clear a variable number of bytes in memory.
 * @param {number} dst_addr
 * @param {number} len
 * @returns {Instruction}
 */
function mcl(dst_addr, len) {
    const ret = wasm$1.mcl(dst_addr, len);
    return Instruction.__wrap(ret);
}

/**
 * Copy a variable number of bytes in memory.
 * @param {number} dst_addr
 * @param {number} src_addr
 * @param {number} len
 * @returns {Instruction}
 */
function mcp(dst_addr, src_addr, len) {
    const ret = wasm$1.mcp(dst_addr, src_addr, len);
    return Instruction.__wrap(ret);
}

/**
 * Compare bytes in memory.
 * @param {number} result
 * @param {number} lhs_addr
 * @param {number} rhs_addr
 * @param {number} len
 * @returns {Instruction}
 */
function meq(result, lhs_addr, rhs_addr, len) {
    const ret = wasm$1.meq(result, lhs_addr, rhs_addr, len);
    return Instruction.__wrap(ret);
}

/**
 * Get block header hash for height.
 * @param {number} dst
 * @param {number} heigth
 * @returns {Instruction}
 */
function bhsh(dst, heigth) {
    const ret = wasm$1.bhsh(dst, heigth);
    return Instruction.__wrap(ret);
}

/**
 * Get current block height.
 * @param {number} dst
 * @returns {Instruction}
 */
function bhei(dst) {
    const ret = wasm$1.bhei(dst);
    return Instruction.__wrap(ret);
}

/**
 * Burns `amount` coins of the asset ID created from `sub_id` for the current contract.
 * @param {number} amount
 * @param {number} sub_id_addr
 * @returns {Instruction}
 */
function burn(amount, sub_id_addr) {
    const ret = wasm$1.burn(amount, sub_id_addr);
    return Instruction.__wrap(ret);
}

/**
 * Call a contract.
 * @param {number} target_struct
 * @param {number} fwd_coins
 * @param {number} asset_id_addr
 * @param {number} fwd_gas
 * @returns {Instruction}
 */
function call(target_struct, fwd_coins, asset_id_addr, fwd_gas) {
    const ret = wasm$1.call(target_struct, fwd_coins, asset_id_addr, fwd_gas);
    return Instruction.__wrap(ret);
}

/**
 * Copy contract code for a contract.
 * @param {number} dst_addr
 * @param {number} contract_id_addr
 * @param {number} offset
 * @param {number} len
 * @returns {Instruction}
 */
function ccp(dst_addr, contract_id_addr, offset, len) {
    const ret = wasm$1.ccp(dst_addr, contract_id_addr, offset, len);
    return Instruction.__wrap(ret);
}

/**
 * Get code root of a contract.
 * @param {number} dst_addr
 * @param {number} contract_id_addr
 * @returns {Instruction}
 */
function croo(dst_addr, contract_id_addr) {
    const ret = wasm$1.croo(dst_addr, contract_id_addr);
    return Instruction.__wrap(ret);
}

/**
 * Get code size of a contract.
 * @param {number} dst
 * @param {number} contract_id_addr
 * @returns {Instruction}
 */
function csiz(dst, contract_id_addr) {
    const ret = wasm$1.csiz(dst, contract_id_addr);
    return Instruction.__wrap(ret);
}

/**
 * Get current block proposer's address.
 * @param {number} dst
 * @returns {Instruction}
 */
function cb(dst) {
    const ret = wasm$1.cb(dst);
    return Instruction.__wrap(ret);
}

/**
 * Load code as executable either from contract, blob, or memory.
 * @param {number} src_addr
 * @param {number} offset
 * @param {number} len
 * @param {number} mode
 * @returns {Instruction}
 */
function ldc(src_addr, offset, len, mode) {
    const ret = wasm$1.ldc(src_addr, offset, len, mode);
    return Instruction.__wrap(ret);
}

/**
 * Log an event.
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @param {number} d
 * @returns {Instruction}
 */
function log(a, b, c, d) {
    const ret = wasm$1.log(a, b, c, d);
    return Instruction.__wrap(ret);
}

/**
 * Log data.
 * @param {number} a
 * @param {number} b
 * @param {number} addr
 * @param {number} len
 * @returns {Instruction}
 */
function logd(a, b, addr, len) {
    const ret = wasm$1.logd(a, b, addr, len);
    return Instruction.__wrap(ret);
}

/**
 * Mints `amount` coins of the asset ID created from `sub_id` for the current contract.
 * @param {number} amount
 * @param {number} sub_id_addr
 * @returns {Instruction}
 */
function mint(amount, sub_id_addr) {
    const ret = wasm$1.mint(amount, sub_id_addr);
    return Instruction.__wrap(ret);
}

/**
 * Halt execution, reverting state changes and returning a value.
 * @param {number} value
 * @returns {Instruction}
 */
function rvrt(value) {
    const ret = wasm$1.rvrt(value);
    return Instruction.__wrap(ret);
}

/**
 * Clear a series of slots from contract storage.
 * @param {number} key_addr
 * @param {number} status
 * @param {number} lenq
 * @returns {Instruction}
 */
function scwq(key_addr, status, lenq) {
    const ret = wasm$1.scwq(key_addr, status, lenq);
    return Instruction.__wrap(ret);
}

/**
 * Load a word from contract storage.
 * @param {number} dst
 * @param {number} status
 * @param {number} key_addr
 * @returns {Instruction}
 */
function srw(dst, status, key_addr) {
    const ret = wasm$1.srw(dst, status, key_addr);
    return Instruction.__wrap(ret);
}

/**
 * Load a series of 32 byte slots from contract storage.
 * @param {number} dst_addr
 * @param {number} status
 * @param {number} key_addr
 * @param {number} lenq
 * @returns {Instruction}
 */
function srwq(dst_addr, status, key_addr, lenq) {
    const ret = wasm$1.srwq(dst_addr, status, key_addr, lenq);
    return Instruction.__wrap(ret);
}

/**
 * Store a word in contract storage.
 * @param {number} key_addr
 * @param {number} status
 * @param {number} value
 * @returns {Instruction}
 */
function sww(key_addr, status, value) {
    const ret = wasm$1.sww(key_addr, status, value);
    return Instruction.__wrap(ret);
}

/**
 * Store a series of 32 byte slots in contract storage.
 * @param {number} key_addr
 * @param {number} status
 * @param {number} src_addr
 * @param {number} lenq
 * @returns {Instruction}
 */
function swwq(key_addr, status, src_addr, lenq) {
    const ret = wasm$1.swwq(key_addr, status, src_addr, lenq);
    return Instruction.__wrap(ret);
}

/**
 * Transfer coins to a contract unconditionally.
 * @param {number} contract_id_addr
 * @param {number} amount
 * @param {number} asset_id_addr
 * @returns {Instruction}
 */
function tr(contract_id_addr, amount, asset_id_addr) {
    const ret = wasm$1.tr(contract_id_addr, amount, asset_id_addr);
    return Instruction.__wrap(ret);
}

/**
 * Transfer coins to a variable output.
 * @param {number} contract_id_addr
 * @param {number} output_index
 * @param {number} amount
 * @param {number} asset_id_addr
 * @returns {Instruction}
 */
function tro(contract_id_addr, output_index, amount, asset_id_addr) {
    const ret = wasm$1.tro(contract_id_addr, output_index, amount, asset_id_addr);
    return Instruction.__wrap(ret);
}

/**
 * The 64-byte public key (x, y) recovered from 64-byte signature on 32-byte message hash.
 * @param {number} dst_addr
 * @param {number} sig_addr
 * @param {number} msg_hash_addr
 * @returns {Instruction}
 */
function eck1(dst_addr, sig_addr, msg_hash_addr) {
    const ret = wasm$1.eck1(dst_addr, sig_addr, msg_hash_addr);
    return Instruction.__wrap(ret);
}

/**
 * The 64-byte Secp256r1 public key (x, y) recovered from 64-byte signature on 32-byte message hash.
 * @param {number} dst_addr
 * @param {number} sig_addr
 * @param {number} msg_hash_addr
 * @returns {Instruction}
 */
function ecr1(dst_addr, sig_addr, msg_hash_addr) {
    const ret = wasm$1.ecr1(dst_addr, sig_addr, msg_hash_addr);
    return Instruction.__wrap(ret);
}

/**
 * Verify ED25519 public key and signature match a message.
 * @param {number} pub_key_addr
 * @param {number} sig_addr
 * @param {number} msg_addr
 * @param {number} msg_len
 * @returns {Instruction}
 */
function ed19(pub_key_addr, sig_addr, msg_addr, msg_len) {
    const ret = wasm$1.ed19(pub_key_addr, sig_addr, msg_addr, msg_len);
    return Instruction.__wrap(ret);
}

/**
 * The keccak-256 hash of a slice.
 * @param {number} dst_addr
 * @param {number} src_addr
 * @param {number} len
 * @returns {Instruction}
 */
function k256(dst_addr, src_addr, len) {
    const ret = wasm$1.k256(dst_addr, src_addr, len);
    return Instruction.__wrap(ret);
}

/**
 * The SHA-2-256 hash of a slice.
 * @param {number} dst_addr
 * @param {number} src_addr
 * @param {number} len
 * @returns {Instruction}
 */
function s256(dst_addr, src_addr, len) {
    const ret = wasm$1.s256(dst_addr, src_addr, len);
    return Instruction.__wrap(ret);
}

/**
 * Get timestamp of block at given height.
 * @param {number} dst
 * @param {number} heigth
 * @returns {Instruction}
 */
function time(dst, heigth) {
    const ret = wasm$1.time(dst, heigth);
    return Instruction.__wrap(ret);
}

/**
 * Performs no operation.
 * @returns {Instruction}
 */
function noop() {
    const ret = wasm$1.noop();
    return Instruction.__wrap(ret);
}

/**
 * Set flag register to a register.
 * @param {number} value
 * @returns {Instruction}
 */
function flag(value) {
    const ret = wasm$1.flag(value);
    return Instruction.__wrap(ret);
}

/**
 * Get the balance of contract of an asset ID.
 * @param {number} dst
 * @param {number} asset_id_addr
 * @param {number} contract_id_addr
 * @returns {Instruction}
 */
function bal(dst, asset_id_addr, contract_id_addr) {
    const ret = wasm$1.bal(dst, asset_id_addr, contract_id_addr);
    return Instruction.__wrap(ret);
}

/**
 * Dynamic jump.
 * @param {number} abs_target
 * @returns {Instruction}
 */
function jmp(abs_target) {
    const ret = wasm$1.jmp(abs_target);
    return Instruction.__wrap(ret);
}

/**
 * Conditional dynamic jump.
 * @param {number} abs_target
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function jne(abs_target, lhs, rhs) {
    const ret = wasm$1.jne(abs_target, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Send a message to recipient address with call abi, coins, and output.
 * @param {number} recipient_addr
 * @param {number} data_addr
 * @param {number} data_len
 * @param {number} coins
 * @returns {Instruction}
 */
function smo(recipient_addr, data_addr, data_len, coins) {
    const ret = wasm$1.smo(recipient_addr, data_addr, data_len, coins);
    return Instruction.__wrap(ret);
}

/**
 * Adds a register and an immediate value.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function addi(dst, lhs, rhs) {
    const ret = wasm$1.addi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Bitwise ANDs a register and an immediate value.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function andi(dst, lhs, rhs) {
    const ret = wasm$1.andi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Divides a register and an immediate value.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function divi(dst, lhs, rhs) {
    const ret = wasm$1.divi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Raises one register to the power of an immediate value.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function expi(dst, lhs, rhs) {
    const ret = wasm$1.expi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Modulo remainder of a register and an immediate value.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function modi(dst, lhs, rhs) {
    const ret = wasm$1.modi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Multiplies a register and an immediate value.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function muli(dst, lhs, rhs) {
    const ret = wasm$1.muli(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Bitwise ORs a register and an immediate value.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function ori(dst, lhs, rhs) {
    const ret = wasm$1.ori(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Left shifts a register by an immediate value.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function slli(dst, lhs, rhs) {
    const ret = wasm$1.slli(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Right shifts a register by an immediate value.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function srli(dst, lhs, rhs) {
    const ret = wasm$1.srli(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Subtracts a register and an immediate value.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function subi(dst, lhs, rhs) {
    const ret = wasm$1.subi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Bitwise XORs a register and an immediate value.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function xori(dst, lhs, rhs) {
    const ret = wasm$1.xori(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Conditional jump.
 * @param {number} cond_lhs
 * @param {number} cond_rhs
 * @param {number} abs_target
 * @returns {Instruction}
 */
function jnei(cond_lhs, cond_rhs, abs_target) {
    const ret = wasm$1.jnei(cond_lhs, cond_rhs, abs_target);
    return Instruction.__wrap(ret);
}

/**
 * A byte is loaded from the specified address offset by an immediate value.
 * @param {number} dst
 * @param {number} addr
 * @param {number} offset
 * @returns {Instruction}
 */
function lb(dst, addr, offset) {
    const ret = wasm$1.lb(dst, addr, offset);
    return Instruction.__wrap(ret);
}

/**
 * A word is loaded from the specified address offset by an immediate value.
 * @param {number} dst
 * @param {number} addr
 * @param {number} offset
 * @returns {Instruction}
 */
function lw(dst, addr, offset) {
    const ret = wasm$1.lw(dst, addr, offset);
    return Instruction.__wrap(ret);
}

/**
 * Write the least significant byte of a register to memory.
 * @param {number} addr
 * @param {number} value
 * @param {number} offset
 * @returns {Instruction}
 */
function sb(addr, value, offset) {
    const ret = wasm$1.sb(addr, value, offset);
    return Instruction.__wrap(ret);
}

/**
 * Write a register to memory.
 * @param {number} addr
 * @param {number} value
 * @param {number} offset
 * @returns {Instruction}
 */
function sw(addr, value, offset) {
    const ret = wasm$1.sw(addr, value, offset);
    return Instruction.__wrap(ret);
}

/**
 * Copy an immediate number of bytes in memory.
 * @param {number} dst_addr
 * @param {number} src_addr
 * @param {number} len
 * @returns {Instruction}
 */
function mcpi(dst_addr, src_addr, len) {
    const ret = wasm$1.mcpi(dst_addr, src_addr, len);
    return Instruction.__wrap(ret);
}

/**
 * Get transaction fields.
 * @param {number} dst
 * @param {number} arg
 * @param {number} selector
 * @returns {Instruction}
 */
function gtf(dst, arg, selector) {
    const ret = wasm$1.gtf(dst, arg, selector);
    return Instruction.__wrap(ret);
}

/**
 * Clear an immediate number of bytes in memory.
 * @param {number} addr
 * @param {number} count
 * @returns {Instruction}
 */
function mcli(addr, count) {
    const ret = wasm$1.mcli(addr, count);
    return Instruction.__wrap(ret);
}

/**
 * Get metadata from memory.
 * @param {number} dst
 * @param {number} selector
 * @returns {Instruction}
 */
function gm(dst, selector) {
    const ret = wasm$1.gm(dst, selector);
    return Instruction.__wrap(ret);
}

/**
 * Copy immediate value into a register
 * @param {number} dst
 * @param {number} val
 * @returns {Instruction}
 */
function movi(dst, val) {
    const ret = wasm$1.movi(dst, val);
    return Instruction.__wrap(ret);
}

/**
 * Conditional jump against zero.
 * @param {number} cond_nz
 * @param {number} abs_target
 * @returns {Instruction}
 */
function jnzi(cond_nz, abs_target) {
    const ret = wasm$1.jnzi(cond_nz, abs_target);
    return Instruction.__wrap(ret);
}

/**
 * Unconditional dynamic relative jump forwards, with a constant offset.
 * @param {number} dynamic
 * @param {number} fixed
 * @returns {Instruction}
 */
function jmpf(dynamic, fixed) {
    const ret = wasm$1.jmpf(dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
 * Unconditional dynamic relative jump backwards, with a constant offset.
 * @param {number} dynamic
 * @param {number} fixed
 * @returns {Instruction}
 */
function jmpb(dynamic, fixed) {
    const ret = wasm$1.jmpb(dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
 * Dynamic relative jump forwards, conditional against zero, with a constant offset.
 * @param {number} cond_nz
 * @param {number} dynamic
 * @param {number} fixed
 * @returns {Instruction}
 */
function jnzf(cond_nz, dynamic, fixed) {
    const ret = wasm$1.jnzf(cond_nz, dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
 * Dynamic relative jump backwards, conditional against zero, with a constant offset.
 * @param {number} cond_nz
 * @param {number} dynamic
 * @param {number} fixed
 * @returns {Instruction}
 */
function jnzb(cond_nz, dynamic, fixed) {
    const ret = wasm$1.jnzb(cond_nz, dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
 * Dynamic relative jump forwards, conditional on comparsion, with a constant offset.
 * @param {number} cond_lhs
 * @param {number} cond_rhs
 * @param {number} dynamic
 * @param {number} fixed
 * @returns {Instruction}
 */
function jnef(cond_lhs, cond_rhs, dynamic, fixed) {
    const ret = wasm$1.jnef(cond_lhs, cond_rhs, dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
 * Dynamic relative jump backwards, conditional on comparsion, with a constant offset.
 * @param {number} cond_lhs
 * @param {number} cond_rhs
 * @param {number} dynamic
 * @param {number} fixed
 * @returns {Instruction}
 */
function jneb(cond_lhs, cond_rhs, dynamic, fixed) {
    const ret = wasm$1.jneb(cond_lhs, cond_rhs, dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
 * Jump.
 * @param {number} abs_target
 * @returns {Instruction}
 */
function ji(abs_target) {
    const ret = wasm$1.ji(abs_target);
    return Instruction.__wrap(ret);
}

/**
 * Extend the current call frame's stack by an immediate value.
 * @param {number} amount
 * @returns {Instruction}
 */
function cfei(amount) {
    const ret = wasm$1.cfei(amount);
    return Instruction.__wrap(ret);
}

/**
 * Shrink the current call frame's stack by an immediate value.
 * @param {number} amount
 * @returns {Instruction}
 */
function cfsi(amount) {
    const ret = wasm$1.cfsi(amount);
    return Instruction.__wrap(ret);
}

/**
 * Extend the current call frame's stack
 * @param {number} amount
 * @returns {Instruction}
 */
function cfe(amount) {
    const ret = wasm$1.cfe(amount);
    return Instruction.__wrap(ret);
}

/**
 * Shrink the current call frame's stack
 * @param {number} amount
 * @returns {Instruction}
 */
function cfs(amount) {
    const ret = wasm$1.cfs(amount);
    return Instruction.__wrap(ret);
}

/**
 * Push a bitmask-selected set of registers in range 16..40 to the stack.
 * @param {number} bitmask
 * @returns {Instruction}
 */
function pshl(bitmask) {
    const ret = wasm$1.pshl(bitmask);
    return Instruction.__wrap(ret);
}

/**
 * Push a bitmask-selected set of registers in range 40..64 to the stack.
 * @param {number} bitmask
 * @returns {Instruction}
 */
function pshh(bitmask) {
    const ret = wasm$1.pshh(bitmask);
    return Instruction.__wrap(ret);
}

/**
 * Pop a bitmask-selected set of registers in range 16..40 to the stack.
 * @param {number} bitmask
 * @returns {Instruction}
 */
function popl(bitmask) {
    const ret = wasm$1.popl(bitmask);
    return Instruction.__wrap(ret);
}

/**
 * Pop a bitmask-selected set of registers in range 40..64 to the stack.
 * @param {number} bitmask
 * @returns {Instruction}
 */
function poph(bitmask) {
    const ret = wasm$1.poph(bitmask);
    return Instruction.__wrap(ret);
}

/**
 * Compare 128bit integers
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @param {number} flags
 * @returns {Instruction}
 */
function wdcm(dst, lhs, rhs, flags) {
    const ret = wasm$1.wdcm(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
 * Compare 256bit integers
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @param {number} flags
 * @returns {Instruction}
 */
function wqcm(dst, lhs, rhs, flags) {
    const ret = wasm$1.wqcm(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
 * Simple 128bit operations
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @param {number} flags
 * @returns {Instruction}
 */
function wdop(dst, lhs, rhs, flags) {
    const ret = wasm$1.wdop(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
 * Simple 256bit operations
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @param {number} flags
 * @returns {Instruction}
 */
function wqop(dst, lhs, rhs, flags) {
    const ret = wasm$1.wqop(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
 * Multiply 128bit
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @param {number} flags
 * @returns {Instruction}
 */
function wdml(dst, lhs, rhs, flags) {
    const ret = wasm$1.wdml(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
 * Multiply 256bit
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @param {number} flags
 * @returns {Instruction}
 */
function wqml(dst, lhs, rhs, flags) {
    const ret = wasm$1.wqml(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
 * Divide 128bit
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @param {number} flags
 * @returns {Instruction}
 */
function wddv(dst, lhs, rhs, flags) {
    const ret = wasm$1.wddv(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
 * Divide 256bit
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @param {number} flags
 * @returns {Instruction}
 */
function wqdv(dst, lhs, rhs, flags) {
    const ret = wasm$1.wqdv(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
 * Fused multiply-divide 128bit
 * @param {number} dst
 * @param {number} mul_lhs
 * @param {number} mul_rhs
 * @param {number} divisor
 * @returns {Instruction}
 */
function wdmd(dst, mul_lhs, mul_rhs, divisor) {
    const ret = wasm$1.wdmd(dst, mul_lhs, mul_rhs, divisor);
    return Instruction.__wrap(ret);
}

/**
 * Fused multiply-divide 256bit
 * @param {number} dst
 * @param {number} mul_lhs
 * @param {number} mul_rhs
 * @param {number} divisor
 * @returns {Instruction}
 */
function wqmd(dst, mul_lhs, mul_rhs, divisor) {
    const ret = wasm$1.wqmd(dst, mul_lhs, mul_rhs, divisor);
    return Instruction.__wrap(ret);
}

/**
 * AddMod 128bit
 * @param {number} dst
 * @param {number} add_lhs
 * @param {number} add_rhs
 * @param {number} modulo
 * @returns {Instruction}
 */
function wdam(dst, add_lhs, add_rhs, modulo) {
    const ret = wasm$1.wdam(dst, add_lhs, add_rhs, modulo);
    return Instruction.__wrap(ret);
}

/**
 * AddMod 256bit
 * @param {number} dst
 * @param {number} add_lhs
 * @param {number} add_rhs
 * @param {number} modulo
 * @returns {Instruction}
 */
function wqam(dst, add_lhs, add_rhs, modulo) {
    const ret = wasm$1.wqam(dst, add_lhs, add_rhs, modulo);
    return Instruction.__wrap(ret);
}

/**
 * MulMod 128bit
 * @param {number} dst
 * @param {number} mul_lhs
 * @param {number} mul_rhs
 * @param {number} modulo
 * @returns {Instruction}
 */
function wdmm(dst, mul_lhs, mul_rhs, modulo) {
    const ret = wasm$1.wdmm(dst, mul_lhs, mul_rhs, modulo);
    return Instruction.__wrap(ret);
}

/**
 * MulMod 256bit
 * @param {number} dst
 * @param {number} mul_lhs
 * @param {number} mul_rhs
 * @param {number} modulo
 * @returns {Instruction}
 */
function wqmm(dst, mul_lhs, mul_rhs, modulo) {
    const ret = wasm$1.wqmm(dst, mul_lhs, mul_rhs, modulo);
    return Instruction.__wrap(ret);
}

/**
 * Call external function
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @param {number} d
 * @returns {Instruction}
 */
function ecal(a, b, c, d) {
    const ret = wasm$1.ecal(a, b, c, d);
    return Instruction.__wrap(ret);
}

/**
 * Get blob size
 * @param {number} dst
 * @param {number} blob_id_ptr
 * @returns {Instruction}
 */
function bsiz(dst, blob_id_ptr) {
    const ret = wasm$1.bsiz(dst, blob_id_ptr);
    return Instruction.__wrap(ret);
}

/**
 * Load blob as data
 * @param {number} dst_ptr
 * @param {number} blob_id_ptr
 * @param {number} offset
 * @param {number} len
 * @returns {Instruction}
 */
function bldd(dst_ptr, blob_id_ptr, offset, len) {
    const ret = wasm$1.bldd(dst_ptr, blob_id_ptr, offset, len);
    return Instruction.__wrap(ret);
}

/**
 * Given some curve, performs an operation on points
 * @param {number} dst
 * @param {number} curve_id
 * @param {number} operation_type
 * @param {number} points_ptr
 * @returns {Instruction}
 */
function ecop(dst, curve_id, operation_type, points_ptr) {
    const ret = wasm$1.ecop(dst, curve_id, operation_type, points_ptr);
    return Instruction.__wrap(ret);
}

/**
 * Given some curve, performs a pairing on groups of points
 * @param {number} success
 * @param {number} curve_id
 * @param {number} number_elements
 * @param {number} points_ptr
 * @returns {Instruction}
 */
function epar(success, curve_id, number_elements, points_ptr) {
    const ret = wasm$1.epar(success, curve_id, number_elements, points_ptr);
    return Instruction.__wrap(ret);
}

let cachedDataViewMemory0 = null;

function getDataViewMemory0() {
    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm$1.memory.buffer)) {
        cachedDataViewMemory0 = new DataView(wasm$1.memory.buffer);
    }
    return cachedDataViewMemory0;
}

function getArrayU8FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
}
/**
 * Comparison mode used by WDCM and WQCM instructions.
 * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6}
 */
const CompareMode = Object.freeze({
    /**
     * Equality (`==`)
     */
    EQ: 0, "0": "EQ",
    /**
     * Inequality (`!=`)
     */
    NE: 1, "1": "NE",
    /**
     * Less than (`<`)
     */
    LT: 2, "2": "LT",
    /**
     * Greater than (`>`)
     */
    GT: 3, "3": "GT",
    /**
     * Less than or equals (`>=`)
     */
    LTE: 4, "4": "LTE",
    /**
     * Greater than or equals (`>=`)
     */
    GTE: 5, "5": "GTE",
    /**
     * Number of leading zeroes in lhs (`lzcnt`) (discards rhs)
     */
    LZC: 6, "6": "LZC",
});
/**
 * r" Argument list for GM (get metadata) instruction
 * r" The VM is the only who should match this struct, and it *MUST* always perform
 * r" exhaustive match so all offered variants are covered.
 * @enum {1 | 2 | 3 | 4 | 5 | 6 | 7}
 */
const GMArgs = Object.freeze({
    /**
     * r" Get if caller is external.
     */
    IsCallerExternal: 1, "1": "IsCallerExternal",
    /**
     * r" Get caller's contract ID.
     */
    GetCaller: 2, "2": "GetCaller",
    /**
     * r" Get index of current predicate.
     */
    GetVerifyingPredicate: 3, "3": "GetVerifyingPredicate",
    /**
     * r" Get the Chain ID this VM is operating within
     */
    GetChainId: 4, "4": "GetChainId",
    /**
     * r" Get memory address where the transaction is located
     */
    TxStart: 5, "5": "TxStart",
    /**
     * r" Get memory address of base asset ID
     */
    BaseAssetId: 6, "6": "BaseAssetId",
    /**
     * r" Get gas price for block
     */
    GetGasPrice: 7, "7": "GetGasPrice",
});
/**
 * r" Argument list for GTF (get tx fields) instruction
 * r" The VM is the only who should match this struct, and it *MUST* always perform
 * r" exhaustive match so all offered variants are covered.
 * @enum {1 | 2 | 3 | 4 | 5 | 6 | 7 | 9 | 10 | 11 | 12 | 13 | 14 | 257 | 258 | 259 | 260 | 261 | 262 | 263 | 264 | 265 | 266 | 512 | 513 | 514 | 515 | 516 | 517 | 518 | 519 | 521 | 522 | 523 | 524 | 525 | 544 | 545 | 549 | 576 | 577 | 578 | 579 | 580 | 581 | 582 | 583 | 584 | 585 | 586 | 587 | 768 | 769 | 770 | 771 | 772 | 775 | 776 | 1024 | 1025 | 1280 | 1281 | 1282 | 1283 | 1284 | 1285 | 1536 | 1537 | 1538 | 1539 | 1540 | 1541 | 1792 | 1793 | 2048 | 2304 | 2305 | 2306 | 2307 | 2308 | 2309}
 */
const GTFArgs = Object.freeze({
    /**
     * r" Set `$rA` to `tx.type`
     */
    Type: 1, "1": "Type",
    /**
     * r" Set `$rA` to `tx.scriptGasLimit`
     */
    ScriptGasLimit: 2, "2": "ScriptGasLimit",
    /**
     * r" Set `$rA` to `tx.scriptLength`
     */
    ScriptLength: 3, "3": "ScriptLength",
    /**
     * r" Set `$rA` to `tx.scriptDataLength`
     */
    ScriptDataLength: 4, "4": "ScriptDataLength",
    /**
     * r" Set `$rA` to `tx.inputsCount`
     */
    ScriptInputsCount: 5, "5": "ScriptInputsCount",
    /**
     * r" Set `$rA` to `tx.outputsCount`
     */
    ScriptOutputsCount: 6, "6": "ScriptOutputsCount",
    /**
     * r" Set `$rA` to `tx.witnessesCount`
     */
    ScriptWitnessesCount: 7, "7": "ScriptWitnessesCount",
    /**
     * r" Set `$rA` to `Memory address of tx.script`
     */
    Script: 9, "9": "Script",
    /**
     * r" Set `$rA` to `Memory address of tx.scriptData`
     */
    ScriptData: 10, "10": "ScriptData",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB]`
     */
    ScriptInputAtIndex: 11, "11": "ScriptInputAtIndex",
    /**
     * r" Set `$rA` to `Memory address of t.outputs[$rB]`
     */
    ScriptOutputAtIndex: 12, "12": "ScriptOutputAtIndex",
    /**
     * r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
     */
    ScriptWitnessAtIndex: 13, "13": "ScriptWitnessAtIndex",
    /**
     * r" Set `$rA` to size of the transaction in memory, in bytes
     */
    TxLength: 14, "14": "TxLength",
    /**
     * r" Set `$rA` to `tx.bytecodeWitnessIndex`
     */
    CreateBytecodeWitnessIndex: 257, "257": "CreateBytecodeWitnessIndex",
    /**
     * r" Set `$rA` to `tx.storageSlotsCount`
     */
    CreateStorageSlotsCount: 258, "258": "CreateStorageSlotsCount",
    /**
     * r" Set `$rA` to `tx.inputsCount`
     */
    CreateInputsCount: 259, "259": "CreateInputsCount",
    /**
     * r" Set `$rA` to `tx.outputsCount`
     */
    CreateOutputsCount: 260, "260": "CreateOutputsCount",
    /**
     * r" Set `$rA` to `tx.witnessesCount`
     */
    CreateWitnessesCount: 261, "261": "CreateWitnessesCount",
    /**
     * r" Set `$rA` to `Memory address of tx.salt`
     */
    CreateSalt: 262, "262": "CreateSalt",
    /**
     * r" Set `$rA` to `Memory address of tx.storageSlots[$rB]`
     */
    CreateStorageSlotAtIndex: 263, "263": "CreateStorageSlotAtIndex",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB]`
     */
    CreateInputAtIndex: 264, "264": "CreateInputAtIndex",
    /**
     * r" Set `$rA` to `Memory address of t.outputs[$rB]`
     */
    CreateOutputAtIndex: 265, "265": "CreateOutputAtIndex",
    /**
     * r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
     */
    CreateWitnessAtIndex: 266, "266": "CreateWitnessAtIndex",
    /**
     * r" Set `$rA` to `tx.inputs[$rB].type`
     */
    InputType: 512, "512": "InputType",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].txID`
     */
    InputCoinTxId: 513, "513": "InputCoinTxId",
    /**
     * r" Set `$rA` to `tx.inputs[$rB].outputIndex`
     */
    InputCoinOutputIndex: 514, "514": "InputCoinOutputIndex",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].owner`
     */
    InputCoinOwner: 515, "515": "InputCoinOwner",
    /**
     * r" Set `$rA` to `tx.inputs[$rB].amount`
     */
    InputCoinAmount: 516, "516": "InputCoinAmount",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].asset_id`
     */
    InputCoinAssetId: 517, "517": "InputCoinAssetId",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].txPointer`
     */
    InputCoinTxPointer: 518, "518": "InputCoinTxPointer",
    /**
     * r" Set `$rA` to `tx.inputs[$rB].witnessIndex`
     */
    InputCoinWitnessIndex: 519, "519": "InputCoinWitnessIndex",
    /**
     * r" Set `$rA` to `tx.inputs[$rB].predicateLength`
     */
    InputCoinPredicateLength: 521, "521": "InputCoinPredicateLength",
    /**
     * r" Set `$rA` to `tx.inputs[$rB].predicateDataLength`
     */
    InputCoinPredicateDataLength: 522, "522": "InputCoinPredicateDataLength",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].predicate`
     */
    InputCoinPredicate: 523, "523": "InputCoinPredicate",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateData`
     */
    InputCoinPredicateData: 524, "524": "InputCoinPredicateData",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateGasUsed`
     */
    InputCoinPredicateGasUsed: 525, "525": "InputCoinPredicateGasUsed",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].txID`
     */
    InputContractTxId: 544, "544": "InputContractTxId",
    /**
     * r" Set `$rA` to `tx.inputs[$rB].outputIndex`
     */
    InputContractOutputIndex: 545, "545": "InputContractOutputIndex",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].contractID`
     */
    InputContractId: 549, "549": "InputContractId",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].sender`
     */
    InputMessageSender: 576, "576": "InputMessageSender",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].recipient`
     */
    InputMessageRecipient: 577, "577": "InputMessageRecipient",
    /**
     * r" Set `$rA` to `tx.inputs[$rB].amount`
     */
    InputMessageAmount: 578, "578": "InputMessageAmount",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].nonce`
     */
    InputMessageNonce: 579, "579": "InputMessageNonce",
    /**
     * r" Set `$rA` to `tx.inputs[$rB].witnessIndex`
     */
    InputMessageWitnessIndex: 580, "580": "InputMessageWitnessIndex",
    /**
     * r" Set `$rA` to `tx.inputs[$rB].dataLength`
     */
    InputMessageDataLength: 581, "581": "InputMessageDataLength",
    /**
     * r" Set `$rA` to `tx.inputs[$rB].predicateLength`
     */
    InputMessagePredicateLength: 582, "582": "InputMessagePredicateLength",
    /**
     * r" Set `$rA` to `tx.inputs[$rB].predicateDataLength`
     */
    InputMessagePredicateDataLength: 583, "583": "InputMessagePredicateDataLength",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].data`
     */
    InputMessageData: 584, "584": "InputMessageData",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].predicate`
     */
    InputMessagePredicate: 585, "585": "InputMessagePredicate",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateData`
     */
    InputMessagePredicateData: 586, "586": "InputMessagePredicateData",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateGasUsed`
     */
    InputMessagePredicateGasUsed: 587, "587": "InputMessagePredicateGasUsed",
    /**
     * r" Set `$rA` to `tx.outputs[$rB].type`
     */
    OutputType: 768, "768": "OutputType",
    /**
     * r" Set `$rA` to `Memory address of tx.outputs[$rB].to`
     */
    OutputCoinTo: 769, "769": "OutputCoinTo",
    /**
     * r" Set `$rA` to `tx.outputs[$rB].amount`
     */
    OutputCoinAmount: 770, "770": "OutputCoinAmount",
    /**
     * r" Set `$rA` to `Memory address of tx.outputs[$rB].asset_id`
     */
    OutputCoinAssetId: 771, "771": "OutputCoinAssetId",
    /**
     * r" Set `$rA` to `tx.outputs[$rB].inputIndex`
     */
    OutputContractInputIndex: 772, "772": "OutputContractInputIndex",
    /**
     * r" Set `$rA` to `Memory address of tx.outputs[$rB].contractID`
     */
    OutputContractCreatedContractId: 775, "775": "OutputContractCreatedContractId",
    /**
     * r" Set `$rA` to `Memory address of tx.outputs[$rB].stateRoot`
     */
    OutputContractCreatedStateRoot: 776, "776": "OutputContractCreatedStateRoot",
    /**
     * r" Set `$rA` to `tx.witnesses[$rB].dataLength`
     */
    WitnessDataLength: 1024, "1024": "WitnessDataLength",
    /**
     * r" Set `$rA` to `Memory address of tx.witnesses[$rB].data`
     */
    WitnessData: 1025, "1025": "WitnessData",
    /**
     * r" Set `$rA` to `tx.policyTypes`
     */
    PolicyTypes: 1280, "1280": "PolicyTypes",
    /**
     * r" Set `$rA` to `tx.policies[0x00].gasPrice`
     */
    PolicyTip: 1281, "1281": "PolicyTip",
    /**
     * r" Set `$rA` to `tx.policies[count_ones(0b11 & tx.policyTypes) - 1].witnessLimit`
     */
    PolicyWitnessLimit: 1282, "1282": "PolicyWitnessLimit",
    /**
     * r" Set `$rA` to `tx.policies[count_ones(0b111 & tx.policyTypes) - 1].maturity`
     */
    PolicyMaturity: 1283, "1283": "PolicyMaturity",
    /**
     * r" Set `$rA` to `tx.policies[count_ones(0b1111 & tx.policyTypes) - 1].maxFee`
     */
    PolicyMaxFee: 1284, "1284": "PolicyMaxFee",
    /**
     * r" Set `$rA` to `tx.policies[count_ones(0b11111 & tx.policyTypes) - 1].expiration`
     */
    PolicyExpiration: 1285, "1285": "PolicyExpiration",
    /**
     * r" Set `$rA` to `Memory address of tx.root`
     */
    UploadRoot: 1536, "1536": "UploadRoot",
    /**
     * r" Set `$rA` to `tx.witnessIndex`
     */
    UploadWitnessIndex: 1537, "1537": "UploadWitnessIndex",
    /**
     * r" Set `$rA` to `tx.subsectionIndex`
     */
    UploadSubsectionIndex: 1538, "1538": "UploadSubsectionIndex",
    /**
     * r" Set `$rA` to `tx.subsectionsNumber`
     */
    UploadSubsectionsCount: 1539, "1539": "UploadSubsectionsCount",
    /**
     * r" Set `$rA` to `tx.proofSetCount`
     */
    UploadProofSetCount: 1540, "1540": "UploadProofSetCount",
    /**
     * r" Set `$rA` to `Memory address of tx.proofSet[$rB]`
     */
    UploadProofSetAtIndex: 1541, "1541": "UploadProofSetAtIndex",
    /**
     * r" Set `$rA` to `Memory address of tx.id`
     */
    BlobId: 1792, "1792": "BlobId",
    /**
     * r" Set `$rA` to `tx.witnessIndex`
     */
    BlobWitnessIndex: 1793, "1793": "BlobWitnessIndex",
    /**
     * r" Set `$rA` to `Memory address of tx.purpose`
     */
    UpgradePurpose: 2048, "2048": "UpgradePurpose",
    /**
     * r" Set `$rA` to `tx.inputsCount`
     */
    TxInputsCount: 2304, "2304": "TxInputsCount",
    /**
     * r" Set `$rA` to `tx.outputsCount`
     */
    TxOutputsCount: 2305, "2305": "TxOutputsCount",
    /**
     * r" Set `$rA` to `tx.witnessesCount`
     */
    TxWitnessesCount: 2306, "2306": "TxWitnessesCount",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB]`
     */
    TxInputAtIndex: 2307, "2307": "TxInputAtIndex",
    /**
     * r" Set `$rA` to `Memory address of t.outputs[$rB]`
     */
    TxOutputAtIndex: 2308, "2308": "TxOutputAtIndex",
    /**
     * r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
     */
    TxWitnessAtIndex: 2309, "2309": "TxWitnessAtIndex",
});
/**
 * The operation performed by WDOP and WQOP instructions, determined as
 * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7}
 */
const MathOp = Object.freeze({
    /**
     * Add
     */
    ADD: 0, "0": "ADD",
    /**
     * Subtract
     */
    SUB: 1, "1": "SUB",
    /**
     * Invert bits (discards rhs)
     */
    NOT: 2, "2": "NOT",
    /**
     * Bitwise or
     */
    OR: 3, "3": "OR",
    /**
     * Bitwise exclusive or
     */
    XOR: 4, "4": "XOR",
    /**
     * Bitwise and
     */
    AND: 5, "5": "AND",
    /**
     * Shift left
     */
    SHL: 6, "6": "SHL",
    /**
     * Shift right
     */
    SHR: 7, "7": "SHR",
});
/**
 * r" Panic reason representation for the interpreter.
 * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 | 64}
 */
const PanicReason = Object.freeze({
    /**
     * r" The byte can't be mapped to any known `PanicReason`.
     */
    UnknownPanicReason: 0, "0": "UnknownPanicReason",
    /**
     * r" Found `RVRT` instruction.
     */
    Revert: 1, "1": "Revert",
    /**
     * r" Execution ran out of gas.
     */
    OutOfGas: 2, "2": "OutOfGas",
    /**
     * r" The transaction validity is violated.
     */
    TransactionValidity: 3, "3": "TransactionValidity",
    /**
     * r" Attempt to write outside interpreter memory boundaries.
     */
    MemoryOverflow: 4, "4": "MemoryOverflow",
    /**
     * r" Overflow while executing arithmetic operation.
     * r" These errors are ignored using the WRAPPING flag.
     */
    ArithmeticOverflow: 5, "5": "ArithmeticOverflow",
    /**
     * r" Designed contract was not found in the storage.
     */
    ContractNotFound: 6, "6": "ContractNotFound",
    /**
     * r" Memory ownership rules are violated.
     */
    MemoryOwnership: 7, "7": "MemoryOwnership",
    /**
     * r" The asset ID balance isn't enough for the instruction.
     */
    NotEnoughBalance: 8, "8": "NotEnoughBalance",
    /**
     * r" The interpreter is expected to be in internal context.
     */
    ExpectedInternalContext: 9, "9": "ExpectedInternalContext",
    /**
     * r" The queried asset ID was not found in the state.
     */
    AssetIdNotFound: 10, "10": "AssetIdNotFound",
    /**
     * r" The provided input is not found in the transaction.
     */
    InputNotFound: 11, "11": "InputNotFound",
    /**
     * r" The provided output is not found in the transaction.
     */
    OutputNotFound: 12, "12": "OutputNotFound",
    /**
     * r" The provided witness is not found in the transaction.
     */
    WitnessNotFound: 13, "13": "WitnessNotFound",
    /**
     * r" The transaction maturity is not valid for this request.
     */
    TransactionMaturity: 14, "14": "TransactionMaturity",
    /**
     * r" The metadata identifier is invalid.
     */
    InvalidMetadataIdentifier: 15, "15": "InvalidMetadataIdentifier",
    /**
     * r" The call structure is not valid.
     */
    MalformedCallStructure: 16, "16": "MalformedCallStructure",
    /**
     * r" The provided register does not allow write operations.
     */
    ReservedRegisterNotWritable: 17, "17": "ReservedRegisterNotWritable",
    /**
     * r" The execution resulted in an erroneous state of the interpreter.
     */
    InvalidFlags: 18, "18": "InvalidFlags",
    /**
     * r" The provided immediate value is not valid for this instruction.
     */
    InvalidImmediateValue: 19, "19": "InvalidImmediateValue",
    /**
     * r" The provided transaction input is not of type `Coin`.
     */
    ExpectedCoinInput: 20, "20": "ExpectedCoinInput",
    /**
     * r" `ECAL` instruction failed.
     */
    EcalError: 21, "21": "EcalError",
    /**
     * r" Two segments of the interpreter memory should not intersect for write operations.
     */
    MemoryWriteOverlap: 22, "22": "MemoryWriteOverlap",
    /**
     * r" The requested contract is not listed in the transaction inputs.
     */
    ContractNotInInputs: 23, "23": "ContractNotInInputs",
    /**
     * r" The internal asset ID balance overflowed with the provided instruction.
     */
    InternalBalanceOverflow: 24, "24": "InternalBalanceOverflow",
    /**
     * r" The maximum allowed contract size is violated.
     */
    ContractMaxSize: 25, "25": "ContractMaxSize",
    /**
     * r" This instruction expects the stack area to be unallocated for this call.
     */
    ExpectedUnallocatedStack: 26, "26": "ExpectedUnallocatedStack",
    /**
     * r" The maximum allowed number of static contracts was reached for this transaction.
     */
    MaxStaticContractsReached: 27, "27": "MaxStaticContractsReached",
    /**
     * r" The requested transfer amount cannot be zero.
     */
    TransferAmountCannotBeZero: 28, "28": "TransferAmountCannotBeZero",
    /**
     * r" The provided transaction output should be of type `Variable`.
     */
    ExpectedOutputVariable: 29, "29": "ExpectedOutputVariable",
    /**
     * r" The expected context of the stack parent is internal.
     */
    ExpectedParentInternalContext: 30, "30": "ExpectedParentInternalContext",
    /**
     * r" The predicate returned non `1`. The `1` means successful verification
     * r" of the predicate, all other values means unsuccessful.
     */
    PredicateReturnedNonOne: 31, "31": "PredicateReturnedNonOne",
    /**
     * r" The contract ID is already deployed and can't be overwritten.
     */
    ContractIdAlreadyDeployed: 32, "32": "ContractIdAlreadyDeployed",
    /**
     * r" The loaded contract mismatch expectations.
     */
    ContractMismatch: 33, "33": "ContractMismatch",
    /**
     * r" Attempting to send message data longer than `MAX_MESSAGE_DATA_LENGTH`
     */
    MessageDataTooLong: 34, "34": "MessageDataTooLong",
    /**
     * r" Mathematically invalid arguments where given to an arithmetic instruction.
     * r" For instance, division by zero produces this.
     * r" These errors are ignored using the UNSAFEMATH flag.
     */
    ArithmeticError: 35, "35": "ArithmeticError",
    /**
     * r" The contract instruction is not allowed in predicates.
     */
    ContractInstructionNotAllowed: 36, "36": "ContractInstructionNotAllowed",
    /**
     * r" Transfer of zero coins is not allowed.
     */
    TransferZeroCoins: 37, "37": "TransferZeroCoins",
    /**
     * r" Attempted to execute an invalid instruction
     */
    InvalidInstruction: 38, "38": "InvalidInstruction",
    /**
     * r" Memory outside $is..$ssp range is not executable
     */
    MemoryNotExecutable: 39, "39": "MemoryNotExecutable",
    /**
     * r" The policy is not set.
     */
    PolicyIsNotSet: 40, "40": "PolicyIsNotSet",
    /**
     * r" The policy is not found across policies.
     */
    PolicyNotFound: 41, "41": "PolicyNotFound",
    /**
     * r" Receipt context is full
     */
    TooManyReceipts: 42, "42": "TooManyReceipts",
    /**
     * r" Balance of a contract overflowed
     */
    BalanceOverflow: 43, "43": "BalanceOverflow",
    /**
     * r" Block height value is invalid, typically because it is too large
     */
    InvalidBlockHeight: 44, "44": "InvalidBlockHeight",
    /**
     * r" Attempt to use sequential memory instructions with too large slot count,
     * r" typically because it cannot fit into usize
     */
    TooManySlots: 45, "45": "TooManySlots",
    /**
     * r" Caller of this internal context is also expected to be internal,
     * r" i.e. $fp->$fp must be non-zero.
     */
    ExpectedNestedCaller: 46, "46": "ExpectedNestedCaller",
    /**
     * r" During memory growth, the stack overlapped with the heap
     */
    MemoryGrowthOverlap: 47, "47": "MemoryGrowthOverlap",
    /**
     * r" Attempting to read or write uninitialized memory.
     * r" Also occurs when boundary crosses from stack to heap.
     */
    UninitalizedMemoryAccess: 48, "48": "UninitalizedMemoryAccess",
    /**
     * r" Overriding consensus parameters is not allowed.
     */
    OverridingConsensusParameters: 49, "49": "OverridingConsensusParameters",
    /**
     * r" The storage doesn't know about the hash of the state transition bytecode.
     */
    UnknownStateTransactionBytecodeRoot: 50, "50": "UnknownStateTransactionBytecodeRoot",
    /**
     * r" Overriding the state transition bytecode is not allowed.
     */
    OverridingStateTransactionBytecode: 51, "51": "OverridingStateTransactionBytecode",
    /**
     * r" The bytecode is already uploaded and cannot be uploaded again.
     */
    BytecodeAlreadyUploaded: 52, "52": "BytecodeAlreadyUploaded",
    /**
     * r" The part of the bytecode is not sequentially connected to the previous parts.
     */
    ThePartIsNotSequentiallyConnected: 53, "53": "ThePartIsNotSequentiallyConnected",
    /**
     * r" The requested blob is not found.
     */
    BlobNotFound: 54, "54": "BlobNotFound",
    /**
     * r" The blob was already
     */
    BlobIdAlreadyUploaded: 55, "55": "BlobIdAlreadyUploaded",
    /**
     * r" Active gas costs do not define the cost for this instruction.
     */
    GasCostNotDefined: 56, "56": "GasCostNotDefined",
    /**
     * r" The curve id is not supported.
     */
    UnsupportedCurveId: 57, "57": "UnsupportedCurveId",
    /**
     * r" The operation type is not supported.
     */
    UnsupportedOperationType: 58, "58": "UnsupportedOperationType",
    /**
     * r" Read alt_bn_128 curve point is invalid.
     */
    InvalidEllipticCurvePoint: 59, "59": "InvalidEllipticCurvePoint",
    /**
     * r" Given input contract does not exist.
     */
    InputContractDoesNotExist: 60, "60": "InputContractDoesNotExist",
    /**
     * r" Storage slot in Create not found
     */
    StorageSlotsNotFound: 61, "61": "StorageSlotsNotFound",
    /**
     * r" Proof in Upload not found
     */
    ProofInUploadNotFound: 62, "62": "ProofInUploadNotFound",
    /**
     * r" Invalid purpose type in Upgrade
     */
    InvalidUpgradePurposeType: 63, "63": "InvalidUpgradePurposeType",
    /**
     * r" Cannot get gas price in predicate
     */
    CanNotGetGasPriceInPredicate: 64, "64": "CanNotGetGasPriceInPredicate",
});

const ADDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_add_free(ptr >>> 0, 1));
/**
 * Adds two registers.
 */
class ADD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ADDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_add_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        ADDFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ADDIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_addi_free(ptr >>> 0, 1));
/**
 * Adds a register and an immediate value.
 */
class ADDI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ADDIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_addi_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {Imm12} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        ADDIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const ALOCFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_aloc_free(ptr >>> 0, 1));
/**
 * Allocate a number of bytes from the heap.
 */
class ALOC {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ALOCFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_aloc_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} bytes
     */
    constructor(bytes) {
        _assertClass(bytes, RegId);
        var ptr0 = bytes.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        ALOCFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ANDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_and_free(ptr >>> 0, 1));
/**
 * Bitwise ANDs two registers.
 */
class AND {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ANDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_and_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        ANDFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ANDIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_andi_free(ptr >>> 0, 1));
/**
 * Bitwise ANDs a register and an immediate value.
 */
class ANDI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ANDIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_andi_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {Imm12} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        ANDIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const BALFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_bal_free(ptr >>> 0, 1));
/**
 * Get the balance of contract of an asset ID.
 */
class BAL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BALFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_bal_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} asset_id_addr
     * @param {RegId} contract_id_addr
     */
    constructor(dst, asset_id_addr, contract_id_addr) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(asset_id_addr, RegId);
        var ptr1 = asset_id_addr.__destroy_into_raw();
        _assertClass(contract_id_addr, RegId);
        var ptr2 = contract_id_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        BALFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const BHEIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_bhei_free(ptr >>> 0, 1));
/**
 * Get current block height.
 */
class BHEI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BHEIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_bhei_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     */
    constructor(dst) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        BHEIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const BHSHFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_bhsh_free(ptr >>> 0, 1));
/**
 * Get block header hash for height.
 */
class BHSH {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BHSHFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_bhsh_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} heigth
     */
    constructor(dst, heigth) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(heigth, RegId);
        var ptr1 = heigth.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        BHSHFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const BLDDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_bldd_free(ptr >>> 0, 1));
/**
 * Load blob as data
 */
class BLDD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BLDDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_bldd_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst_ptr
     * @param {RegId} blob_id_ptr
     * @param {RegId} offset
     * @param {RegId} len
     */
    constructor(dst_ptr, blob_id_ptr, offset, len) {
        _assertClass(dst_ptr, RegId);
        var ptr0 = dst_ptr.__destroy_into_raw();
        _assertClass(blob_id_ptr, RegId);
        var ptr1 = blob_id_ptr.__destroy_into_raw();
        _assertClass(offset, RegId);
        var ptr2 = offset.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr3 = len.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        BLDDFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const BSIZFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_bsiz_free(ptr >>> 0, 1));
/**
 * Get blob size
 */
class BSIZ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BSIZFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_bsiz_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} blob_id_ptr
     */
    constructor(dst, blob_id_ptr) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(blob_id_ptr, RegId);
        var ptr1 = blob_id_ptr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        BSIZFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const BURNFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_burn_free(ptr >>> 0, 1));
/**
 * Burns `amount` coins of the asset ID created from `sub_id` for the current contract.
 */
class BURN {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BURNFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_burn_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} amount
     * @param {RegId} sub_id_addr
     */
    constructor(amount, sub_id_addr) {
        _assertClass(amount, RegId);
        var ptr0 = amount.__destroy_into_raw();
        _assertClass(sub_id_addr, RegId);
        var ptr1 = sub_id_addr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        BURNFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CALLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_call_free(ptr >>> 0, 1));
/**
 * Call a contract.
 */
class CALL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CALLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_call_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} target_struct
     * @param {RegId} fwd_coins
     * @param {RegId} asset_id_addr
     * @param {RegId} fwd_gas
     */
    constructor(target_struct, fwd_coins, asset_id_addr, fwd_gas) {
        _assertClass(target_struct, RegId);
        var ptr0 = target_struct.__destroy_into_raw();
        _assertClass(fwd_coins, RegId);
        var ptr1 = fwd_coins.__destroy_into_raw();
        _assertClass(asset_id_addr, RegId);
        var ptr2 = asset_id_addr.__destroy_into_raw();
        _assertClass(fwd_gas, RegId);
        var ptr3 = fwd_gas.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        CALLFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_cb_free(ptr >>> 0, 1));
/**
 * Get current block proposer's address.
 */
class CB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cb_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     */
    constructor(dst) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        CBFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CCPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ccp_free(ptr >>> 0, 1));
/**
 * Copy contract code for a contract.
 */
class CCP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CCPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ccp_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst_addr
     * @param {RegId} contract_id_addr
     * @param {RegId} offset
     * @param {RegId} len
     */
    constructor(dst_addr, contract_id_addr, offset, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(contract_id_addr, RegId);
        var ptr1 = contract_id_addr.__destroy_into_raw();
        _assertClass(offset, RegId);
        var ptr2 = offset.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr3 = len.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        CCPFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CFEFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_cfe_free(ptr >>> 0, 1));
/**
 * Extend the current call frame's stack
 */
class CFE {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CFEFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cfe_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} amount
     */
    constructor(amount) {
        _assertClass(amount, RegId);
        var ptr0 = amount.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        CFEFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CFEIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_cfei_free(ptr >>> 0, 1));
/**
 * Extend the current call frame's stack by an immediate value.
 */
class CFEI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CFEIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cfei_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {Imm24} amount
     */
    constructor(amount) {
        _assertClass(amount, Imm24);
        var ptr0 = amount.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        CFEIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the 24-bit immediate value.
     * @returns {Imm24}
     */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const CFSFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_cfs_free(ptr >>> 0, 1));
/**
 * Shrink the current call frame's stack
 */
class CFS {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CFSFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cfs_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} amount
     */
    constructor(amount) {
        _assertClass(amount, RegId);
        var ptr0 = amount.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        CFSFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CFSIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_cfsi_free(ptr >>> 0, 1));
/**
 * Shrink the current call frame's stack by an immediate value.
 */
class CFSI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CFSIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cfsi_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {Imm24} amount
     */
    constructor(amount) {
        _assertClass(amount, Imm24);
        var ptr0 = amount.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        CFSIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the 24-bit immediate value.
     * @returns {Imm24}
     */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const CROOFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_croo_free(ptr >>> 0, 1));
/**
 * Get code root of a contract.
 */
class CROO {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CROOFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_croo_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst_addr
     * @param {RegId} contract_id_addr
     */
    constructor(dst_addr, contract_id_addr) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(contract_id_addr, RegId);
        var ptr1 = contract_id_addr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        CROOFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CSIZFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_csiz_free(ptr >>> 0, 1));
/**
 * Get code size of a contract.
 */
class CSIZ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CSIZFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_csiz_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} contract_id_addr
     */
    constructor(dst, contract_id_addr) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(contract_id_addr, RegId);
        var ptr1 = contract_id_addr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        CSIZFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CompareArgsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compareargs_free(ptr >>> 0, 1));
/**
 * Arguments for WDCM and WQCM instructions.
 */
class CompareArgs {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompareArgs.prototype);
        obj.__wbg_ptr = ptr;
        CompareArgsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompareArgsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compareargs_free(ptr, 0);
    }
    /**
     * Comparison mode
     * @returns {CompareMode}
     */
    get mode() {
        const ret = wasm$1.__wbg_get_compareargs_mode(this.__wbg_ptr);
        return ret;
    }
    /**
     * Comparison mode
     * @param {CompareMode} arg0
     */
    set mode(arg0) {
        wasm$1.__wbg_set_compareargs_mode(this.__wbg_ptr, arg0);
    }
    /**
     * Load RHS from register if true, otherwise zero-extend register value
     * @returns {boolean}
     */
    get indirect_rhs() {
        const ret = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * Load RHS from register if true, otherwise zero-extend register value
     * @param {boolean} arg0
     */
    set indirect_rhs(arg0) {
        wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
    /**
     * Convert to immediate value.
     * @returns {Imm06}
     */
    to_imm() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm$1.compareargs_to_imm(ptr);
        return Imm06.__wrap(ret);
    }
    /**
     * Construct from `Imm06`. Returns `None` if the value has reserved flags set.
     * @param {Imm06} bits
     * @returns {CompareArgs | undefined}
     */
    static from_imm(bits) {
        _assertClass(bits, Imm06);
        var ptr0 = bits.__destroy_into_raw();
        const ret = wasm$1.compareargs_from_imm(ptr0);
        return ret === 0 ? undefined : CompareArgs.__wrap(ret);
    }
}

const DIVFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_div_free(ptr >>> 0, 1));
/**
 * Divides two registers.
 */
class DIV {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DIVFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_div_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        DIVFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const DIVIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_divi_free(ptr >>> 0, 1));
/**
 * Divides a register and an immediate value.
 */
class DIVI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DIVIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_divi_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {Imm12} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        DIVIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const DivArgsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_divargs_free(ptr >>> 0, 1));
/**
 * Additional arguments for WMDV and WDDV instructions.
 */
class DivArgs {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DivArgsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_divargs_free(ptr, 0);
    }
    /**
     * Load RHS from register if true, otherwise zero-extend register value
     * @returns {boolean}
     */
    get indirect_rhs() {
        const ret = wasm$1.__wbg_get_divargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * Load RHS from register if true, otherwise zero-extend register value
     * @param {boolean} arg0
     */
    set indirect_rhs(arg0) {
        wasm$1.__wbg_set_divargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
}

const ECALFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ecal_free(ptr >>> 0, 1));
/**
 * Call external function
 */
class ECAL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ECALFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ecal_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} a
     * @param {RegId} b
     * @param {RegId} c
     * @param {RegId} d
     */
    constructor(a, b, c, d) {
        _assertClass(a, RegId);
        var ptr0 = a.__destroy_into_raw();
        _assertClass(b, RegId);
        var ptr1 = b.__destroy_into_raw();
        _assertClass(c, RegId);
        var ptr2 = c.__destroy_into_raw();
        _assertClass(d, RegId);
        var ptr3 = d.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        ECALFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ECK1Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_eck1_free(ptr >>> 0, 1));
/**
 * The 64-byte public key (x, y) recovered from 64-byte signature on 32-byte message hash.
 */
class ECK1 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ECK1Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_eck1_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst_addr
     * @param {RegId} sig_addr
     * @param {RegId} msg_hash_addr
     */
    constructor(dst_addr, sig_addr, msg_hash_addr) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(sig_addr, RegId);
        var ptr1 = sig_addr.__destroy_into_raw();
        _assertClass(msg_hash_addr, RegId);
        var ptr2 = msg_hash_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        ECK1Finalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ECOPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ecop_free(ptr >>> 0, 1));
/**
 * Given some curve, performs an operation on points
 */
class ECOP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ECOPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ecop_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} curve_id
     * @param {RegId} operation_type
     * @param {RegId} points_ptr
     */
    constructor(dst, curve_id, operation_type, points_ptr) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(curve_id, RegId);
        var ptr1 = curve_id.__destroy_into_raw();
        _assertClass(operation_type, RegId);
        var ptr2 = operation_type.__destroy_into_raw();
        _assertClass(points_ptr, RegId);
        var ptr3 = points_ptr.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        ECOPFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ECR1Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ecr1_free(ptr >>> 0, 1));
/**
 * The 64-byte Secp256r1 public key (x, y) recovered from 64-byte signature on 32-byte message hash.
 */
class ECR1 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ECR1Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ecr1_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst_addr
     * @param {RegId} sig_addr
     * @param {RegId} msg_hash_addr
     */
    constructor(dst_addr, sig_addr, msg_hash_addr) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(sig_addr, RegId);
        var ptr1 = sig_addr.__destroy_into_raw();
        _assertClass(msg_hash_addr, RegId);
        var ptr2 = msg_hash_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        ECR1Finalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ED19Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ed19_free(ptr >>> 0, 1));
/**
 * Verify ED25519 public key and signature match a message.
 */
class ED19 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ED19Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ed19_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} pub_key_addr
     * @param {RegId} sig_addr
     * @param {RegId} msg_addr
     * @param {RegId} msg_len
     */
    constructor(pub_key_addr, sig_addr, msg_addr, msg_len) {
        _assertClass(pub_key_addr, RegId);
        var ptr0 = pub_key_addr.__destroy_into_raw();
        _assertClass(sig_addr, RegId);
        var ptr1 = sig_addr.__destroy_into_raw();
        _assertClass(msg_addr, RegId);
        var ptr2 = msg_addr.__destroy_into_raw();
        _assertClass(msg_len, RegId);
        var ptr3 = msg_len.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        ED19Finalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const EPARFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_epar_free(ptr >>> 0, 1));
/**
 * Given some curve, performs a pairing on groups of points
 */
class EPAR {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EPARFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_epar_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} success
     * @param {RegId} curve_id
     * @param {RegId} number_elements
     * @param {RegId} points_ptr
     */
    constructor(success, curve_id, number_elements, points_ptr) {
        _assertClass(success, RegId);
        var ptr0 = success.__destroy_into_raw();
        _assertClass(curve_id, RegId);
        var ptr1 = curve_id.__destroy_into_raw();
        _assertClass(number_elements, RegId);
        var ptr2 = number_elements.__destroy_into_raw();
        _assertClass(points_ptr, RegId);
        var ptr3 = points_ptr.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        EPARFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const EQFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_eq_free(ptr >>> 0, 1));
/**
 * Compares two registers for equality.
 */
class EQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EQFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_eq_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        EQFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const EXPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_exp_free(ptr >>> 0, 1));
/**
 * Raises one register to the power of another.
 */
class EXP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EXPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_exp_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        EXPFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const EXPIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_expi_free(ptr >>> 0, 1));
/**
 * Raises one register to the power of an immediate value.
 */
class EXPI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EXPIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_expi_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {Imm12} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        EXPIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const FLAGFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_flag_free(ptr >>> 0, 1));
/**
 * Set flag register to a register.
 */
class FLAG {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FLAGFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_flag_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} value
     */
    constructor(value) {
        _assertClass(value, RegId);
        var ptr0 = value.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        FLAGFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const GMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_gm_free(ptr >>> 0, 1));
/**
 * Get metadata from memory.
 */
class GM {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(GM.prototype);
        obj.__wbg_ptr = ptr;
        GMFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_gm_free(ptr, 0);
    }
    /**
     * Construct a `GM` instruction from its arguments.
     * @param {RegId} ra
     * @param {GMArgs} args
     * @returns {GM}
     */
    static from_args(ra, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        const ret = wasm$1.gm_from_args(ptr0, args);
        return GM.__wrap(ret);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {Imm18} selector
     */
    constructor(dst, selector) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(selector, Imm18);
        var ptr1 = selector.__destroy_into_raw();
        const ret = wasm$1.gm_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        GMFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 18-bit immediate value.
     * @returns {Imm18}
     */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}

const GTFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_gt_free(ptr >>> 0, 1));
/**
 * Compares two registers for greater-than.
 */
class GT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GTFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_gt_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        GTFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const GTFFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_gtf_free(ptr >>> 0, 1));
/**
 * Get transaction fields.
 */
class GTF {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(GTF.prototype);
        obj.__wbg_ptr = ptr;
        GTFFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GTFFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_gtf_free(ptr, 0);
    }
    /**
     * Construct a `GTF` instruction from its arguments.
     * @param {RegId} ra
     * @param {RegId} rb
     * @param {GTFArgs} args
     * @returns {GTF}
     */
    static from_args(ra, rb, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        const ret = wasm$1.gtf_from_args(ptr0, ptr1, args);
        return GTF.__wrap(ret);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} arg
     * @param {Imm12} selector
     */
    constructor(dst, arg, selector) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(arg, RegId);
        var ptr1 = arg.__destroy_into_raw();
        _assertClass(selector, Imm12);
        var ptr2 = selector.__destroy_into_raw();
        const ret = wasm$1.gtf_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        GTFFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const Imm06Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_imm06_free(ptr >>> 0, 1));
/**
 * Represents a 6-bit immediate value, guaranteed to be masked by construction.
 */
class Imm06 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Imm06.prototype);
        obj.__wbg_ptr = ptr;
        Imm06Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Imm06Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_imm06_free(ptr, 0);
    }
}

const Imm12Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_imm12_free(ptr >>> 0, 1));
/**
 * Represents a 12-bit immediate value, guaranteed to be masked by construction.
 */
class Imm12 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Imm12.prototype);
        obj.__wbg_ptr = ptr;
        Imm12Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Imm12Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_imm12_free(ptr, 0);
    }
}

const Imm18Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_imm18_free(ptr >>> 0, 1));
/**
 * Represents a 18-bit immediate value, guaranteed to be masked by construction.
 */
class Imm18 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Imm18.prototype);
        obj.__wbg_ptr = ptr;
        Imm18Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Imm18Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_imm18_free(ptr, 0);
    }
}

const Imm24Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_imm24_free(ptr >>> 0, 1));
/**
 * Represents a 24-bit immediate value, guaranteed to be masked by construction.
 */
class Imm24 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Imm24.prototype);
        obj.__wbg_ptr = ptr;
        Imm24Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Imm24Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_imm24_free(ptr, 0);
    }
}

const InstructionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_instruction_free(ptr >>> 0, 1));
/**
 * Representation of a single instruction for the interpreter.
 *
 * The opcode is represented in the tag (variant), or may be retrieved in the
 * form of an `Opcode` byte using the `opcode` method.
 *
 * The register and immediate data associated with the instruction is represented
 * within an inner unit type wrapper around the 3 remaining bytes.
 */
class Instruction {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Instruction.prototype);
        obj.__wbg_ptr = ptr;
        InstructionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        InstructionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_instruction_free(ptr, 0);
    }
    /**
     * Convenience method for converting to bytes
     * @returns {Uint8Array}
     */
    to_bytes() {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.instruction_to_bytes(retptr, this.__wbg_ptr);
            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
            var v1 = getArrayU8FromWasm0(r0, r1).slice();
            wasm$1.__wbindgen_export_0(r0, r1 * 1, 1);
            return v1;
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
     * Size of an instruction in bytes
     * @returns {number}
     */
    static size() {
        const ret = wasm$1.instruction_size();
        return ret >>> 0;
    }
}

const JIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ji_free(ptr >>> 0, 1));
/**
 * Jump.
 */
class JI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ji_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {Imm24} abs_target
     */
    constructor(abs_target) {
        _assertClass(abs_target, Imm24);
        var ptr0 = abs_target.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        JIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the 24-bit immediate value.
     * @returns {Imm24}
     */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const JMPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jmp_free(ptr >>> 0, 1));
/**
 * Dynamic jump.
 */
class JMP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JMPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jmp_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} abs_target
     */
    constructor(abs_target) {
        _assertClass(abs_target, RegId);
        var ptr0 = abs_target.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        JMPFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const JMPBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jmpb_free(ptr >>> 0, 1));
/**
 * Unconditional dynamic relative jump backwards, with a constant offset.
 */
class JMPB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JMPBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jmpb_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dynamic
     * @param {Imm18} fixed
     */
    constructor(dynamic, fixed) {
        _assertClass(dynamic, RegId);
        var ptr0 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm18);
        var ptr1 = fixed.__destroy_into_raw();
        const ret = wasm$1.jmpb_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        JMPBFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 18-bit immediate value.
     * @returns {Imm18}
     */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}

const JMPFFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jmpf_free(ptr >>> 0, 1));
/**
 * Unconditional dynamic relative jump forwards, with a constant offset.
 */
class JMPF {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JMPFFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jmpf_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dynamic
     * @param {Imm18} fixed
     */
    constructor(dynamic, fixed) {
        _assertClass(dynamic, RegId);
        var ptr0 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm18);
        var ptr1 = fixed.__destroy_into_raw();
        const ret = wasm$1.jmpb_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        JMPFFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 18-bit immediate value.
     * @returns {Imm18}
     */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}

const JNEFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jne_free(ptr >>> 0, 1));
/**
 * Conditional dynamic jump.
 */
class JNE {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNEFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jne_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} abs_target
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(abs_target, lhs, rhs) {
        _assertClass(abs_target, RegId);
        var ptr0 = abs_target.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        JNEFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const JNEBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jneb_free(ptr >>> 0, 1));
/**
 * Dynamic relative jump backwards, conditional on comparsion, with a constant offset.
 */
class JNEB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNEBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jneb_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} cond_lhs
     * @param {RegId} cond_rhs
     * @param {RegId} dynamic
     * @param {Imm06} fixed
     */
    constructor(cond_lhs, cond_rhs, dynamic, fixed) {
        _assertClass(cond_lhs, RegId);
        var ptr0 = cond_lhs.__destroy_into_raw();
        _assertClass(cond_rhs, RegId);
        var ptr1 = cond_rhs.__destroy_into_raw();
        _assertClass(dynamic, RegId);
        var ptr2 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm06);
        var ptr3 = fixed.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        JNEBFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 6-bit immediate value.
     * @returns {Imm06}
     */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const JNEFFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jnef_free(ptr >>> 0, 1));
/**
 * Dynamic relative jump forwards, conditional on comparsion, with a constant offset.
 */
class JNEF {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNEFFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnef_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} cond_lhs
     * @param {RegId} cond_rhs
     * @param {RegId} dynamic
     * @param {Imm06} fixed
     */
    constructor(cond_lhs, cond_rhs, dynamic, fixed) {
        _assertClass(cond_lhs, RegId);
        var ptr0 = cond_lhs.__destroy_into_raw();
        _assertClass(cond_rhs, RegId);
        var ptr1 = cond_rhs.__destroy_into_raw();
        _assertClass(dynamic, RegId);
        var ptr2 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm06);
        var ptr3 = fixed.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        JNEFFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 6-bit immediate value.
     * @returns {Imm06}
     */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const JNEIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jnei_free(ptr >>> 0, 1));
/**
 * Conditional jump.
 */
class JNEI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNEIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnei_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} cond_lhs
     * @param {RegId} cond_rhs
     * @param {Imm12} abs_target
     */
    constructor(cond_lhs, cond_rhs, abs_target) {
        _assertClass(cond_lhs, RegId);
        var ptr0 = cond_lhs.__destroy_into_raw();
        _assertClass(cond_rhs, RegId);
        var ptr1 = cond_rhs.__destroy_into_raw();
        _assertClass(abs_target, Imm12);
        var ptr2 = abs_target.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        JNEIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const JNZBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jnzb_free(ptr >>> 0, 1));
/**
 * Dynamic relative jump backwards, conditional against zero, with a constant offset.
 */
class JNZB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNZBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnzb_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} cond_nz
     * @param {RegId} dynamic
     * @param {Imm12} fixed
     */
    constructor(cond_nz, dynamic, fixed) {
        _assertClass(cond_nz, RegId);
        var ptr0 = cond_nz.__destroy_into_raw();
        _assertClass(dynamic, RegId);
        var ptr1 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm12);
        var ptr2 = fixed.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        JNZBFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const JNZFFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jnzf_free(ptr >>> 0, 1));
/**
 * Dynamic relative jump forwards, conditional against zero, with a constant offset.
 */
class JNZF {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNZFFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnzf_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} cond_nz
     * @param {RegId} dynamic
     * @param {Imm12} fixed
     */
    constructor(cond_nz, dynamic, fixed) {
        _assertClass(cond_nz, RegId);
        var ptr0 = cond_nz.__destroy_into_raw();
        _assertClass(dynamic, RegId);
        var ptr1 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm12);
        var ptr2 = fixed.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        JNZFFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const JNZIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jnzi_free(ptr >>> 0, 1));
/**
 * Conditional jump against zero.
 */
class JNZI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNZIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnzi_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} cond_nz
     * @param {Imm18} abs_target
     */
    constructor(cond_nz, abs_target) {
        _assertClass(cond_nz, RegId);
        var ptr0 = cond_nz.__destroy_into_raw();
        _assertClass(abs_target, Imm18);
        var ptr1 = abs_target.__destroy_into_raw();
        const ret = wasm$1.jmpb_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        JNZIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 18-bit immediate value.
     * @returns {Imm18}
     */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}

const K256Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_k256_free(ptr >>> 0, 1));
/**
 * The keccak-256 hash of a slice.
 */
class K256 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        K256Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_k256_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst_addr
     * @param {RegId} src_addr
     * @param {RegId} len
     */
    constructor(dst_addr, src_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr1 = src_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        K256Finalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const LBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_lb_free(ptr >>> 0, 1));
/**
 * A byte is loaded from the specified address offset by an immediate value.
 */
class LB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_lb_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} addr
     * @param {Imm12} offset
     */
    constructor(dst, addr, offset) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(addr, RegId);
        var ptr1 = addr.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        LBFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const LDCFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ldc_free(ptr >>> 0, 1));
/**
 * Load code as executable either from contract, blob, or memory.
 */
class LDC {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LDCFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ldc_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} src_addr
     * @param {RegId} offset
     * @param {RegId} len
     * @param {Imm06} mode
     */
    constructor(src_addr, offset, len, mode) {
        _assertClass(src_addr, RegId);
        var ptr0 = src_addr.__destroy_into_raw();
        _assertClass(offset, RegId);
        var ptr1 = offset.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr2 = len.__destroy_into_raw();
        _assertClass(mode, Imm06);
        var ptr3 = mode.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        LDCFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 6-bit immediate value.
     * @returns {Imm06}
     */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const LOGFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_log_free(ptr >>> 0, 1));
/**
 * Log an event.
 */
class LOG {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LOGFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_log_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} a
     * @param {RegId} b
     * @param {RegId} c
     * @param {RegId} d
     */
    constructor(a, b, c, d) {
        _assertClass(a, RegId);
        var ptr0 = a.__destroy_into_raw();
        _assertClass(b, RegId);
        var ptr1 = b.__destroy_into_raw();
        _assertClass(c, RegId);
        var ptr2 = c.__destroy_into_raw();
        _assertClass(d, RegId);
        var ptr3 = d.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        LOGFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const LOGDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_logd_free(ptr >>> 0, 1));
/**
 * Log data.
 */
class LOGD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LOGDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_logd_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} a
     * @param {RegId} b
     * @param {RegId} addr
     * @param {RegId} len
     */
    constructor(a, b, addr, len) {
        _assertClass(a, RegId);
        var ptr0 = a.__destroy_into_raw();
        _assertClass(b, RegId);
        var ptr1 = b.__destroy_into_raw();
        _assertClass(addr, RegId);
        var ptr2 = addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr3 = len.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        LOGDFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const LTFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_lt_free(ptr >>> 0, 1));
/**
 * Compares two registers for less-than.
 */
class LT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LTFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_lt_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        LTFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const LWFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_lw_free(ptr >>> 0, 1));
/**
 * A word is loaded from the specified address offset by an immediate value.
 */
class LW {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LWFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_lw_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} addr
     * @param {Imm12} offset
     */
    constructor(dst, addr, offset) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(addr, RegId);
        var ptr1 = addr.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        LWFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const MCLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mcl_free(ptr >>> 0, 1));
/**
 * Clear a variable number of bytes in memory.
 */
class MCL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MCLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mcl_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst_addr
     * @param {RegId} len
     */
    constructor(dst_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr1 = len.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        MCLFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MCLIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mcli_free(ptr >>> 0, 1));
/**
 * Clear an immediate number of bytes in memory.
 */
class MCLI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MCLIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mcli_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} addr
     * @param {Imm18} count
     */
    constructor(addr, count) {
        _assertClass(addr, RegId);
        var ptr0 = addr.__destroy_into_raw();
        _assertClass(count, Imm18);
        var ptr1 = count.__destroy_into_raw();
        const ret = wasm$1.jmpb_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        MCLIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 18-bit immediate value.
     * @returns {Imm18}
     */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}

const MCPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mcp_free(ptr >>> 0, 1));
/**
 * Copy a variable number of bytes in memory.
 */
class MCP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MCPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mcp_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst_addr
     * @param {RegId} src_addr
     * @param {RegId} len
     */
    constructor(dst_addr, src_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr1 = src_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        MCPFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MCPIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mcpi_free(ptr >>> 0, 1));
/**
 * Copy an immediate number of bytes in memory.
 */
class MCPI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MCPIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mcpi_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst_addr
     * @param {RegId} src_addr
     * @param {Imm12} len
     */
    constructor(dst_addr, src_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr1 = src_addr.__destroy_into_raw();
        _assertClass(len, Imm12);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        MCPIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const MEQFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_meq_free(ptr >>> 0, 1));
/**
 * Compare bytes in memory.
 */
class MEQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MEQFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_meq_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} result
     * @param {RegId} lhs_addr
     * @param {RegId} rhs_addr
     * @param {RegId} len
     */
    constructor(result, lhs_addr, rhs_addr, len) {
        _assertClass(result, RegId);
        var ptr0 = result.__destroy_into_raw();
        _assertClass(lhs_addr, RegId);
        var ptr1 = lhs_addr.__destroy_into_raw();
        _assertClass(rhs_addr, RegId);
        var ptr2 = rhs_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr3 = len.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        MEQFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MINTFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mint_free(ptr >>> 0, 1));
/**
 * Mints `amount` coins of the asset ID created from `sub_id` for the current contract.
 */
class MINT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MINTFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mint_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} amount
     * @param {RegId} sub_id_addr
     */
    constructor(amount, sub_id_addr) {
        _assertClass(amount, RegId);
        var ptr0 = amount.__destroy_into_raw();
        _assertClass(sub_id_addr, RegId);
        var ptr1 = sub_id_addr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        MINTFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MLDVFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mldv_free(ptr >>> 0, 1));
/**
 * Fused multiply-divide with arbitrary precision intermediate step.
 */
class MLDV {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MLDVFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mldv_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} mul_lhs
     * @param {RegId} mul_rhs
     * @param {RegId} divisor
     */
    constructor(dst, mul_lhs, mul_rhs, divisor) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(divisor, RegId);
        var ptr3 = divisor.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        MLDVFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MLOGFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mlog_free(ptr >>> 0, 1));
/**
 * The integer logarithm of a register.
 */
class MLOG {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MLOGFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mlog_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        MLOGFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MODFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mod_free(ptr >>> 0, 1));
/**
 * Modulo remainder of two registers.
 */
class MOD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MODFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mod_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        MODFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MODIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_modi_free(ptr >>> 0, 1));
/**
 * Modulo remainder of a register and an immediate value.
 */
class MODI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MODIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_modi_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {Imm12} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        MODIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const MOVEFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_move_free(ptr >>> 0, 1));
/**
 * Copy from one register to another.
 */
class MOVE {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MOVEFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_move_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} src
     */
    constructor(dst, src) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(src, RegId);
        var ptr1 = src.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        MOVEFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MOVIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_movi_free(ptr >>> 0, 1));
/**
 * Copy immediate value into a register
 */
class MOVI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MOVIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_movi_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {Imm18} val
     */
    constructor(dst, val) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(val, Imm18);
        var ptr1 = val.__destroy_into_raw();
        const ret = wasm$1.jmpb_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        MOVIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 18-bit immediate value.
     * @returns {Imm18}
     */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}

const MROOFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mroo_free(ptr >>> 0, 1));
/**
 * The integer root of a register.
 */
class MROO {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MROOFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mroo_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        MROOFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MULFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mul_free(ptr >>> 0, 1));
/**
 * Multiplies two registers.
 */
class MUL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MULFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mul_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        MULFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MULIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_muli_free(ptr >>> 0, 1));
/**
 * Multiplies a register and an immediate value.
 */
class MULI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MULIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_muli_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {Imm12} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        MULIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const MathArgsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mathargs_free(ptr >>> 0, 1));
/**
 * Additional arguments for WDOP and WQOP instructions.
 */
class MathArgs {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MathArgsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mathargs_free(ptr, 0);
    }
    /**
     * The operation to perform
     * @returns {MathOp}
     */
    get op() {
        const ret = wasm$1.__wbg_get_mathargs_op(this.__wbg_ptr);
        return ret;
    }
    /**
     * The operation to perform
     * @param {MathOp} arg0
     */
    set op(arg0) {
        wasm$1.__wbg_set_mathargs_op(this.__wbg_ptr, arg0);
    }
    /**
     * Load RHS from register if true, otherwise zero-extend register value
     * @returns {boolean}
     */
    get indirect_rhs() {
        const ret = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * Load RHS from register if true, otherwise zero-extend register value
     * @param {boolean} arg0
     */
    set indirect_rhs(arg0) {
        wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
}

const MulArgsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mulargs_free(ptr >>> 0, 1));
/**
 * Additional arguments for WDML and WQML instructions.
 */
class MulArgs {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MulArgsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mulargs_free(ptr, 0);
    }
    /**
     * Load LHSS from register if true, otherwise zero-extend register value
     * @returns {boolean}
     */
    get indirect_lhs() {
        const ret = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * Load LHSS from register if true, otherwise zero-extend register value
     * @param {boolean} arg0
     */
    set indirect_lhs(arg0) {
        wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
    /**
     * Load RHS from register if true, otherwise zero-extend register value
     * @returns {boolean}
     */
    get indirect_rhs() {
        const ret = wasm$1.__wbg_get_mulargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * Load RHS from register if true, otherwise zero-extend register value
     * @param {boolean} arg0
     */
    set indirect_rhs(arg0) {
        wasm$1.__wbg_set_mulargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
}

const NOOPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_noop_free(ptr >>> 0, 1));
/**
 * Performs no operation.
 */
class NOOP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NOOPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_noop_free(ptr, 0);
    }
    /**
     * Construct the instruction.
     */
    constructor() {
        const ret = wasm$1.noop_new_typescript();
        this.__wbg_ptr = ret >>> 0;
        NOOPFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
}

const NOTFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_not_free(ptr >>> 0, 1));
/**
 * Bitwise NOT a register.
 */
class NOT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NOTFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_not_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} arg
     */
    constructor(dst, arg) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(arg, RegId);
        var ptr1 = arg.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        NOTFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ORFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_or_free(ptr >>> 0, 1));
/**
 * Bitwise ORs two registers.
 */
class OR {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ORFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_or_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        ORFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ORIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ori_free(ptr >>> 0, 1));
/**
 * Bitwise ORs a register and an immediate value.
 */
class ORI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ORIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ori_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {Imm12} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        ORIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const POPHFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_poph_free(ptr >>> 0, 1));
/**
 * Pop a bitmask-selected set of registers in range 40..64 to the stack.
 */
class POPH {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        POPHFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_poph_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {Imm24} bitmask
     */
    constructor(bitmask) {
        _assertClass(bitmask, Imm24);
        var ptr0 = bitmask.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        POPHFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the 24-bit immediate value.
     * @returns {Imm24}
     */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const POPLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_popl_free(ptr >>> 0, 1));
/**
 * Pop a bitmask-selected set of registers in range 16..40 to the stack.
 */
class POPL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        POPLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_popl_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {Imm24} bitmask
     */
    constructor(bitmask) {
        _assertClass(bitmask, Imm24);
        var ptr0 = bitmask.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        POPLFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the 24-bit immediate value.
     * @returns {Imm24}
     */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const PSHHFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_pshh_free(ptr >>> 0, 1));
/**
 * Push a bitmask-selected set of registers in range 40..64 to the stack.
 */
class PSHH {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PSHHFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_pshh_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {Imm24} bitmask
     */
    constructor(bitmask) {
        _assertClass(bitmask, Imm24);
        var ptr0 = bitmask.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        PSHHFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the 24-bit immediate value.
     * @returns {Imm24}
     */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const PSHLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_pshl_free(ptr >>> 0, 1));
/**
 * Push a bitmask-selected set of registers in range 16..40 to the stack.
 */
class PSHL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PSHLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_pshl_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {Imm24} bitmask
     */
    constructor(bitmask) {
        _assertClass(bitmask, Imm24);
        var ptr0 = bitmask.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        PSHLFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the 24-bit immediate value.
     * @returns {Imm24}
     */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const PanicInstructionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_panicinstruction_free(ptr >>> 0, 1));
/**
 * Describe a panic reason with the instruction that generated it
 */
class PanicInstruction {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PanicInstructionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_panicinstruction_free(ptr, 0);
    }
    /**
     * Represents an error described by a reason and an instruction.
     * @param {PanicReason} reason
     * @param {number} instruction
     */
    constructor(reason, instruction) {
        const ret = wasm$1.panicinstruction_error_typescript(reason, instruction);
        this.__wbg_ptr = ret >>> 0;
        PanicInstructionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Underlying panic reason
     * @returns {PanicReason}
     */
    reason() {
        const ret = wasm$1.panicinstruction_reason(this.__wbg_ptr);
        return ret;
    }
    /**
     * Underlying instruction
     * @returns {number}
     */
    instruction() {
        const ret = wasm$1.panicinstruction_instruction(this.__wbg_ptr);
        return ret >>> 0;
    }
}

const RETFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ret_free(ptr >>> 0, 1));
/**
 * Return from context.
 */
class RET {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RETFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ret_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} value
     */
    constructor(value) {
        _assertClass(value, RegId);
        var ptr0 = value.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        RETFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const RETDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_retd_free(ptr >>> 0, 1));
/**
 * Return from context with data.
 */
class RETD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RETDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_retd_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} addr
     * @param {RegId} len
     */
    constructor(addr, len) {
        _assertClass(addr, RegId);
        var ptr0 = addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr1 = len.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        RETDFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const RVRTFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_rvrt_free(ptr >>> 0, 1));
/**
 * Halt execution, reverting state changes and returning a value.
 */
class RVRT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RVRTFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_rvrt_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} value
     */
    constructor(value) {
        _assertClass(value, RegId);
        var ptr0 = value.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        RVRTFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const RegIdFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_regid_free(ptr >>> 0, 1));
/**
 * Represents a 6-bit register ID, guaranteed to be masked by construction.
 */
class RegId {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RegId.prototype);
        obj.__wbg_ptr = ptr;
        RegIdFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RegIdFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_regid_free(ptr, 0);
    }
    /**
     * Construct a register ID from the given value.
     *
     * Returns `None` if the value is outside the 6-bit value range.
     * @param {number} u
     * @returns {RegId | undefined}
     */
    static new_checked(u) {
        const ret = wasm$1.regid_new_checked(u);
        return ret === 0 ? undefined : RegId.__wrap(ret);
    }
    /**
     * Received balance for this context.
     * @returns {RegId}
     */
    static bal() {
        const ret = wasm$1.regid_bal();
        return RegId.__wrap(ret);
    }
    /**
     * Remaining gas in the context.
     * @returns {RegId}
     */
    static cgas() {
        const ret = wasm$1.regid_cgas();
        return RegId.__wrap(ret);
    }
    /**
     * Error codes for particular operations.
     * @returns {RegId}
     */
    static err() {
        const ret = wasm$1.regid_err();
        return RegId.__wrap(ret);
    }
    /**
     * Flags register.
     * @returns {RegId}
     */
    static flag() {
        const ret = wasm$1.regid_flag();
        return RegId.__wrap(ret);
    }
    /**
     * Frame pointer. Memory address of beginning of current call frame.
     * @returns {RegId}
     */
    static fp() {
        const ret = wasm$1.regid_fp();
        return RegId.__wrap(ret);
    }
    /**
     * Remaining gas globally.
     * @returns {RegId}
     */
    static ggas() {
        const ret = wasm$1.regid_ggas();
        return RegId.__wrap(ret);
    }
    /**
     * Heap pointer. Memory address below the current bottom of the heap (points to free
     * memory).
     * @returns {RegId}
     */
    static hp() {
        const ret = wasm$1.regid_hp();
        return RegId.__wrap(ret);
    }
    /**
     * Instructions start. Pointer to the start of the currently-executing code.
     * @returns {RegId}
     */
    static is() {
        const ret = wasm$1.regid_is();
        return RegId.__wrap(ret);
    }
    /**
     * Contains overflow/underflow of addition, subtraction, and multiplication.
     * @returns {RegId}
     */
    static of() {
        const ret = wasm$1.regid_of();
        return RegId.__wrap(ret);
    }
    /**
     * Contains one (1), for convenience.
     * @returns {RegId}
     */
    static one() {
        const ret = wasm$1.regid_one();
        return RegId.__wrap(ret);
    }
    /**
     * The program counter. Memory address of the current instruction.
     * @returns {RegId}
     */
    static pc() {
        const ret = wasm$1.regid_pc();
        return RegId.__wrap(ret);
    }
    /**
     * Return value or pointer.
     * @returns {RegId}
     */
    static ret() {
        const ret = wasm$1.regid_ret();
        return RegId.__wrap(ret);
    }
    /**
     * Return value length in bytes.
     * @returns {RegId}
     */
    static retl() {
        const ret = wasm$1.regid_retl();
        return RegId.__wrap(ret);
    }
    /**
     * Stack pointer. Memory address on top of current writable stack area (points to
     * free memory).
     * @returns {RegId}
     */
    static sp() {
        const ret = wasm$1.regid_sp();
        return RegId.__wrap(ret);
    }
    /**
     * Stack start pointer. Memory address of bottom of current writable stack area.
     * @returns {RegId}
     */
    static spp() {
        const ret = wasm$1.regid_spp();
        return RegId.__wrap(ret);
    }
    /**
     * Smallest writable register.
     * @returns {RegId}
     */
    static writable() {
        const ret = wasm$1.regid_writable();
        return RegId.__wrap(ret);
    }
    /**
     * Contains zero (0), for convenience.
     * @returns {RegId}
     */
    static zero() {
        const ret = wasm$1.regid_zero();
        return RegId.__wrap(ret);
    }
    /**
     * Construct a register ID from the given value.
     *
     * The given value will be masked to 6 bits.
     * @param {number} u
     */
    constructor(u) {
        const ret = wasm$1.regid_new_typescript(u);
        this.__wbg_ptr = ret >>> 0;
        RegIdFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * A const alternative to the `Into<u8>` implementation.
     * @returns {number}
     */
    to_u8() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm$1.regid_to_u8(ptr);
        return ret;
    }
}

const S256Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_s256_free(ptr >>> 0, 1));
/**
 * The SHA-2-256 hash of a slice.
 */
class S256 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        S256Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_s256_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst_addr
     * @param {RegId} src_addr
     * @param {RegId} len
     */
    constructor(dst_addr, src_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr1 = src_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        S256Finalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_sb_free(ptr >>> 0, 1));
/**
 * Write the least significant byte of a register to memory.
 */
class SB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sb_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} addr
     * @param {RegId} value
     * @param {Imm12} offset
     */
    constructor(addr, value, offset) {
        _assertClass(addr, RegId);
        var ptr0 = addr.__destroy_into_raw();
        _assertClass(value, RegId);
        var ptr1 = value.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SBFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const SCWQFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_scwq_free(ptr >>> 0, 1));
/**
 * Clear a series of slots from contract storage.
 */
class SCWQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SCWQFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_scwq_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} key_addr
     * @param {RegId} status
     * @param {RegId} lenq
     */
    constructor(key_addr, status, lenq) {
        _assertClass(key_addr, RegId);
        var ptr0 = key_addr.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(lenq, RegId);
        var ptr2 = lenq.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SCWQFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SLLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_sll_free(ptr >>> 0, 1));
/**
 * Left shifts a register by a register.
 */
class SLL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SLLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sll_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SLLFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SLLIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_slli_free(ptr >>> 0, 1));
/**
 * Left shifts a register by an immediate value.
 */
class SLLI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SLLIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_slli_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {Imm12} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SLLIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const SMOFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_smo_free(ptr >>> 0, 1));
/**
 * Send a message to recipient address with call abi, coins, and output.
 */
class SMO {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SMOFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_smo_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} recipient_addr
     * @param {RegId} data_addr
     * @param {RegId} data_len
     * @param {RegId} coins
     */
    constructor(recipient_addr, data_addr, data_len, coins) {
        _assertClass(recipient_addr, RegId);
        var ptr0 = recipient_addr.__destroy_into_raw();
        _assertClass(data_addr, RegId);
        var ptr1 = data_addr.__destroy_into_raw();
        _assertClass(data_len, RegId);
        var ptr2 = data_len.__destroy_into_raw();
        _assertClass(coins, RegId);
        var ptr3 = coins.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        SMOFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SRLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_srl_free(ptr >>> 0, 1));
/**
 * Right shifts a register by a register.
 */
class SRL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SRLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_srl_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SRLFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SRLIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_srli_free(ptr >>> 0, 1));
/**
 * Right shifts a register by an immediate value.
 */
class SRLI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SRLIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_srli_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {Imm12} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SRLIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const SRWFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_srw_free(ptr >>> 0, 1));
/**
 * Load a word from contract storage.
 */
class SRW {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SRWFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_srw_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} status
     * @param {RegId} key_addr
     */
    constructor(dst, status, key_addr) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(key_addr, RegId);
        var ptr2 = key_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SRWFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SRWQFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_srwq_free(ptr >>> 0, 1));
/**
 * Load a series of 32 byte slots from contract storage.
 */
class SRWQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SRWQFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_srwq_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst_addr
     * @param {RegId} status
     * @param {RegId} key_addr
     * @param {RegId} lenq
     */
    constructor(dst_addr, status, key_addr, lenq) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(key_addr, RegId);
        var ptr2 = key_addr.__destroy_into_raw();
        _assertClass(lenq, RegId);
        var ptr3 = lenq.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        SRWQFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SUBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_sub_free(ptr >>> 0, 1));
/**
 * Subtracts two registers.
 */
class SUB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SUBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sub_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SUBFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SUBIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_subi_free(ptr >>> 0, 1));
/**
 * Subtracts a register and an immediate value.
 */
class SUBI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SUBIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_subi_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {Imm12} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SUBIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const SWFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_sw_free(ptr >>> 0, 1));
/**
 * Write a register to memory.
 */
class SW {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SWFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sw_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} addr
     * @param {RegId} value
     * @param {Imm12} offset
     */
    constructor(addr, value, offset) {
        _assertClass(addr, RegId);
        var ptr0 = addr.__destroy_into_raw();
        _assertClass(value, RegId);
        var ptr1 = value.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SWFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const SWWFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_sww_free(ptr >>> 0, 1));
/**
 * Store a word in contract storage.
 */
class SWW {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SWWFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sww_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} key_addr
     * @param {RegId} status
     * @param {RegId} value
     */
    constructor(key_addr, status, value) {
        _assertClass(key_addr, RegId);
        var ptr0 = key_addr.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(value, RegId);
        var ptr2 = value.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SWWFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SWWQFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_swwq_free(ptr >>> 0, 1));
/**
 * Store a series of 32 byte slots in contract storage.
 */
class SWWQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SWWQFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_swwq_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} key_addr
     * @param {RegId} status
     * @param {RegId} src_addr
     * @param {RegId} lenq
     */
    constructor(key_addr, status, src_addr, lenq) {
        _assertClass(key_addr, RegId);
        var ptr0 = key_addr.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr2 = src_addr.__destroy_into_raw();
        _assertClass(lenq, RegId);
        var ptr3 = lenq.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        SWWQFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const TIMEFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_time_free(ptr >>> 0, 1));
/**
 * Get timestamp of block at given height.
 */
class TIME {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TIMEFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_time_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} heigth
     */
    constructor(dst, heigth) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(heigth, RegId);
        var ptr1 = heigth.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        TIMEFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const TRFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_tr_free(ptr >>> 0, 1));
/**
 * Transfer coins to a contract unconditionally.
 */
class TR {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TRFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_tr_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} contract_id_addr
     * @param {RegId} amount
     * @param {RegId} asset_id_addr
     */
    constructor(contract_id_addr, amount, asset_id_addr) {
        _assertClass(contract_id_addr, RegId);
        var ptr0 = contract_id_addr.__destroy_into_raw();
        _assertClass(amount, RegId);
        var ptr1 = amount.__destroy_into_raw();
        _assertClass(asset_id_addr, RegId);
        var ptr2 = asset_id_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        TRFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const TROFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_tro_free(ptr >>> 0, 1));
/**
 * Transfer coins to a variable output.
 */
class TRO {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TROFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_tro_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} contract_id_addr
     * @param {RegId} output_index
     * @param {RegId} amount
     * @param {RegId} asset_id_addr
     */
    constructor(contract_id_addr, output_index, amount, asset_id_addr) {
        _assertClass(contract_id_addr, RegId);
        var ptr0 = contract_id_addr.__destroy_into_raw();
        _assertClass(output_index, RegId);
        var ptr1 = output_index.__destroy_into_raw();
        _assertClass(amount, RegId);
        var ptr2 = amount.__destroy_into_raw();
        _assertClass(asset_id_addr, RegId);
        var ptr3 = asset_id_addr.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        TROFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WDAMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wdam_free(ptr >>> 0, 1));
/**
 * AddMod 128bit
 */
class WDAM {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDAMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdam_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} add_lhs
     * @param {RegId} add_rhs
     * @param {RegId} modulo
     */
    constructor(dst, add_lhs, add_rhs, modulo) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(add_lhs, RegId);
        var ptr1 = add_lhs.__destroy_into_raw();
        _assertClass(add_rhs, RegId);
        var ptr2 = add_rhs.__destroy_into_raw();
        _assertClass(modulo, RegId);
        var ptr3 = modulo.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WDAMFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WDCMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wdcm_free(ptr >>> 0, 1));
/**
 * Compare 128bit integers
 */
class WDCM {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDCM.prototype);
        obj.__wbg_ptr = ptr;
        WDCMFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDCMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdcm_free(ptr, 0);
    }
    /**
     * Construct a `WDCM` instruction from its arguments.
     * @param {RegId} ra
     * @param {RegId} rb
     * @param {RegId} rc
     * @param {CompareArgs} args
     * @returns {WDCM}
     */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, CompareArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdcm_from_args(ptr0, ptr1, ptr2, ptr3);
        return WDCM.__wrap(ret);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     * @param {Imm06} flags
     */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WDCMFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 6-bit immediate value.
     * @returns {Imm06}
     */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WDDVFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wddv_free(ptr >>> 0, 1));
/**
 * Divide 128bit
 */
class WDDV {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDDV.prototype);
        obj.__wbg_ptr = ptr;
        WDDVFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDDVFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wddv_free(ptr, 0);
    }
    /**
     * Construct a `WDDV` instruction from its arguments.
     * @param {RegId} ra
     * @param {RegId} rb
     * @param {RegId} rc
     * @param {DivArgs} args
     * @returns {WDDV}
     */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, DivArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wddv_from_args(ptr0, ptr1, ptr2, ptr3);
        return WDDV.__wrap(ret);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     * @param {Imm06} flags
     */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WDDVFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 6-bit immediate value.
     * @returns {Imm06}
     */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WDMDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wdmd_free(ptr >>> 0, 1));
/**
 * Fused multiply-divide 128bit
 */
class WDMD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDMDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdmd_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} mul_lhs
     * @param {RegId} mul_rhs
     * @param {RegId} divisor
     */
    constructor(dst, mul_lhs, mul_rhs, divisor) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(divisor, RegId);
        var ptr3 = divisor.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WDMDFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WDMLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wdml_free(ptr >>> 0, 1));
/**
 * Multiply 128bit
 */
class WDML {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDML.prototype);
        obj.__wbg_ptr = ptr;
        WDMLFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDMLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdml_free(ptr, 0);
    }
    /**
     * Construct a `WDML` instruction from its arguments.
     * @param {RegId} ra
     * @param {RegId} rb
     * @param {RegId} rc
     * @param {MulArgs} args
     * @returns {WDML}
     */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, MulArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdml_from_args(ptr0, ptr1, ptr2, ptr3);
        return WDML.__wrap(ret);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     * @param {Imm06} flags
     */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WDMLFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 6-bit immediate value.
     * @returns {Imm06}
     */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WDMMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wdmm_free(ptr >>> 0, 1));
/**
 * MulMod 128bit
 */
class WDMM {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDMMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdmm_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} mul_lhs
     * @param {RegId} mul_rhs
     * @param {RegId} modulo
     */
    constructor(dst, mul_lhs, mul_rhs, modulo) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(modulo, RegId);
        var ptr3 = modulo.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WDMMFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WDOPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wdop_free(ptr >>> 0, 1));
/**
 * Simple 128bit operations
 */
class WDOP {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDOP.prototype);
        obj.__wbg_ptr = ptr;
        WDOPFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDOPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdop_free(ptr, 0);
    }
    /**
     * Construct a `WDOP` instruction from its arguments.
     * @param {RegId} ra
     * @param {RegId} rb
     * @param {RegId} rc
     * @param {MathArgs} args
     * @returns {WDOP}
     */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, MathArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdop_from_args(ptr0, ptr1, ptr2, ptr3);
        return WDOP.__wrap(ret);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     * @param {Imm06} flags
     */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WDOPFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 6-bit immediate value.
     * @returns {Imm06}
     */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WQAMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqam_free(ptr >>> 0, 1));
/**
 * AddMod 256bit
 */
class WQAM {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQAMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqam_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} add_lhs
     * @param {RegId} add_rhs
     * @param {RegId} modulo
     */
    constructor(dst, add_lhs, add_rhs, modulo) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(add_lhs, RegId);
        var ptr1 = add_lhs.__destroy_into_raw();
        _assertClass(add_rhs, RegId);
        var ptr2 = add_rhs.__destroy_into_raw();
        _assertClass(modulo, RegId);
        var ptr3 = modulo.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WQAMFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WQCMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqcm_free(ptr >>> 0, 1));
/**
 * Compare 256bit integers
 */
class WQCM {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQCM.prototype);
        obj.__wbg_ptr = ptr;
        WQCMFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQCMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqcm_free(ptr, 0);
    }
    /**
     * Construct a `WQCM` instruction from its arguments.
     * @param {RegId} ra
     * @param {RegId} rb
     * @param {RegId} rc
     * @param {CompareArgs} args
     * @returns {WQCM}
     */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, CompareArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdcm_from_args(ptr0, ptr1, ptr2, ptr3);
        return WQCM.__wrap(ret);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     * @param {Imm06} flags
     */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WQCMFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 6-bit immediate value.
     * @returns {Imm06}
     */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WQDVFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqdv_free(ptr >>> 0, 1));
/**
 * Divide 256bit
 */
class WQDV {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQDV.prototype);
        obj.__wbg_ptr = ptr;
        WQDVFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQDVFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqdv_free(ptr, 0);
    }
    /**
     * Construct a `WQDV` instruction from its arguments.
     * @param {RegId} ra
     * @param {RegId} rb
     * @param {RegId} rc
     * @param {DivArgs} args
     * @returns {WQDV}
     */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, DivArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wddv_from_args(ptr0, ptr1, ptr2, ptr3);
        return WQDV.__wrap(ret);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     * @param {Imm06} flags
     */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WQDVFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 6-bit immediate value.
     * @returns {Imm06}
     */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WQMDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqmd_free(ptr >>> 0, 1));
/**
 * Fused multiply-divide 256bit
 */
class WQMD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQMDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqmd_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} mul_lhs
     * @param {RegId} mul_rhs
     * @param {RegId} divisor
     */
    constructor(dst, mul_lhs, mul_rhs, divisor) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(divisor, RegId);
        var ptr3 = divisor.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WQMDFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WQMLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqml_free(ptr >>> 0, 1));
/**
 * Multiply 256bit
 */
class WQML {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQML.prototype);
        obj.__wbg_ptr = ptr;
        WQMLFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQMLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqml_free(ptr, 0);
    }
    /**
     * Construct a `WQML` instruction from its arguments.
     * @param {RegId} ra
     * @param {RegId} rb
     * @param {RegId} rc
     * @param {MulArgs} args
     * @returns {WQML}
     */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, MulArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdml_from_args(ptr0, ptr1, ptr2, ptr3);
        return WQML.__wrap(ret);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     * @param {Imm06} flags
     */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WQMLFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 6-bit immediate value.
     * @returns {Imm06}
     */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WQMMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqmm_free(ptr >>> 0, 1));
/**
 * MulMod 256bit
 */
class WQMM {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQMMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqmm_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} mul_lhs
     * @param {RegId} mul_rhs
     * @param {RegId} modulo
     */
    constructor(dst, mul_lhs, mul_rhs, modulo) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(modulo, RegId);
        var ptr3 = modulo.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WQMMFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WQOPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqop_free(ptr >>> 0, 1));
/**
 * Simple 256bit operations
 */
class WQOP {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQOP.prototype);
        obj.__wbg_ptr = ptr;
        WQOPFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQOPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqop_free(ptr, 0);
    }
    /**
     * Construct a `WQOP` instruction from its arguments.
     * @param {RegId} ra
     * @param {RegId} rb
     * @param {RegId} rc
     * @param {MathArgs} args
     * @returns {WQOP}
     */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, MathArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdop_from_args(ptr0, ptr1, ptr2, ptr3);
        return WQOP.__wrap(ret);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     * @param {Imm06} flags
     */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WQOPFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 6-bit immediate value.
     * @returns {Imm06}
     */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const XORFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_xor_free(ptr >>> 0, 1));
/**
 * Bitwise XORs two registers.
 */
class XOR {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        XORFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_xor_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        XORFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const XORIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_xori_free(ptr >>> 0, 1));
/**
 * Bitwise XORs a register and an immediate value.
 */
class XORI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        XORIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_xori_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {Imm12} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        XORIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

async function __wbg_load(module, imports) {
    if (typeof Response === 'function' && module instanceof Response) {
        if (typeof WebAssembly.instantiateStreaming === 'function') {
            try {
                return await WebAssembly.instantiateStreaming(module, imports);

            } catch (e) {
                if (module.headers.get('Content-Type') != 'application/wasm') {
                    console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);

                } else {
                    throw e;
                }
            }
        }

        const bytes = await module.arrayBuffer();
        return await WebAssembly.instantiate(bytes, imports);

    } else {
        const instance = await WebAssembly.instantiate(module, imports);

        if (instance instanceof WebAssembly.Instance) {
            return { instance, module };

        } else {
            return instance;
        }
    }
}

function __wbg_get_imports() {
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
        throw new Error(getStringFromWasm0(arg0, arg1));
    };

    return imports;
}

function __wbg_finalize_init(instance, module) {
    wasm$1 = instance.exports;
    __wbg_init.__wbindgen_wasm_module = module;
    cachedDataViewMemory0 = null;
    cachedUint8ArrayMemory0 = null;



    return wasm$1;
}

function initSync(module) {
    if (wasm$1 !== undefined) return wasm$1;


    if (typeof module !== 'undefined') {
        if (Object.getPrototypeOf(module) === Object.prototype) {
            ({module} = module);
        } else {
            console.warn('using deprecated parameters for `initSync()`; pass a single object instead');
        }
    }

    const imports = __wbg_get_imports();

    if (!(module instanceof WebAssembly.Module)) {
        module = new WebAssembly.Module(module);
    }

    const instance = new WebAssembly.Instance(module, imports);

    return __wbg_finalize_init(instance, module);
}

async function __wbg_init(module_or_path) {
    if (wasm$1 !== undefined) return wasm$1;


    if (typeof module_or_path !== 'undefined') {
        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
            ({module_or_path} = module_or_path);
        } else {
            console.warn('using deprecated parameters for the initialization function; pass a single object instead');
        }
    }
    const imports = __wbg_get_imports();

    const { instance, module } = await __wbg_load(await module_or_path, imports);

    return __wbg_finalize_init(instance, module);
}

function _loadWasmModule (sync, filepath, src, imports) {
  function _instantiateOrCompile(source, imports, stream) {
    var instantiateFunc = stream ? WebAssembly.instantiateStreaming : WebAssembly.instantiate;
    var compileFunc = stream ? WebAssembly.compileStreaming : WebAssembly.compile;

    if (imports) {
      return instantiateFunc(source, imports)
    } else {
      return compileFunc(source)
    }
  }

  
var buf = null;
var isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;
if (isNode) {
  
buf = Buffer.from(src, 'base64');

} else {
  
var raw = globalThis.atob(src);
var rawLength = raw.length;
buf = new Uint8Array(new ArrayBuffer(rawLength));
for(var i = 0; i < rawLength; i++) {
   buf[i] = raw.charCodeAt(i);
}

}


  if(sync) {
    var mod = new WebAssembly.Module(buf);
    return imports ? new WebAssembly.Instance(mod, imports) : mod
  } else {
    return _instantiateOrCompile(buf, imports, false)
  }
}

function wasm(imports){return _loadWasmModule(1, null, 'AGFzbQEAAAABRwxgA39/fwF/YAF/AX9gBH9/f38Bf2ACf38Bf2ACf38AYAABf2ABfwBgBX9/f39/AX9gA39/fwBgAn5/AX9gBH9/f38AYAAAAhgBA3diZxBfX3diaW5kZ2VuX3Rocm93AAQDigKIAgEDCQEEBAQEBAEEAQQEAQMKAQEEAQQBAQEDAQQEAQEEAQEEAgEBBAICAgICAgQEBAMDAwMDAwMDAgEBBAQABAICAwAAAwMDAwMDAwMDAwABAQQEBAEBAQEBAQECAQYBAQEEBgYBAQEEBAICAQUAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEDAAEHAgIGBAQAAgAGCAMBAwELAwMDBAEBBAYBBQQFBQUFBQUFBQUFBQUFBQUFBQUEBwcCAgMCBwcAAAgAAwQFAXABCAgFAwEAEQYJAX8BQYCAwAALB8FN3QUGbWVtb3J5AgAWX193YmdfY29tcGFyZWFyZ3NfZnJlZQAUGl9fd2JnX2dldF9jb21wYXJlYXJnc19tb2RlAFAaX193Ymdfc2V0X2NvbXBhcmVhcmdzX21vZGUAPCJfX3diZ19nZXRfY29tcGFyZWFyZ3NfaW5kaXJlY3RfcmhzAFEiX193Ymdfc2V0X2NvbXBhcmVhcmdzX2luZGlyZWN0X3JocwBTEmNvbXBhcmVhcmdzX3RvX2ltbQBfFGNvbXBhcmVhcmdzX2Zyb21faW1tABUVX193YmdfZ2V0X21hdGhhcmdzX29wAFAVX193Ymdfc2V0X21hdGhhcmdzX29wAD0SX193YmdfbXVsYXJnc19mcmVlABYeX193YmdfZ2V0X211bGFyZ3NfaW5kaXJlY3RfcmhzAFAeX193Ymdfc2V0X211bGFyZ3NfaW5kaXJlY3RfcmhzAFQSX193YmdfZGl2YXJnc19mcmVlACceX193YmdfZ2V0X2RpdmFyZ3NfaW5kaXJlY3RfcmhzAMABHl9fd2JnX3NldF9kaXZhcmdzX2luZGlyZWN0X3JocwBpG19fd2JnX3BhbmljaW5zdHJ1Y3Rpb25fZnJlZQAcIXBhbmljaW5zdHJ1Y3Rpb25fZXJyb3JfdHlwZXNjcmlwdABCF3BhbmljaW5zdHJ1Y3Rpb25fcmVhc29uAGAccGFuaWNpbnN0cnVjdGlvbl9pbnN0cnVjdGlvbgBhDGdtX2Zyb21fYXJncwDbAQ1ndGZfZnJvbV9hcmdzANQBB2dtX2FyZ3MAjwEIZ3RmX2FyZ3MAbg53ZGNtX2Zyb21fYXJncwBADndkb3BfZnJvbV9hcmdzAEAOd2RtbF9mcm9tX2FyZ3MAQQ53ZGR2X2Zyb21fYXJncwDPAQl3ZGNtX2FyZ3MAKAl3cWNtX2FyZ3MAKQl3ZG9wX2FyZ3MAKgl3cW9wX2FyZ3MAKwl3ZG1sX2FyZ3MALAl3cW1sX2FyZ3MALQl3ZGR2X2FyZ3MAagl3cWR2X2FyZ3MAaxBfX3diZ19pbW0wNl9mcmVlAC4QX193YmdfaW1tMTJfZnJlZQAvEF9fd2JnX2ltbTE4X2ZyZWUAMA5fX3diZ19hZGRfZnJlZQAdD19fd2JnX25vb3BfZnJlZQAJEmFkZF9uZXdfdHlwZXNjcmlwdABDBmFkZF9yYQA6BmFkZF9yYgAXBmFkZF9yYwAeA2FkZADMAQNhbmQAkQEDZGl2AJIBAmVxAJMBA2V4cACUAQJndACVAQJsdACWAQRtbG9nAJcBBG1yb28AmAEEbW9kXwCZAQVtb3ZlXwBFA211bACaAQNub3QARgJvcgCbAQNzbGwAnAEDc3JsAJ0BA3N1YgCeAQN4b3IAnwEEbWxkdgBvA3JldADBAQRyZXRkAEcTYWxvY19uZXdfdHlwZXNjcmlwdABdB2Fsb2NfcmEAJQRhbG9jAMIBA21jbABIA21jcACgAQNtZXEAcBNiaHNoX25ld190eXBlc2NyaXB0ABoEYmhzaAAxBGJoZWkAwwEEYnVybgBJBGNhbGwAcQNjY3AAcgRjcm9vAEoEY3NpegBLAmNiAMQBA2xkYwBzA2xvZwB0BGxvZ2QAdQRtaW50AEwEcnZydADFAQRzY3dxAKEBA3NydwCiAQRzcndxAHYDc3d3AKMBBHN3d3EAdwJ0cgCkAQN0cm8AeARlY2sxAKUBBGVjcjEApgEEZWQxOQB5BGsyNTYApwEEczI1NgCoAQR0aW1lAE0Tbm9vcF9uZXdfdHlwZXNjcmlwdABtBG5vb3AA5wEEZmxhZwDGAQNiYWwAqQEDam1wAMcBA2puZQCqAQNzbW8AehNhZGRpX25ld190eXBlc2NyaXB0AEQKYWRkaV9pbW0xMgAKBGFkZGkAqwEEYW5kaQCsAQRkaXZpAK0BBGV4cGkArgEEbW9kaQCvAQRtdWxpALABA29yaQCxAQRzbGxpALIBBHNybGkAswEEc3ViaQC0AQR4b3JpALUBBGpuZWkAtgECbGIAtwECbHcAuAECc2IAuQECc3cAugEEbWNwaQC7ARJndGZfbmV3X3R5cGVzY3JpcHQA1gEDZ3RmALwBBG1jbGkAMhFnbV9uZXdfdHlwZXNjcmlwdABOCGdtX2ltbTE4AA8CZ20AMwRtb3ZpADQEam56aQA1BGptcGYANhNqbXBiX25ld190eXBlc2NyaXB0ABAEam1wYgA3BGpuemYAvQEEam56YgC+AQRqbmVmAHsKam5lYl9pbW0wNgA7BGpuZWIAfAJqaQBVE2NmZWlfbmV3X3R5cGVzY3JpcHQAJgpjZmVpX2ltbTI0AAwEY2ZlaQBWBGNmc2kAVwNjZmUAyAEDY2ZzAMkBBHBzaGwAWARwc2hoAFkEcG9wbABaBHBvcGgAWxN3ZGNtX25ld190eXBlc2NyaXB0ANABBHdkY20AfQR3cWNtAH4Ed2RvcAB/BHdxb3AAgAEEd2RtbACBAQR3cW1sAIIBBHdkZHYAgwEEd3FkdgCEAQR3ZG1kAIUBBHdxbWQAhgEEd2RhbQCHAQR3cWFtAIgBBHdkbW0AiQEEd3FtbQCKAQRlY2FsAIsBBGJzaXoAOBNibGRkX25ld190eXBlc2NyaXB0ADkHYmxkZF9yZAA7BGJsZGQAjAEEZWNvcACNAQRlcGFyAI4BFl9fd2JnX2luc3RydWN0aW9uX2ZyZWUADhRpbnN0cnVjdGlvbl90b19ieXRlcwAIEGluc3RydWN0aW9uX3NpemUA+gERcmVnaWRfbmV3X2NoZWNrZWQAvwEJcmVnaWRfYmFsAOkBCnJlZ2lkX2NnYXMA6gEJcmVnaWRfZXJyAOsBCnJlZ2lkX2ZsYWcA7AEIcmVnaWRfZnAA7QEKcmVnaWRfZ2dhcwDuAQhyZWdpZF9ocADvAQhyZWdpZF9pcwDwAQhyZWdpZF9vZgDxAQlyZWdpZF9vbmUA8gEIcmVnaWRfcGMA8wEJcmVnaWRfcmV0APQBCnJlZ2lkX3JldGwA9QEIcmVnaWRfc3AA9gEJcmVnaWRfc3BwAPcBDnJlZ2lkX3dyaXRhYmxlAPgBCnJlZ2lkX3plcm8A+QEUcmVnaWRfbmV3X3R5cGVzY3JpcHQA4gELcmVnaWRfdG9fdTgA4wESYW5kX25ld190eXBlc2NyaXB0AEMSZGl2X25ld190eXBlc2NyaXB0AEMRZXFfbmV3X3R5cGVzY3JpcHQAQxJleHBfbmV3X3R5cGVzY3JpcHQAQxFndF9uZXdfdHlwZXNjcmlwdABDEWx0X25ld190eXBlc2NyaXB0AEMTbWxvZ19uZXdfdHlwZXNjcmlwdABDE21yb29fbmV3X3R5cGVzY3JpcHQAQxJtb2RfbmV3X3R5cGVzY3JpcHQAQxJtdWxfbmV3X3R5cGVzY3JpcHQAQxFvcl9uZXdfdHlwZXNjcmlwdABDEnNsbF9uZXdfdHlwZXNjcmlwdABDEnNybF9uZXdfdHlwZXNjcmlwdABDEnN1Yl9uZXdfdHlwZXNjcmlwdABDEnhvcl9uZXdfdHlwZXNjcmlwdABDEm1jcF9uZXdfdHlwZXNjcmlwdABDE3Njd3FfbmV3X3R5cGVzY3JpcHQAQxJzcndfbmV3X3R5cGVzY3JpcHQAQxJzd3dfbmV3X3R5cGVzY3JpcHQAQxF0cl9uZXdfdHlwZXNjcmlwdABDE2VjazFfbmV3X3R5cGVzY3JpcHQAQxNlY3IxX25ld190eXBlc2NyaXB0AEMTazI1Nl9uZXdfdHlwZXNjcmlwdABDE3MyNTZfbmV3X3R5cGVzY3JpcHQAQxJiYWxfbmV3X3R5cGVzY3JpcHQAQxJqbmVfbmV3X3R5cGVzY3JpcHQAQxNhbmRpX25ld190eXBlc2NyaXB0AEQTZGl2aV9uZXdfdHlwZXNjcmlwdABEE2V4cGlfbmV3X3R5cGVzY3JpcHQARBNtb2RpX25ld190eXBlc2NyaXB0AEQTbXVsaV9uZXdfdHlwZXNjcmlwdABEEm9yaV9uZXdfdHlwZXNjcmlwdABEE3NsbGlfbmV3X3R5cGVzY3JpcHQARBNzcmxpX25ld190eXBlc2NyaXB0AEQTc3ViaV9uZXdfdHlwZXNjcmlwdABEE3hvcmlfbmV3X3R5cGVzY3JpcHQARBNqbmVpX25ld190eXBlc2NyaXB0AEQRbGJfbmV3X3R5cGVzY3JpcHQARBFsd19uZXdfdHlwZXNjcmlwdABEEXNiX25ld190eXBlc2NyaXB0AEQRc3dfbmV3X3R5cGVzY3JpcHQARBNtY3BpX25ld190eXBlc2NyaXB0AEQTam56Zl9uZXdfdHlwZXNjcmlwdABEE2puemJfbmV3X3R5cGVzY3JpcHQARBFqaV9uZXdfdHlwZXNjcmlwdAAmE2Nmc2lfbmV3X3R5cGVzY3JpcHQAJhNwc2hsX25ld190eXBlc2NyaXB0ACYTcHNoaF9uZXdfdHlwZXNjcmlwdAAmE3BvcGxfbmV3X3R5cGVzY3JpcHQAJhNwb3BoX25ld190eXBlc2NyaXB0ACYSbm90X25ld190eXBlc2NyaXB0ABoTcmV0ZF9uZXdfdHlwZXNjcmlwdAAaE21vdmVfbmV3X3R5cGVzY3JpcHQAGhJtY2xfbmV3X3R5cGVzY3JpcHQAGhNidXJuX25ld190eXBlc2NyaXB0ABoTY3Jvb19uZXdfdHlwZXNjcmlwdAAaE2NzaXpfbmV3X3R5cGVzY3JpcHQAGhNtaW50X25ld190eXBlc2NyaXB0ABoTdGltZV9uZXdfdHlwZXNjcmlwdAAaE2JzaXpfbmV3X3R5cGVzY3JpcHQAGhJyZXRfbmV3X3R5cGVzY3JpcHQAXRNiaGVpX25ld190eXBlc2NyaXB0AF0RY2JfbmV3X3R5cGVzY3JpcHQAXRNydnJ0X25ld190eXBlc2NyaXB0AF0TZmxhZ19uZXdfdHlwZXNjcmlwdABdEmptcF9uZXdfdHlwZXNjcmlwdABdEmNmZV9uZXdfdHlwZXNjcmlwdABdEmNmc19uZXdfdHlwZXNjcmlwdABdE21sZHZfbmV3X3R5cGVzY3JpcHQAORJtZXFfbmV3X3R5cGVzY3JpcHQAORJjY3BfbmV3X3R5cGVzY3JpcHQAORJsb2dfbmV3X3R5cGVzY3JpcHQAORNsb2dkX25ld190eXBlc2NyaXB0ADkTc3J3cV9uZXdfdHlwZXNjcmlwdAA5E3N3d3FfbmV3X3R5cGVzY3JpcHQAORJ0cm9fbmV3X3R5cGVzY3JpcHQAORNlZDE5X25ld190eXBlc2NyaXB0ADkSc21vX25ld190eXBlc2NyaXB0ADkSbGRjX25ld190eXBlc2NyaXB0ADkTam5lZl9uZXdfdHlwZXNjcmlwdAA5E3dkbWRfbmV3X3R5cGVzY3JpcHQAORN3cW1kX25ld190eXBlc2NyaXB0ADkTd2RhbV9uZXdfdHlwZXNjcmlwdAA5E3dxYW1fbmV3X3R5cGVzY3JpcHQAORN3ZG1tX25ld190eXBlc2NyaXB0ADkTd3FtbV9uZXdfdHlwZXNjcmlwdAA5E2VjYWxfbmV3X3R5cGVzY3JpcHQAORNjYWxsX25ld190eXBlc2NyaXB0ADkTZWNvcF9uZXdfdHlwZXNjcmlwdAA5E2VwYXJfbmV3X3R5cGVzY3JpcHQAOQZyZXRfcmEAJQdiaGVpX3JhACUFY2JfcmEAJQdydnJ0X3JhACUHZmxhZ19yYQAlBmptcF9yYQAlCGppX2ltbTI0AAwKY2ZzaV9pbW0yNAAMBmNmZV9yYQAlBmNmc19yYQAlCnBzaGxfaW1tMjQADApwc2hoX2ltbTI0AAwKcG9wbF9pbW0yNAAMCnBvcGhfaW1tMjQADBNtb3ZpX25ld190eXBlc2NyaXB0ABATbWNsaV9uZXdfdHlwZXNjcmlwdAAQE2puemlfbmV3X3R5cGVzY3JpcHQAEBNqbXBmX25ld190eXBlc2NyaXB0ABATX193YmdfbWF0aGFyZ3NfZnJlZQAUH19fd2JnX3NldF9tYXRoYXJnc19pbmRpcmVjdF9yaHMAUx5fX3diZ19zZXRfbXVsYXJnc19pbmRpcmVjdF9saHMAUx9fX3diZ19nZXRfbWF0aGFyZ3NfaW5kaXJlY3RfcmhzAFEeX193YmdfZ2V0X211bGFyZ3NfaW5kaXJlY3RfbGhzAFEPX193YmdfZXhwaV9mcmVlAB0PX193YmdfYmhlaV9mcmVlAB0PX193Ymdfd2RtbF9mcmVlAB0PX193YmdfcHNobF9mcmVlAB0OX193YmdfbG9nX2ZyZWUAHQ5fX3diZ19jY3BfZnJlZQAdD19fd2JnX2VjazFfZnJlZQAdD19fd2JnX2VjcjFfZnJlZQAdDl9fd2JnX3Ntb19mcmVlAB0OX193Ymdfb3JpX2ZyZWUAHQ5fX3diZ190cm9fZnJlZQAdDl9fd2JnX21lcV9mcmVlAB0OX193YmdfY2ZzX2ZyZWUAHQ5fX3diZ19kaXZfZnJlZQAdDV9fd2JnX2x0X2ZyZWUAHQ9fX3diZ19iaHNoX2ZyZWUAHQ1fX3diZ19zYl9mcmVlAB0PX193Ymdfd2RtZF9mcmVlAB0NX193YmdfdHJfZnJlZQAdDl9fd2JnX3hvcl9mcmVlAB0PX193Ymdfam5lYl9mcmVlAB0PX193Ymdfam5lZl9mcmVlAB0PX193YmdfY3Npel9mcmVlAB0PX193YmdfY3Jvb19mcmVlAB0PX193YmdfZGl2aV9mcmVlAB0NX193YmdfZ21fZnJlZQAdD19fd2JnX21vZGlfZnJlZQAdD19fd2JnX3hvcmlfZnJlZQAdDV9fd2JnX2NiX2ZyZWUAHQ9fX3diZ193ZGNtX2ZyZWUAHQ5fX3diZ19qbXBfZnJlZQAdD19fd2JnX3dxYW1fZnJlZQAdDl9fd2JnX2xkY19mcmVlAB0PX193YmdfZWQxOV9mcmVlAB0NX193Ymdfc3dfZnJlZQAdD19fd2JnX3RpbWVfZnJlZQAdD19fd2JnX2Vjb3BfZnJlZQAdD19fd2JnX3Njd3FfZnJlZQAdD19fd2JnX3dxbW1fZnJlZQAdD19fd2JnX3dkYW1fZnJlZQAdDV9fd2JnX2xiX2ZyZWUAHQ1fX3diZ19qaV9mcmVlAB0PX193YmdfazI1Nl9mcmVlAB0PX193YmdfYW5kaV9mcmVlAB0PX193Ymdfam56aV9mcmVlAB0PX193Ymdfc3J3cV9mcmVlAB0OX193Ymdfbm90X2ZyZWUAHQ5fX3diZ19jZmVfZnJlZQAdD19fd2JnX2xvZ2RfZnJlZQAdDl9fd2JnX3Nyd19mcmVlAB0PX193YmdfcnZydF9mcmVlAB0PX193YmdfcHNoaF9mcmVlAB0OX193Ymdfc3JsX2ZyZWUAHQ5fX3diZ19tdWxfZnJlZQAdD19fd2JnX2ZsYWdfZnJlZQAdD19fd2JnX21jcGlfZnJlZQAdDl9fd2JnX21vZF9mcmVlAB0PX193YmdfbW92aV9mcmVlAB0OX193YmdfcmV0X2ZyZWUAHQ9fX3diZ19tcm9vX2ZyZWUAHQ9fX3diZ193cWR2X2ZyZWUAHQ1fX3diZ19sd19mcmVlAB0PX193Ymdfd3FtZF9mcmVlAB0OX193Ymdfc3d3X2ZyZWUAHQ5fX3diZ19ndGZfZnJlZQAdD19fd2JnX3BvcGhfZnJlZQAdDV9fd2JnX29yX2ZyZWUAHQ9fX3diZ19tb3ZlX2ZyZWUAHQ9fX3diZ193ZGR2X2ZyZWUAHQ9fX3diZ19yZXRkX2ZyZWUAHQ5fX3diZ19iYWxfZnJlZQAdD19fd2JnX2FkZGlfZnJlZQAdDl9fd2JnX2FuZF9mcmVlAB0PX193YmdfbWNsaV9mcmVlAB0PX193Ymdfd3FtbF9mcmVlAB0PX193Ymdfc2xsaV9mcmVlAB0PX193Ymdfd2RvcF9mcmVlAB0OX193Ymdfc2xsX2ZyZWUAHQ9fX3diZ19lY2FsX2ZyZWUAHQ9fX3diZ193cWNtX2ZyZWUAHQ9fX3diZ19zd3dxX2ZyZWUAHQ9fX3diZ19tbGR2X2ZyZWUAHQ1fX3diZ19ndF9mcmVlAB0NX193YmdfZXFfZnJlZQAdDl9fd2JnX2puZV9mcmVlAB0PX193Ymdfam5laV9mcmVlAB0PX193Ymdfam1wZl9mcmVlAB0OX193YmdfZXhwX2ZyZWUAHQ9fX3diZ19zMjU2X2ZyZWUAHQ5fX3diZ19zdWJfZnJlZQAdDl9fd2JnX21jcF9mcmVlAB0PX193YmdfZXBhcl9mcmVlAB0PX193YmdfY2ZlaV9mcmVlAB0PX193YmdfY2ZzaV9mcmVlAB0PX193Ymdfam56Zl9mcmVlAB0PX193YmdfbWludF9mcmVlAB0PX193YmdfYnNpel9mcmVlAB0PX193YmdfYnVybl9mcmVlAB0PX193Ymdfd2RtbV9mcmVlAB0PX193Ymdfam1wYl9mcmVlAB0PX193Ymdfc3JsaV9mcmVlAB0PX193Ymdfc3ViaV9mcmVlAB0PX193Ymdfam56Yl9mcmVlAB0PX193YmdfbXVsaV9mcmVlAB0PX193Ymdfd3FvcF9mcmVlAB0PX193YmdfcG9wbF9mcmVlAB0OX193YmdfbWNsX2ZyZWUAHQ9fX3diZ19jYWxsX2ZyZWUAHQ9fX3diZ19tbG9nX2ZyZWUAHQ9fX3diZ19ibGRkX2ZyZWUAHQ9fX3diZ19hbG9jX2ZyZWUAHRN3cWR2X25ld190eXBlc2NyaXB0ANABE3dxbWxfbmV3X3R5cGVzY3JpcHQA0AETd2RtbF9uZXdfdHlwZXNjcmlwdADQARN3cW9wX25ld190eXBlc2NyaXB0ANABE3dkb3BfbmV3X3R5cGVzY3JpcHQA0AETd3FjbV9uZXdfdHlwZXNjcmlwdADQARN3ZGR2X25ld190eXBlc2NyaXB0ANABDndxY21fZnJvbV9hcmdzAEAKd3Fkdl9pbW0wNgA7CndxbWxfaW1tMDYAOwp3ZG1sX2ltbTA2ADsKd3FvcF9pbW0wNgA7Cndkb3BfaW1tMDYAOwp3cWNtX2ltbTA2ADsKd2Rkdl9pbW0wNgA7CndkY21faW1tMDYAOwpqbmVmX2ltbTA2ADsJbGRjX2ltbTA2ADsOd3Fkdl9mcm9tX2FyZ3MAzwEOd3FtbF9mcm9tX2FyZ3MAQQ53cW9wX2Zyb21fYXJncwBABWdtX3JhADoFZ3RfcmMAHgVndF9yYgAXBWd0X3JhADoFbGJfcmIAFwVsYl9yYQA6BWx0X3JjAB4FbHRfcmIAFwVsdF9yYQA6CGx3X2ltbTEyAAoFbHdfcmIAFwVsd19yYQA6BW9yX3JjAB4Fb3JfcmIAFwVvcl9yYQA6CHNiX2ltbTEyAAoFc2JfcmIAFwVzYl9yYQA6CHN3X2ltbTEyAAoFc3dfcmIAFwVzd19yYQA6BXRyX3JjAB4FdHJfcmIAFwV0cl9yYQA6BWVxX3JjAB4FZXFfcmIAFwVlcV9yYQA6BmFuZF9yYwAeBmFuZF9yYgAXBmFuZF9yYQA6BmJhbF9yYwAeBmJhbF9yYgAXBmJhbF9yYQA6BmNjcF9yYwAeBmNjcF9yYgAXBmNjcF9yYQA6BmRpdl9yYwAeBmRpdl9yYgAXBmRpdl9yYQA6BmV4cF9yYwAeBmV4cF9yYgAXBmV4cF9yYQA6CGxiX2ltbTEyAAoGZ3RmX3JiABcGZ3RmX3JhADoGam5lX3JjAB4Gam5lX3JiABcGam5lX3JhADoGbGRjX3JjAB4GbGRjX3JiABcGbGRjX3JhADoGbG9nX3JkADsGbG9nX3JjAB4GbG9nX3JiABcGbG9nX3JhADoGbWNsX3JiABcGbWNsX3JhADoGbWNwX3JjAB4GbWNwX3JiABcGbWNwX3JhADoGbWVxX3JkADsGbWVxX3JjAB4GbWVxX3JiABcGbWVxX3JhADoGbW9kX3JjAB4GbW9kX3JiABcGbW9kX3JhADoGbXVsX3JjAB4GbXVsX3JiABcGbXVsX3JhADoGbm90X3JiABcGbm90X3JhADoJb3JpX2ltbTEyAAoGb3JpX3JiABcGb3JpX3JhADoGc2xsX3JjAB4Gc2xsX3JiABcGc2xsX3JhADoGc21vX3JkADsGc21vX3JjAB4Gc21vX3JiABcGc21vX3JhADoGc3JsX3JjAB4Gc3JsX3JiABcGc3JsX3JhADoGc3J3X3JjAB4Gc3J3X3JiABcGc3J3X3JhADoGc3ViX3JjAB4Gc3ViX3JiABcGc3ViX3JhADoGc3d3X3JjAB4Gc3d3X3JiABcGc3d3X3JhADoGdHJvX3JkADsGdHJvX3JjAB4GdHJvX3JiABcGdHJvX3JhADoGeG9yX3JjAB4GeG9yX3JiABcGeG9yX3JhADoJZ3RmX2ltbTEyAAoHYWRkaV9yYgAXB2FkZGlfcmEAOgphbmRpX2ltbTEyAAoHYW5kaV9yYgAXB2FuZGlfcmEAOgdiaHNoX3JiABcHYmhzaF9yYQA6BmNjcF9yZAA7B2JsZGRfcmMAHgdibGRkX3JiABcHYmxkZF9yYQA6B2JzaXpfcmIAFwdic2l6X3JhADoHYnVybl9yYgAXB2J1cm5fcmEAOgdjYWxsX3JkADsHY2FsbF9yYwAeB2NhbGxfcmIAFwdjYWxsX3JhADoHY3Jvb19yYgAXB2Nyb29fcmEAOgdjc2l6X3JiABcHY3Npel9yYQA6CmRpdmlfaW1tMTIACgdkaXZpX3JiABcHZGl2aV9yYQA6B2VjYWxfcmQAOwdlY2FsX3JjAB4HZWNhbF9yYgAXB2VjYWxfcmEAOgdlY2sxX3JjAB4HZWNrMV9yYgAXB2VjazFfcmEAOgdlY29wX3JkADsHZWNvcF9yYwAeB2Vjb3BfcmIAFwdlY29wX3JhADoHZWNyMV9yYwAeB2VjcjFfcmIAFwdlY3IxX3JhADoHZWQxOV9yZAA7B2VkMTlfcmMAHgdlZDE5X3JiABcHZWQxOV9yYQA6B2VwYXJfcmQAOwdlcGFyX3JjAB4HZXBhcl9yYgAXB2VwYXJfcmEAOgpleHBpX2ltbTEyAAoHZXhwaV9yYgAXB2V4cGlfcmEAOgpqbXBiX2ltbTE4AA8Ham1wYl9yYQA6CmptcGZfaW1tMTgADwdqbXBmX3JhADoHam5lYl9yYwAeB2puZWJfcmIAFwdqbmViX3JhADoHam5lZl9yYwAeB2puZWZfcmIAFwdqbmVmX3JhADoKam5laV9pbW0xMgAKB2puZWlfcmIAFwdqbmVpX3JhADoKam56Yl9pbW0xMgAKB2puemJfcmIAFwdqbnpiX3JhADoKam56Zl9pbW0xMgAKB2puemZfcmIAFwdqbnpmX3JhADoKam56aV9pbW0xOAAPB2puemlfcmEAOgdrMjU2X3JjAB4HazI1Nl9yYgAXB2syNTZfcmEAOgdsb2dkX3JkADsHbG9nZF9yYwAeB2xvZ2RfcmIAFwdsb2dkX3JhADoKbWNsaV9pbW0xOAAPB21jbGlfcmEAOgptY3BpX2ltbTEyAAoHbWNwaV9yYgAXB21jcGlfcmEAOgdtaW50X3JiABcHbWludF9yYQA6B21sZHZfcmQAOwdtbGR2X3JjAB4HbWxkdl9yYgAXB21sZHZfcmEAOgdtbG9nX3JjAB4HbWxvZ19yYgAXB21sb2dfcmEAOgptb2RpX2ltbTEyAAoHbW9kaV9yYgAXB21vZGlfcmEAOgdtb3ZlX3JiABcHbW92ZV9yYQA6Cm1vdmlfaW1tMTgADwdtb3ZpX3JhADoHbXJvb19yYwAeB21yb29fcmIAFwdtcm9vX3JhADoKbXVsaV9pbW0xMgAKB211bGlfcmIAFwdtdWxpX3JhADoHcmV0ZF9yYgAXB3JldGRfcmEAOgdzMjU2X3JjAB4HczI1Nl9yYgAXB3MyNTZfcmEAOgdzY3dxX3JjAB4Hc2N3cV9yYgAXB3Njd3FfcmEAOgpzbGxpX2ltbTEyAAoHc2xsaV9yYgAXB3NsbGlfcmEAOgpzcmxpX2ltbTEyAAoHc3JsaV9yYgAXB3NybGlfcmEAOgdzcndxX3JkADsHc3J3cV9yYwAeB3Nyd3FfcmIAFwdzcndxX3JhADoKc3ViaV9pbW0xMgAKB3N1YmlfcmIAFwdzdWJpX3JhADoHc3d3cV9yZAA7B3N3d3FfcmMAHgdzd3dxX3JiABcHc3d3cV9yYQA6B3RpbWVfcmIAFwd0aW1lX3JhADoHd2RhbV9yZAA7B3dkYW1fcmMAHgd3ZGFtX3JiABcHd2RhbV9yYQA6B3dkY21fcmMAHgd3ZGNtX3JiABcHd2RjbV9yYQA6B3dkZHZfcmMAHgd3ZGR2X3JiABcHd2Rkdl9yYQA6B3dkbWRfcmQAOwd3ZG1kX3JjAB4Hd2RtZF9yYgAXB3dkbWRfcmEAOgd3ZG1sX3JjAB4Hd2RtbF9yYgAXB3dkbWxfcmEAOgd3ZG1tX3JkADsHd2RtbV9yYwAeB3dkbW1fcmIAFwd3ZG1tX3JhADoHd2RvcF9yYwAeB3dkb3BfcmIAFwd3ZG9wX3JhADoHd3FhbV9yZAA7B3dxYW1fcmMAHgd3cWFtX3JiABcHd3FhbV9yYQA6B3dxY21fcmMAHgd3cWNtX3JiABcHd3FjbV9yYQA6B3dxZHZfcmMAHgd3cWR2X3JiABcHd3Fkdl9yYQA6B3dxbWRfcmQAOwd3cW1kX3JjAB4Hd3FtZF9yYgAXB3dxbWRfcmEAOgd3cW1sX3JjAB4Hd3FtbF9yYgAXB3dxbWxfcmEAOgd3cW1tX3JkADsHd3FtbV9yYwAeB3dxbW1fcmIAFwd3cW1tX3JhADoHd3FvcF9yYwAeB3dxb3BfcmIAFwd3cW9wX3JhADoKeG9yaV9pbW0xMgAKB3hvcmlfcmIAFwd4b3JpX3JhADoTam5lYl9uZXdfdHlwZXNjcmlwdAA5EF9fd2JnX3JlZ2lkX2ZyZWUALhBfX3diZ19pbW0yNF9mcmVlADAfX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcgDcARNfX3diaW5kZ2VuX2V4cG9ydF8wANgBCRMBAEEBCwcC3gHfAeAB6AHkAdEBCvOQAYgC7SICCH8BfgJAAkACQAJAAkACQAJAAkAgAEH1AU8EQCAAQc3/e08NBSAAQQtqIgBBeHEhBUHsj8AAKAIAIghFDQRBACAFayEEAn9BACAFQYACSQ0AGkEfIAVB////B0sNABogBUEGIABBCHZnIgBrdkEBcSAAQQF0a0E+agsiB0ECdEHQjMAAaigCACICRQRAQQAhAAwCC0EAIQAgBUEZIAdBAXZrQQAgB0EfRxt0IQMDQAJAIAIoAgRBeHEiBiAFSQ0AIAYgBWsiBiAETw0AIAIhASAGIgQNAEEAIQQgASEADAQLIAIoAhQiBiAAIAYgAiADQR12QQRxakEQaigCACICRxsgACAGGyEAIANBAXQhAyACDQALDAELQeiPwAAoAgAiAkEQIABBC2pB+ANxIABBC0kbIgVBA3YiAHYiAUEDcQRAAkAgAUF/c0EBcSAAaiIBQQN0IgBB4I3AAGoiAyAAQeiNwABqKAIAIgAoAggiBEcEQCAEIAM2AgwgAyAENgIIDAELQeiPwAAgAkF+IAF3cTYCAAsgACABQQN0IgFBA3I2AgQgACABaiIBIAEoAgRBAXI2AgQMCAsgBUHwj8AAKAIATQ0DAkACQCABRQRAQeyPwAAoAgAiAEUNBiAAaEECdEHQjMAAaigCACIBKAIEQXhxIAVrIQQgASECA0ACQCABKAIQIgANACABKAIUIgANACACKAIYIQcCQAJAIAIgAigCDCIARgRAIAJBFEEQIAIoAhQiABtqKAIAIgENAUEAIQAMAgsgAigCCCIBIAA2AgwgACABNgIIDAELIAJBFGogAkEQaiAAGyEDA0AgAyEGIAEiAEEUaiAAQRBqIAAoAhQiARshAyAAQRRBECABG2ooAgAiAQ0ACyAGQQA2AgALIAdFDQQgAiACKAIcQQJ0QdCMwABqIgEoAgBHBEAgB0EQQRQgBygCECACRhtqIAA2AgAgAEUNBQwECyABIAA2AgAgAA0DQeyPwABB7I/AACgCAEF+IAIoAhx3cTYCAAwECyAAKAIEQXhxIAVrIgEgBCABIARJIgEbIQQgACACIAEbIQIgACEBDAALAAsCQEECIAB0IgNBACADa3IgASAAdHFoIgBBA3QiAUHgjcAAaiIDIAFB6I3AAGooAgAiASgCCCIERwRAIAQgAzYCDCADIAQ2AggMAQtB6I/AACACQX4gAHdxNgIACyABIAVBA3I2AgQgASAFaiIGIABBA3QiACAFayIEQQFyNgIEIAAgAWogBDYCAEHwj8AAKAIAIgIEQCACQXhxQeCNwABqIQBB+I/AACgCACEDAn9B6I/AACgCACIFQQEgAkEDdnQiAnFFBEBB6I/AACACIAVyNgIAIAAMAQsgACgCCAshAiAAIAM2AgggAiADNgIMIAMgADYCDCADIAI2AggLQfiPwAAgBjYCAEHwj8AAIAQ2AgAgAUEIag8LIAAgBzYCGCACKAIQIgEEQCAAIAE2AhAgASAANgIYCyACKAIUIgFFDQAgACABNgIUIAEgADYCGAsCQAJAIARBEE8EQCACIAVBA3I2AgQgAiAFaiIFIARBAXI2AgQgBCAFaiAENgIAQfCPwAAoAgAiA0UNASADQXhxQeCNwABqIQBB+I/AACgCACEBAn9B6I/AACgCACIGQQEgA0EDdnQiA3FFBEBB6I/AACADIAZyNgIAIAAMAQsgACgCCAshAyAAIAE2AgggAyABNgIMIAEgADYCDCABIAM2AggMAQsgAiAEIAVqIgBBA3I2AgQgACACaiIAIAAoAgRBAXI2AgQMAQtB+I/AACAFNgIAQfCPwAAgBDYCAAsgAkEIag8LIAAgAXJFBEBBACEBQQIgB3QiAEEAIABrciAIcSIARQ0DIABoQQJ0QdCMwABqKAIAIQALIABFDQELA0AgACABIAAoAgRBeHEiAyAFayIGIARJIgcbIQggACgCECICRQRAIAAoAhQhAgsgASAIIAMgBUkiABshASAEIAYgBCAHGyAAGyEEIAIiAA0ACwsgAUUNACAFQfCPwAAoAgAiAE0gBCAAIAVrT3ENACABKAIYIQcCQAJAIAEgASgCDCIARgRAIAFBFEEQIAEoAhQiABtqKAIAIgINAUEAIQAMAgsgASgCCCICIAA2AgwgACACNgIIDAELIAFBFGogAUEQaiAAGyEDA0AgAyEGIAIiAEEUaiAAQRBqIAAoAhQiAhshAyAAQRRBECACG2ooAgAiAg0ACyAGQQA2AgALIAdFDQMgASABKAIcQQJ0QdCMwABqIgIoAgBHBEAgB0EQQRQgBygCECABRhtqIAA2AgAgAEUNBAwDCyACIAA2AgAgAA0CQeyPwABB7I/AACgCAEF+IAEoAhx3cTYCAAwDCwJAAkACQAJAAkAgBUHwj8AAKAIAIgFLBEAgBUH0j8AAKAIAIgBPBEBBACEEIAVBr4AEaiIAQRB2QAAiAUF/RiIDDQcgAUEQdCICRQ0HQYCQwABBACAAQYCAfHEgAxsiBEGAkMAAKAIAaiIANgIAQYSQwABBhJDAACgCACIBIAAgACABSRs2AgACQAJAQfyPwAAoAgAiAwRAQdCNwAAhAANAIAAoAgAiASAAKAIEIgZqIAJGDQIgACgCCCIADQALDAILQYyQwAAoAgAiAEEAIAAgAk0bRQRAQYyQwAAgAjYCAAtBkJDAAEH/HzYCAEHUjcAAIAQ2AgBB0I3AACACNgIAQeyNwABB4I3AADYCAEH0jcAAQeiNwAA2AgBB6I3AAEHgjcAANgIAQfyNwABB8I3AADYCAEHwjcAAQeiNwAA2AgBBhI7AAEH4jcAANgIAQfiNwABB8I3AADYCAEGMjsAAQYCOwAA2AgBBgI7AAEH4jcAANgIAQZSOwABBiI7AADYCAEGIjsAAQYCOwAA2AgBBnI7AAEGQjsAANgIAQZCOwABBiI7AADYCAEGkjsAAQZiOwAA2AgBBmI7AAEGQjsAANgIAQdyNwABBADYCAEGsjsAAQaCOwAA2AgBBoI7AAEGYjsAANgIAQaiOwABBoI7AADYCAEG0jsAAQaiOwAA2AgBBsI7AAEGojsAANgIAQbyOwABBsI7AADYCAEG4jsAAQbCOwAA2AgBBxI7AAEG4jsAANgIAQcCOwABBuI7AADYCAEHMjsAAQcCOwAA2AgBByI7AAEHAjsAANgIAQdSOwABByI7AADYCAEHQjsAAQciOwAA2AgBB3I7AAEHQjsAANgIAQdiOwABB0I7AADYCAEHkjsAAQdiOwAA2AgBB4I7AAEHYjsAANgIAQeyOwABB4I7AADYCAEH0jsAAQeiOwAA2AgBB6I7AAEHgjsAANgIAQfyOwABB8I7AADYCAEHwjsAAQeiOwAA2AgBBhI/AAEH4jsAANgIAQfiOwABB8I7AADYCAEGMj8AAQYCPwAA2AgBBgI/AAEH4jsAANgIAQZSPwABBiI/AADYCAEGIj8AAQYCPwAA2AgBBnI/AAEGQj8AANgIAQZCPwABBiI/AADYCAEGkj8AAQZiPwAA2AgBBmI/AAEGQj8AANgIAQayPwABBoI/AADYCAEGgj8AAQZiPwAA2AgBBtI/AAEGoj8AANgIAQaiPwABBoI/AADYCAEG8j8AAQbCPwAA2AgBBsI/AAEGoj8AANgIAQcSPwABBuI/AADYCAEG4j8AAQbCPwAA2AgBBzI/AAEHAj8AANgIAQcCPwABBuI/AADYCAEHUj8AAQciPwAA2AgBByI/AAEHAj8AANgIAQdyPwABB0I/AADYCAEHQj8AAQciPwAA2AgBB5I/AAEHYj8AANgIAQdiPwABB0I/AADYCAEH8j8AAIAI2AgBB4I/AAEHYj8AANgIAQfSPwAAgBEEoayIANgIAIAIgAEEBcjYCBCAAIAJqQSg2AgRBiJDAAEGAgIABNgIADAgLIAIgA00gASADS3INACAAKAIMRQ0DC0GMkMAAQYyQwAAoAgAiACACIAAgAkkbNgIAIAIgBGohAUHQjcAAIQACQAJAA0AgASAAKAIARwRAIAAoAggiAA0BDAILCyAAKAIMRQ0BC0HQjcAAIQADQAJAIAMgACgCACIBTwRAIAMgASAAKAIEaiIGSQ0BCyAAKAIIIQAMAQsLQfyPwAAgAjYCAEH0j8AAIARBKGsiADYCACACIABBAXI2AgQgACACakEoNgIEQYiQwABBgICAATYCACADIAZBIGtBeHFBCGsiACAAIANBEGpJGyIBQRs2AgRB0I3AACkCACEJIAFBEGpB2I3AACkCADcCACABIAk3AghB1I3AACAENgIAQdCNwAAgAjYCAEHYjcAAIAFBCGo2AgBB3I3AAEEANgIAIAFBHGohAANAIABBBzYCACAAQQRqIgAgBkkNAAsgASADRg0HIAEgASgCBEF+cTYCBCADIAEgA2siAEEBcjYCBCABIAA2AgAgAEGAAk8EQCADIAAQBwwICyAAQXhxQeCNwABqIQECf0Hoj8AAKAIAIgJBASAAQQN2dCIAcUUEQEHoj8AAIAAgAnI2AgAgAQwBCyABKAIICyEAIAEgAzYCCCAAIAM2AgwgAyABNgIMIAMgADYCCAwHCyAAIAI2AgAgACAAKAIEIARqNgIEIAIgBUEDcjYCBCABIAIgBWoiA2shBSABQfyPwAAoAgBGDQMgAUH4j8AAKAIARg0EIAEoAgQiBEEDcUEBRgRAIAEgBEF4cSIAEAYgACAFaiEFIAAgAWoiASgCBCEECyABIARBfnE2AgQgAyAFQQFyNgIEIAMgBWogBTYCACAFQYACTwRAIAMgBRAHDAYLIAVBeHFB4I3AAGohAAJ/QeiPwAAoAgAiAUEBIAVBA3Z0IgRxRQRAQeiPwAAgASAEcjYCACAADAELIAAoAggLIQUgACADNgIIIAUgAzYCDCADIAA2AgwgAyAFNgIIDAULQfSPwAAgACAFayIBNgIAQfyPwABB/I/AACgCACIAIAVqIgI2AgAgAiABQQFyNgIEIAAgBUEDcjYCBCAAQQhqIQQMBgtB+I/AACgCACEAAkAgASAFayICQQ9NBEBB+I/AAEEANgIAQfCPwABBADYCACAAIAFBA3I2AgQgACABaiIBIAEoAgRBAXI2AgQMAQtB8I/AACACNgIAQfiPwAAgACAFaiIDNgIAIAMgAkEBcjYCBCAAIAFqIAI2AgAgACAFQQNyNgIECwwICyAAIAQgBmo2AgRB/I/AAEH8j8AAKAIAIgBBD2pBeHEiAUEIayICNgIAQfSPwABB9I/AACgCACAEaiIDIAAgAWtqQQhqIgE2AgAgAiABQQFyNgIEIAAgA2pBKDYCBEGIkMAAQYCAgAE2AgAMAwtB/I/AACADNgIAQfSPwABB9I/AACgCACAFaiIANgIAIAMgAEEBcjYCBAwBC0H4j8AAIAM2AgBB8I/AAEHwj8AAKAIAIAVqIgA2AgAgAyAAQQFyNgIEIAAgA2ogADYCAAsgAkEIag8LQQAhBEH0j8AAKAIAIgAgBU0NAEH0j8AAIAAgBWsiATYCAEH8j8AAQfyPwAAoAgAiACAFaiICNgIAIAIgAUEBcjYCBCAAIAVBA3I2AgQMAwsgBA8LIAAgBzYCGCABKAIQIgIEQCAAIAI2AhAgAiAANgIYCyABKAIUIgJFDQAgACACNgIUIAIgADYCGAsCQCAEQRBPBEAgASAFQQNyNgIEIAEgBWoiAiAEQQFyNgIEIAIgBGogBDYCACAEQYACTwRAIAIgBBAHDAILIARBeHFB4I3AAGohAAJ/QeiPwAAoAgAiA0EBIARBA3Z0IgRxRQRAQeiPwAAgAyAEcjYCACAADAELIAAoAggLIQQgACACNgIIIAQgAjYCDCACIAA2AgwgAiAENgIIDAELIAEgBCAFaiIAQQNyNgIEIAAgAWoiACAAKAIEQQFyNgIECyABQQhqDwsgAEEIagueCgELfyAAKAIEIQggACgCACEGAkACQAJAIAEoAgAiAyABKAIIIgByBEACQCAARQ0AIAYgCGohBAJAIAEoAgwiCUUEQCAGIQIMAQsgBiECA0AgAiIAIARGDQICfyAAQQFqIAAsAAAiAkEATg0AGiAAQQJqIAJBYEkNABogAEEDaiACQXBJDQAaIABBBGoLIgIgAGsgBWohBSAJIAdBAWoiB0cNAAsLIAIgBEYNACACLAAAGgJAAkAgBUUNACAFIAhJBEBBACEAIAUgBmosAABBv39KDQEMAgtBACEAIAUgCEcNAQsgBiEACyAFIAggABshCCAAIAYgABshBgsgA0UNAyABKAIEIQsgCEEQTwRAIAggBiAGQQNqQXxxIgVrIgdqIgpBA3EhCUEAIQNBACEAIAUgBkcEQCAHQXxNBEBBACEEA0AgACAEIAZqIgIsAABBv39KaiACQQFqLAAAQb9/SmogAkECaiwAAEG/f0pqIAJBA2osAABBv39KaiEAIARBBGoiBA0ACwsgBiECA0AgACACLAAAQb9/SmohACACQQFqIQIgB0EBaiIHDQALCwJAIAlFDQAgBSAKQXxxaiICLAAAQb9/SiEDIAlBAUYNACADIAIsAAFBv39KaiEDIAlBAkYNACADIAIsAAJBv39KaiEDCyAKQQJ2IQQgACADaiEDA0AgBSEHIARFDQRBwAEgBCAEQcABTxsiCUEDcSEKIAlBAnQhBUEAIQIgBEEETwRAIAcgBUHwB3FqIQwgByEAA0AgAiAAKAIAIgJBf3NBB3YgAkEGdnJBgYKECHFqIAAoAgQiAkF/c0EHdiACQQZ2ckGBgoQIcWogACgCCCICQX9zQQd2IAJBBnZyQYGChAhxaiAAKAIMIgJBf3NBB3YgAkEGdnJBgYKECHFqIQIgAEEQaiIAIAxHDQALCyAEIAlrIQQgBSAHaiEFIAJBCHZB/4H8B3EgAkH/gfwHcWpBgYAEbEEQdiADaiEDIApFDQALIAcgCUH8AXFBAnRqIgIoAgAiAEF/c0EHdiAAQQZ2ckGBgoQIcSEAIApBAUYNAiAAIAIoAgQiAEF/c0EHdiAAQQZ2ckGBgoQIcWohACAKQQJGDQIgACACKAIIIgBBf3NBB3YgAEEGdnJBgYKECHFqIQAMAgsgCEUEQEEAIQMMAwsgCEEDcSECAkAgCEEESQRAQQAhA0EAIQcMAQtBACEDIAYhACAIQQxxIgchBQNAIAMgACwAAEG/f0pqIABBAWosAABBv39KaiAAQQJqLAAAQb9/SmogAEEDaiwAAEG/f0pqIQMgAEEEaiEAIAVBBGsiBQ0ACwsgAkUNAiAGIAdqIQADQCADIAAsAABBv39KaiEDIABBAWohACACQQFrIgINAAsMAgsMAgsgAEEIdkH/gRxxIABB/4H8B3FqQYGABGxBEHYgA2ohAwsCQCADIAtJBEAgCyADayEEQQAhAAJAAkACQCABLQAgQQFrDgIAAQILIAQhAEEAIQQMAQsgBEEBdiEAIARBAWpBAXYhBAsgAEEBaiEAIAEoAhAhByABKAIYIQIgASgCFCEBA0AgAEEBayIARQ0CIAEgByACKAIQEQMARQ0AC0EBDwsMAQtBASEAIAEgBiAIIAIoAgwRAAAEf0EBBUEAIQACfwNAIAQgACAERg0BGiAAQQFqIQAgASAHIAIoAhARAwBFDQALIABBAWsLIARJCw8LIAEoAhQgBiAIIAEoAhgoAgwRAAALnQYCDX8BfiMAQTBrIgckAEEnIQICQCAAQpDOAFQEQCAAIQ8MAQsDQCAHQQlqIAJqIgZBBGsgAEKQzgCAIg9C8LEDfiAAfKciBEH//wNxQeQAbiIDQQF0QYSHwABqLwAAOwAAIAZBAmsgA0Gcf2wgBGpB//8DcUEBdEGEh8AAai8AADsAACACQQRrIQIgAEL/wdcvViAPIQANAAsLIA+nIgRB4wBLBEAgAkECayICIAdBCWpqIA+nIgNB//8DcUHkAG4iBEGcf2wgA2pB//8DcUEBdEGEh8AAai8AADsAAAsCQCAEQQpPBEAgAkECayICIAdBCWpqIARBAXRBhIfAAGovAAA7AAAMAQsgAkEBayICIAdBCWpqIARBMHI6AAALQScgAmshCEEBIQVBK0GAgMQAIAEoAhwiBEEBcSIMGyEJIARBBHFBAnYhCiAHQQlqIAJqIQsCQCABKAIARQRAIAEoAhQiAyABKAIYIgEgCSAKEFwNASADIAsgCCABKAIMEQAAIQUMAQsgASgCBCINIAggDGoiA00EQCABKAIUIgMgASgCGCIBIAkgChBcDQEgAyALIAggASgCDBEAACEFDAELIARBCHEEQCABKAIQIQQgAUEwNgIQIAEtACAhAyABQQE6ACAgASgCFCIOIAEoAhgiBiAJIAoQXA0BIAIgDWogDGtBJmshAgNAIAJBAWsiAgRAIA5BMCAGKAIQEQMARQ0BDAMLCyAOIAsgCCAGKAIMEQAADQEgASADOgAgIAEgBDYCEEEAIQUMAQsgDSADayEDAkACQAJAIAEtACAiAkEBaw4DAAEAAgsgAyECQQAhAwwBCyADQQF2IQIgA0EBakEBdiEDCyACQQFqIQIgASgCECEEIAEoAhghBiABKAIUIQECQANAIAJBAWsiAkUNASABIAQgBigCEBEDAEUNAAsMAQsgASAGIAkgChBcDQAgASALIAggBigCDBEAAA0AQQAhAgNAIAIgA0YEQEEAIQUMAgsgAkEBaiECIAEgBCAGKAIQEQMARQ0ACyACQQFrIANJIQULIAdBMGokACAFC6gGAQF/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEGABGsOJgECAwQFBgcIOwkKCwwNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Dg87OzsQAAtBASEBAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQQFrDg5SAQIDBAUGUQcICQoLDAALAkAgAEHABGsODCcoKSorLC0uLzAxMgALAkAgAEGBAmsOCg0ODxAREhMUFRYACwJAIABBgAZrDgkzNDU2N1FRODkACwJAIABBgAprDgY8PT4/QEEACwJAIABBgAxrDgZCQ0RFRkcACwJAIABBgBJrDgZKS0xNTk8ACwJAIABBgAhrDgI6OwALIABBgA5rDgJHSE8LQQIPC0EDDwtBBA8LQQUPC0EGDwtBBw8LQQkPC0EKDwtBCw8LQQwPC0ENDwtBDg8LQYECDwtBggIPC0GDAg8LQYQCDwtBhQIPC0GGAg8LQYcCDwtBiAIPC0GJAg8LQYoCDwtBgAQPC0GBBA8LQYIEDwtBgwQPC0GEBA8LQYUEDwtBhgQPC0GHBA8LQYkEDwtBigQPC0GLBA8LQYwEDwtBjQQPC0GgBA8LQaEEDwtBpQQPC0HABA8LQcEEDwtBwgQPC0HDBA8LQcQEDwtBxQQPC0HGBA8LQccEDwtByAQPC0HJBA8LQcoEDwtBywQPC0GABg8LQYEGDwtBggYPC0GDBg8LQYQGDwtBhwYPC0GIBg8LQYAIDwtBgQgPC0GACg8LQYEKDwtBggoPC0GDCg8LQYQKDwtBhQoPC0GADA8LQYEMDwtBggwPC0GDDA8LQYQMDwtBhQwPC0GADg8LQYEODwtBgBIPC0GBEg8LQYISDwtBgxIPC0GEEg8LQYUSIQEMAgtBgBAhASAAQYAQRg0BC0HggsAAQRkQ4QEACyABC/gDAQJ/IAAgAWohAgJAAkAgACgCBCIDQQFxDQAgA0ECcUUNASAAKAIAIgMgAWohASAAIANrIgBB+I/AACgCAEYEQCACKAIEQQNxQQNHDQFB8I/AACABNgIAIAIgAigCBEF+cTYCBCAAIAFBAXI2AgQgAiABNgIADAILIAAgAxAGCwJAAkACQCACKAIEIgNBAnFFBEAgAkH8j8AAKAIARg0CIAJB+I/AACgCAEYNAyACIANBeHEiAhAGIAAgASACaiIBQQFyNgIEIAAgAWogATYCACAAQfiPwAAoAgBHDQFB8I/AACABNgIADwsgAiADQX5xNgIEIAAgAUEBcjYCBCAAIAFqIAE2AgALIAFBgAJPBEAgACABEAcPCyABQXhxQeCNwABqIQICf0Hoj8AAKAIAIgNBASABQQN2dCIBcUUEQEHoj8AAIAEgA3I2AgAgAgwBCyACKAIICyEBIAIgADYCCCABIAA2AgwgACACNgIMIAAgATYCCA8LQfyPwAAgADYCAEH0j8AAQfSPwAAoAgAgAWoiATYCACAAIAFBAXI2AgQgAEH4j8AAKAIARw0BQfCPwABBADYCAEH4j8AAQQA2AgAPC0H4j8AAIAA2AgBB8I/AAEHwj8AAKAIAIAFqIgE2AgAgACABQQFyNgIEIAAgAWogATYCAAsL8QIBBH8gACgCDCECAkACQCABQYACTwRAIAAoAhghAwJAAkAgACACRgRAIABBFEEQIAAoAhQiAhtqKAIAIgENAUEAIQIMAgsgACgCCCIBIAI2AgwgAiABNgIIDAELIABBFGogAEEQaiACGyEEA0AgBCEFIAEiAkEUaiACQRBqIAIoAhQiARshBCACQRRBECABG2ooAgAiAQ0ACyAFQQA2AgALIANFDQIgACAAKAIcQQJ0QdCMwABqIgEoAgBHBEAgA0EQQRQgAygCECAARhtqIAI2AgAgAkUNAwwCCyABIAI2AgAgAg0BQeyPwABB7I/AACgCAEF+IAAoAhx3cTYCAAwCCyAAKAIIIgAgAkcEQCAAIAI2AgwgAiAANgIIDwtB6I/AAEHoj8AAKAIAQX4gAUEDdndxNgIADwsgAiADNgIYIAAoAhAiAQRAIAIgATYCECABIAI2AhgLIAAoAhQiAEUNACACIAA2AhQgACACNgIYCwu6AgEEf0EfIQIgAEIANwIQIAFB////B00EQCABQQYgAUEIdmciA2t2QQFxIANBAXRrQT5qIQILIAAgAjYCHCACQQJ0QdCMwABqIQRBASACdCIDQeyPwAAoAgBxRQRAIAQgADYCACAAIAQ2AhggACAANgIMIAAgADYCCEHsj8AAQeyPwAAoAgAgA3I2AgAPCwJAAkAgASAEKAIAIgMoAgRBeHFGBEAgAyECDAELIAFBGSACQQF2a0EAIAJBH0cbdCEFA0AgAyAFQR12QQRxakEQaiIEKAIAIgJFDQIgBUEBdCEFIAIhAyACKAIEQXhxIAFHDQALCyACKAIIIgEgADYCDCACIAA2AgggAEEANgIYIAAgAjYCDCAAIAE2AggPCyAEIAA2AgAgACADNgIYIAAgADYCDCAAIAA2AggLlAEBBH8gARDXASABQQhrIgMgAygCAEEBaiICNgIAAkACQCACBEAgASgCACICQX9GDQEgASACQQFqNgIAIAEoAgQoAAAiBMBBAnRBuIPAAGooAgAhBUEBQQQQ2QEiAg0CCwALEN0BAAsgAiAFIARBgH5xcjYAACABIAEoAgBBAWs2AgAgAxBeIABBBDYCBCAAIAI2AgALiwEBAn8gABDXASAAQQhrIgIoAgAhAwJAAkAgAUUEQCADQQFGBEAgAkEANgIAIAJBf0YNAyAAQQRrIgAgACgCAEEBayIANgIAIABFDQIMAwtB+YLAAEE/EOEBAAsgAiADQQFrIgE2AgAgAQ0BIABBBGsiACAAKAIAQQFrIgA2AgAgAA0BCyACQRAQIwsLhAEBA38jAEEQayIBJAAgAUEEaiAAECAgASgCBCIAQQJqLQAAIQIgAC8AACEDIAEoAgggASgCDBDSAUEEQRAQ2QEiAEUEQAALIABBADYCCCAAQoGAgIAQNwIAIAAgAyACQRB0chDmASICQQh2QYAecSACQRh2cjsBDCABQRBqJAAgAEEIagt1AgF/AX4gARDXASABQQhrIgIoAgBBAUYEQCABNQIEIQMgAkEANgIAAkAgAkF/Rg0AIAFBBGsiASABKAIAQQFrIgE2AgAgAQ0AIAJBEBAjCyAAIANCAYM8AAAgACADp0EIdkEBcToAAQ8LQfmCwABBPxDhAQALbAECfyAAENcBIABBCGsiASABKAIAQQFqIgI2AgACQCACBEAgACgCAEF/Rg0BIAAvAAQgAEEGai0AAEEQdHIQ5gEhACABEGMgAEEIdkGA/gNxIABBGHZyIABBgP4DcUEIdHIQZg8LAAsQ3QEAC28BAn8gARDXASABQQhrIgIoAgBBAUYEQCABKAIEIQMgAkEANgIAAkAgAkF/Rg0AIAFBBGsiASABKAIAQQFrIgE2AgAgAQ0AIAJBEBAjCyAAIANBCHY6AAEgACADQQFxOgAADwtB+YLAAEE/EOEBAAtrAQF/IAAQ1wEgAEEIayECAkAgAUUEQCACKAIAQQFHDQEgACgCBCACQQA2AgACQCACQX9GDQAgAEEEayIAIAAoAgBBAWsiADYCACAADQAgAkEQECMLEOUBDwsgAhBeDwtB+YLAAEE/EOEBAAthAQF/IwBBEGsiASQAIAFBBGogABAgIAEoAgQiAC8AACAAQQJqLQAAQRB0chDmASEAIAEoAgggASgCDBDSASAAQQh2QYD+A3EgAEEYdnIgAEGABnFBCHRyEGYgAUEQaiQAC2cBAX8gABAfIQIgARAiIQFBBEEQENkBIgBFBEAACyAAQoGAgIAQNwIAIAAgAUEQdEGAgPwHcSACQf8BcUESdCABciIBQYD+A3FBCHQgAUEIdkGA/gNxckEIdnKtQiCGNwIIIABBCGoLewEBfyMAQRBrIgMkAEHMjMAAQcyMwAAoAgAiBEEBajYCAAJAIARBAEgNAAJAQZiQwAAtAABFBEBBlJDAAEGUkMAAKAIAQQFqNgIAQciMwAAoAgBBAE4NAQwCCyADQQhqIAAgAREEAAALQZiQwABBADoAACACRQ0AAAsAC2oBAX8jAEEwayIBJAAgASAAOgAPIABB/wFxQcAATwRAIAFBAjYCFCABQfSAwAA2AhAgAUIBNwIcIAFBAjYCLCABIAFBKGo2AhggASABQQ9qNgIoIAFBEGpBhIHAABA/AAsgAUEwaiQAIAALawEBfyMAQTBrIgEkACABIAA7AQ4gAEH//wNxQYAgTwRAIAFBAjYCFCABQbiBwAA2AhAgAUIBNwIcIAFBAzYCLCABIAFBKGo2AhggASABQQ5qNgIoIAFBEGpByIHAABA/AAsgAUEwaiQAIAALYwECfyMAQRBrIgIkAAJAIAFFBEAgAkEIaiAAEA0MAQsgABDXASAAQQhrIgEgASgCAEEBayIDNgIAIAMNACAAQQRrIgAgACgCAEEBayIANgIAIAANACABQRAQIwsgAkEQaiQAC1sBAn8CQAJAIAAQHyICQRhxDQAgAkEHcSIAQQdGDQBBBEEQENkBIgFFDQEgAUKBgICAEDcCACABIAJBBXZBAXGtQiCGIACtQiiGhDcCCCABQQhqIQELIAEPCwALYwECfyMAQRBrIgIkAAJAIAFFBEAgAkEIaiAAEAsMAQsgABDXASAAQQhrIgEgASgCAEEBayIDNgIAIAMNACAAQQRrIgAgACgCAEEBayIANgIAIAANACABQRAQIwsgAkEQaiQAC14BAX8jAEEQayIBJAAgAUEEaiAAECAgASgCBCIALwAAIABBAmotAABBEHRyEOYBIQAgASgCCCABKAIMENIBIABBCHZBgOADcSAAQYAGcUEIdHJBDHYQZyABQRBqJAALFQAgAEGMgsAAQfyBwABBgIAQEIECCxYAIABB0ILAAEHAgsAAQYCAgAgQgQILXgEBfyAAEB8hAiABEB8hAUEEQRAQ2QEiAEUEQAALIABCgYCAgBA3AgAgACABQf8BcUEMdCACQRJ0ciIBQYDgA3FBCHQgAUEIdkGA/gNxckEIdq1CIIY3AgggAEEIagtcAQJ/IAAQ1wEgAEEIayIBKAIAQQFGBEAgAC0ABCABQQA2AgACQCABQX9GDQAgAEEEayIAIAAoAgBBAWsiADYCACAADQAgAUEQECMLQQFxDwtB+YLAAEE/EOEBAAtgAQF/IAAQ1wEgAEEIayECAkAgAUUEQCACKAIAQQFGBEAgAkEANgIAIAJBf0YNAiAAQQRrIgAgACgCAEEBayIANgIAIAANAiACQRQQIw8LQfmCwABBPxDhAQALIAIQZAsLYAEBfyAAENcBIABBCGshAgJAIAFFBEAgAigCAEEBRgRAIAJBADYCACACQX9GDQIgAEEEayIAIAAoAgBBAWsiADYCACAADQIgAkEQECMPC0H5gsAAQT8Q4QEACyACEGMLC1UBAX8jAEEQayIBJAAgAUEEaiAAECAgASgCBCIALwAAIABBAmotAABBEHRyEOYBIQAgASgCCCABKAIMENIBIABBDnZBPHEgAEEednIQZyABQRBqJAALWQECfyAAENcBIABBCGsiASgCAEEBRgRAIAAtAAQgAUEANgIAAkAgAUF/Rg0AIABBBGsiACAAKAIAQQFrIgA2AgAgAA0AIAFBEBAjCw8LQfmCwABBPxDhAQALWQECfyABENcBIAFBCGsiAyADKAIAQQFqIgI2AgACQCACBEAgASgCACICQX9GDQEgACADNgIIIAAgATYCBCAAIAFBBGo2AgAgASACQQFqNgIADwsACxDdAQALWQECfyAAENcBIABBCGsiASgCAEEBRgRAIAAvAQQgAUEANgIAAkAgAUF/Rg0AIABBBGsiACAAKAIAQQFrIgA2AgAgAA0AIAFBEBAjCw8LQfmCwABBPxDhAQALWQECfyAAENcBIABBCGsiASgCAEEBRgRAIAAoAgQgAUEANgIAAkAgAUF/Rg0AIABBBGsiACAAKAIAQQFrIgA2AgAgAA0AIAFBEBAjCw8LQfmCwABBPxDhAQALzQYBBH8CQCAAQQRrKAIAIgQiAkF4cSIDQQRBCCACQQNxIgIbIAFqTwRAIAJBACADIAFBJ2pLGw0BIABBCGsiASAEIgNBeHEiAGohAgJAAkAgA0EBcQ0AIANBAnFFDQEgASgCACIDIABqIQAgASADayIBQfiPwAAoAgBGBEAgAigCBEEDcUEDRw0BQfCPwAAgADYCACACIAIoAgRBfnE2AgQgASAAQQFyNgIEIAIgADYCAAwCCyABIAMQBgsCQAJAAkACQAJAIAIoAgQiA0ECcUUEQCACQfyPwAAoAgBGDQIgAkH4j8AAKAIARg0DIAIgA0F4cSICEAYgASAAIAJqIgBBAXI2AgQgACABaiAANgIAIAFB+I/AACgCAEcNAUHwj8AAIAA2AgAMBgsgAiADQX5xNgIEIAEgAEEBcjYCBCAAIAFqIAA2AgALIABBgAJJDQIgASAAEAdBACEBQZCQwABBkJDAACgCAEEBayIANgIAIAANBEHYjcAAKAIAIgAEQANAIAFBAWohASAAKAIIIgANAAsLQZCQwABB/x8gASABQf8fTRs2AgAMBAtB/I/AACABNgIAQfSPwABB9I/AACgCACAAaiIANgIAIAEgAEEBcjYCBEH4j8AAKAIAIAFGBEBB8I/AAEEANgIAQfiPwABBADYCAAsgAEGIkMAAKAIAIgNNDQNB/I/AACgCACICRQ0DQQAhAEH0j8AAKAIAIgRBKUkNAkHQjcAAIQEDQCACIAEoAgAiBU8EQCACIAUgASgCBGpJDQQLIAEoAgghAQwACwALQfiPwAAgATYCAEHwj8AAQfCPwAAoAgAgAGoiADYCACABIABBAXI2AgQgACABaiAANgIADAILIABBeHFB4I3AAGohAgJ/QeiPwAAoAgAiA0EBIABBA3Z0IgBxRQRAQeiPwAAgACADcjYCACACDAELIAIoAggLIQAgAiABNgIIIAAgATYCDCABIAI2AgwgASAANgIIDAELQdiNwAAoAgAiAQRAA0AgAEEBaiEAIAEoAggiAQ0ACwtBkJDAAEH/HyAAIABB/x9NGzYCACADIARPDQBBiJDAAEF/NgIACw8LQfWIwABBpInAABBSAAtBtInAAEHkicAAEFIAC0wAIANB/wFxIAFB/wFxQQx0IABB/wFxQRJ0ciIAIAJB/wFxQQZ0cnIiAUEQdEGAgPwHcSAAQQh2QYD+A3EgAUGA/gNxQQh0ckEIdnILTwECfyAAENcBIABBCGsiASABKAIAQQFqIgI2AgACQCACBEAgACgCAEF/Rg0BIAAvAAQgAEEGai0AAEEQdHIQ2gEgARBjEGcPCwALEN0BAAtVAQF/IAAQIiEAQQRBEBDZASIBRQRAAAsgAUKBgICAEDcCACABIABBEHRBgID8B3EgAEEIdkGA/gNxIABBgP4DcUEIdHJBCHZyrUIghjcCCCABQQhqC04BAX8gAUUEQCAAEBsaDwsgABDXASAAQQhrIgEgASgCAEEBayICNgIAAkAgAg0AIABBBGsiACAAKAIAQQFrIgA2AgAgAA0AIAFBEBAjCwsQACAAIAEgAiADQd4AEIICCxAAIAAgASACIANB3wAQggILEAAgACABIAIgA0HgABCCAgsQACAAIAEgAiADQeEAEIICCxAAIAAgASACIANB4gAQgwILEAAgACABIAIgA0HjABCDAgtOAQF/IAFFBEAgABAfGg8LIAAQ1wEgAEEIayIBIAEoAgBBAWsiAjYCAAJAIAINACAAQQRrIgAgACgCAEEBayIANgIAIAANACABQRAQIwsLTgEBfyABRQRAIAAQIRoPCyAAENcBIABBCGsiASABKAIAQQFrIgI2AgACQCACDQAgAEEEayIAIAAoAgBBAWsiADYCACAADQAgAUEQECMLC04BAX8gAUUEQCAAECIaDwsgABDXASAAQQhrIgEgASgCAEEBayICNgIAAkAgAg0AIABBBGsiACAAKAIAQQFrIgA2AgAgAA0AIAFBEBAjCwsPACAAIAFBgICAyAEQhAILDAAgACABQcsAEIUCCwwAIAAgAUHMABCFAgsMACAAIAFBzQAQhQILDAAgACABQc4AEIUCCwwAIAAgAUHPABCFAgsMACAAIAFB0AAQhQILDwAgACABQYCAgOgGEIQCC1MBAX8gABAfIQQgARAfIQEgAhAfIQIgAxAfIQNBBEEQENkBIgBFBEAACyAAQoGAgIAQNwIAIAAgBCABIAIgAxAkrUL///8Hg0IghjcCCCAAQQhqC0UBAX8jAEEQayIBJAAgAUEEaiAAECAgASgCBCIALwAAIABBAmotAABBEHRyENoBIAEoAgggASgCDBDSARBnIAFBEGokAAtLAQF/IwBBEGsiASQAIAFBBGogABAgIAEoAgQi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AUKBgICAEDcCACABIACtQv///weDQiCGNwIIIAFBCGoLMAEBf0EEQRAQ2QEiAUUEQAALIAEgADYCDCABQQA2AgggAUKBgICAEDcCACABQQhqCzABAX9BBEEQENkBIgFFBEAACyABIAA6AAwgAUEANgIIIAFCgYCAgBA3AgAgAUEIagsoACABKAIARQRAIAFBfzYCACAAIAE2AgQgACABQQRqNgIADwsQ3QEACyQAIAAQ1wEgACgCAARAEN0BAAsgAEEANgIAIAAgAUEARzoABAsoACADEBshAyAAEM0BIAEQzQEgAhDNASADENUBQQh0QeQAchDKARBmCygAIAMQGyEDIAAQzQEgARDNASACEM0BIAMQ1QFBCHRB5QByEMoBEGYLIAAgAEEBayIAQQZNBEAgAEEBag8LQeCCwABBGRDhAQALKQEBf0EEQRAQ2QEiAEUEQAALIABCADcCCCAAQoGAgIAQNwIAIABBCGoLIgAgAhAEIQIgABDNASABEM0BIAIQT0EIdEHKAHIQygEQZgsPACAAIAEgAiADQRIQ/AELDwAgACABIAIgA0EYEPwBCw8AIAAgASACIANBHBD8AQsPACAAIAEgAiADQR0Q/AELDwAgACABIAIgA0EhEP0BCw8AIAAgASACIANBIhD8AQsPACAAIAEgAiADQSMQ/AELDwAgACABIAIgA0EoEPwBCw8AIAAgASACIANBKhD8AQsPACAAIAEgAiADQSwQ/AELDwAgACABIAIgA0EvEPwBCw8AIAAgASACIANBOBD8AQsQACAAIAEgAiADQdMAEP0BCxAAIAAgASACIANB1AAQ/QELEAAgACABIAIgA0HeABD9AQsQACAAIAEgAiADQd8AEP0BCxAAIAAgASACIANB4AAQ/QELEAAgACABIAIgA0HhABD9AQsQACAAIAEgAiADQeIAEP0BCxAAIAAgASACIANB4wAQ/QELEAAgACABIAIgA0HkABD9AQsQACAAIAEgAiADQeUAEP0BCxAAIAAgASACIANB5gAQ/AELEAAgACABIAIgA0HnABD8AQsQACAAIAEgAiADQegAEPwBCxAAIAAgASACIANB6QAQ/AELEAAgACABIAIgA0HqABD8AQsQACAAIAEgAiADQesAEPwBCxAAIAAgASACIANB7AAQ/AELEAAgACABIAIgA0HuABD8AQsQACAAIAEgAiADQe8AEPwBCxAAIAAgASACIANB8AAQ/AELHgAgARBsIQEgABDNASABEMsBQQh0QcwAchDKARBmCxkAIAAgASACQSBBACAEG0EQQQAgAxtyECQLDQAgACABIAJBARD+AQsNACAAIAEgAkECEP4BCw0AIAAgASACQQMQ/gELDQAgACABIAJBBBD+AQsNACAAIAEgAkEFEP4BCw0AIAAgASACQQYQ/gELDQAgACABIAJBBxD+AQsNACAAIAEgAkEIEP4BCw0AIAAgASACQQkQ/gELDQAgACABIAJBCxD+AQsNACAAIAEgAkENEP4BCw0AIAAgASACQQ4Q/gELDQAgACABIAJBDxD+AQsNACAAIAEgAkEQEP4BCw0AIAAgASACQREQ/gELDQAgACABIAJBFxD+AQsNACAAIAEgAkEmEP4BCw0AIAAgASACQScQ/gELDQAgACABIAJBKRD+AQsNACAAIAEgAkErEP4BCw0AIAAgASACQS0Q/gELDQAgACABIAJBLhD+AQsNACAAIAEgAkEwEP4BCw0AIAAgASACQTEQ/gELDQAgACABIAJBNRD+AQsNACAAIAEgAkE3EP4BCw0AIAAgASACQTkQ/wELDQAgACABIAJBOhD/AQsNACAAIAEgAkE7EP8BCw0AIAAgASACQTwQ/wELDQAgACABIAJBPRD/AQsNACAAIAEgAkE+EP8BCw0AIAAgASACQT8Q/wELDgAgACABIAJBwAAQ/wELDgAgACABIAJBwQAQ/wELDgAgACABIAJBwgAQ/wELDgAgACABIAJBwwAQ/wELDgAgACABIAJBxAAQ/wELDgAgACABIAJBxQAQ/wELDgAgACABIAJBxgAQ/wELDgAgACABIAJBxwAQ/wELDgAgACABIAJByAAQ/wELDgAgACABIAJByQAQ/wELDgAgACABIAJBygAQ/wELDgAgACABIAJB0QAQ/wELDgAgACABIAJB0gAQ/wELFwEBfyAAQf8BcUE/TQR/IAAQZwVBAAsLGwAgABDXASAAKAIAQX9GBEAQ3QEACyAALQAECwkAIABBExCAAgsJACAAQRUQgAILCQAgAEEaEIACCwkAIABBIBCAAgsJACAAQSUQgAILCQAgAEE0EIACCwkAIABBNhCAAgsKACAAQdgAEIACCwoAIABB2QAQgAILGwEBf0EBQQQQ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', imports)}

async function initWasm () {
  return await __wbg_init({ module_or_path: wasm() });
}

/**
 * calling it right away for pre-caching
 * the wasm async initialization at startup
 */
initWasm();

exports.ADD = ADD;
exports.ADDI = ADDI;
exports.ALOC = ALOC;
exports.AND = AND;
exports.ANDI = ANDI;
exports.BAL = BAL;
exports.BHEI = BHEI;
exports.BHSH = BHSH;
exports.BLDD = BLDD;
exports.BSIZ = BSIZ;
exports.BURN = BURN;
exports.CALL = CALL;
exports.CB = CB;
exports.CCP = CCP;
exports.CFE = CFE;
exports.CFEI = CFEI;
exports.CFS = CFS;
exports.CFSI = CFSI;
exports.CROO = CROO;
exports.CSIZ = CSIZ;
exports.CompareArgs = CompareArgs;
exports.CompareMode = CompareMode;
exports.DIV = DIV;
exports.DIVI = DIVI;
exports.DivArgs = DivArgs;
exports.ECAL = ECAL;
exports.ECK1 = ECK1;
exports.ECOP = ECOP;
exports.ECR1 = ECR1;
exports.ED19 = ED19;
exports.EPAR = EPAR;
exports.EQ = EQ;
exports.EXP = EXP;
exports.EXPI = EXPI;
exports.FLAG = FLAG;
exports.GM = GM;
exports.GMArgs = GMArgs;
exports.GT = GT;
exports.GTF = GTF;
exports.GTFArgs = GTFArgs;
exports.Imm06 = Imm06;
exports.Imm12 = Imm12;
exports.Imm18 = Imm18;
exports.Imm24 = Imm24;
exports.Instruction = Instruction;
exports.JI = JI;
exports.JMP = JMP;
exports.JMPB = JMPB;
exports.JMPF = JMPF;
exports.JNE = JNE;
exports.JNEB = JNEB;
exports.JNEF = JNEF;
exports.JNEI = JNEI;
exports.JNZB = JNZB;
exports.JNZF = JNZF;
exports.JNZI = JNZI;
exports.K256 = K256;
exports.LB = LB;
exports.LDC = LDC;
exports.LOG = LOG;
exports.LOGD = LOGD;
exports.LT = LT;
exports.LW = LW;
exports.MCL = MCL;
exports.MCLI = MCLI;
exports.MCP = MCP;
exports.MCPI = MCPI;
exports.MEQ = MEQ;
exports.MINT = MINT;
exports.MLDV = MLDV;
exports.MLOG = MLOG;
exports.MOD = MOD;
exports.MODI = MODI;
exports.MOVE = MOVE;
exports.MOVI = MOVI;
exports.MROO = MROO;
exports.MUL = MUL;
exports.MULI = MULI;
exports.MathArgs = MathArgs;
exports.MathOp = MathOp;
exports.MulArgs = MulArgs;
exports.NOOP = NOOP;
exports.NOT = NOT;
exports.OR = OR;
exports.ORI = ORI;
exports.POPH = POPH;
exports.POPL = POPL;
exports.PSHH = PSHH;
exports.PSHL = PSHL;
exports.PanicInstruction = PanicInstruction;
exports.PanicReason = PanicReason;
exports.RET = RET;
exports.RETD = RETD;
exports.RVRT = RVRT;
exports.RegId = RegId;
exports.S256 = S256;
exports.SB = SB;
exports.SCWQ = SCWQ;
exports.SLL = SLL;
exports.SLLI = SLLI;
exports.SMO = SMO;
exports.SRL = SRL;
exports.SRLI = SRLI;
exports.SRW = SRW;
exports.SRWQ = SRWQ;
exports.SUB = SUB;
exports.SUBI = SUBI;
exports.SW = SW;
exports.SWW = SWW;
exports.SWWQ = SWWQ;
exports.TIME = TIME;
exports.TR = TR;
exports.TRO = TRO;
exports.WDAM = WDAM;
exports.WDCM = WDCM;
exports.WDDV = WDDV;
exports.WDMD = WDMD;
exports.WDML = WDML;
exports.WDMM = WDMM;
exports.WDOP = WDOP;
exports.WQAM = WQAM;
exports.WQCM = WQCM;
exports.WQDV = WQDV;
exports.WQMD = WQMD;
exports.WQML = WQML;
exports.WQMM = WQMM;
exports.WQOP = WQOP;
exports.XOR = XOR;
exports.XORI = XORI;
exports.add = add;
exports.addi = addi;
exports.aloc = aloc;
exports.and = and;
exports.andi = andi;
exports.bal = bal;
exports.bhei = bhei;
exports.bhsh = bhsh;
exports.bldd = bldd;
exports.bsiz = bsiz;
exports.burn = burn;
exports.call = call;
exports.cb = cb;
exports.ccp = ccp;
exports.cfe = cfe;
exports.cfei = cfei;
exports.cfs = cfs;
exports.cfsi = cfsi;
exports.croo = croo;
exports.csiz = csiz;
exports.div = div;
exports.divi = divi;
exports.ecal = ecal;
exports.eck1 = eck1;
exports.ecop = ecop;
exports.ecr1 = ecr1;
exports.ed19 = ed19;
exports.epar = epar;
exports.eq = eq;
exports.exp = exp;
exports.expi = expi;
exports.flag = flag;
exports.gm = gm;
exports.gm_args = gm_args;
exports.gt = gt;
exports.gtf = gtf;
exports.gtf_args = gtf_args;
exports.initSync = initSync;
exports.initWasm = initWasm;
exports.ji = ji;
exports.jmp = jmp;
exports.jmpb = jmpb;
exports.jmpf = jmpf;
exports.jne = jne;
exports.jneb = jneb;
exports.jnef = jnef;
exports.jnei = jnei;
exports.jnzb = jnzb;
exports.jnzf = jnzf;
exports.jnzi = jnzi;
exports.k256 = k256;
exports.lb = lb;
exports.ldc = ldc;
exports.log = log;
exports.logd = logd;
exports.lt = lt;
exports.lw = lw;
exports.mcl = mcl;
exports.mcli = mcli;
exports.mcp = mcp;
exports.mcpi = mcpi;
exports.meq = meq;
exports.mint = mint;
exports.mldv = mldv;
exports.mlog = mlog;
exports.mod_ = mod_;
exports.modi = modi;
exports.move_ = move_;
exports.movi = movi;
exports.mroo = mroo;
exports.mul = mul;
exports.muli = muli;
exports.noop = noop;
exports.not = not;
exports.or = or;
exports.ori = ori;
exports.poph = poph;
exports.popl = popl;
exports.pshh = pshh;
exports.pshl = pshl;
exports.ret = ret;
exports.retd = retd;
exports.rvrt = rvrt;
exports.s256 = s256;
exports.sb = sb;
exports.scwq = scwq;
exports.sll = sll;
exports.slli = slli;
exports.smo = smo;
exports.srl = srl;
exports.srli = srli;
exports.srw = srw;
exports.srwq = srwq;
exports.sub = sub;
exports.subi = subi;
exports.sw = sw;
exports.sww = sww;
exports.swwq = swwq;
exports.time = time;
exports.tr = tr;
exports.tro = tro;
exports.wdam = wdam;
exports.wdcm = wdcm;
exports.wdcm_args = wdcm_args;
exports.wddv = wddv;
exports.wddv_args = wddv_args;
exports.wdmd = wdmd;
exports.wdml = wdml;
exports.wdml_args = wdml_args;
exports.wdmm = wdmm;
exports.wdop = wdop;
exports.wdop_args = wdop_args;
exports.wqam = wqam;
exports.wqcm = wqcm;
exports.wqcm_args = wqcm_args;
exports.wqdv = wqdv;
exports.wqdv_args = wqdv_args;
exports.wqmd = wqmd;
exports.wqml = wqml;
exports.wqml_args = wqml_args;
exports.wqmm = wqmm;
exports.wqop = wqop;
exports.wqop_args = wqop_args;
exports.xor = xor;
exports.xori = xori;
