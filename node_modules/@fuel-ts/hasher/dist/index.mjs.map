{"version":3,"sources":["../src/hasher.ts"],"sourcesContent":["import type { BytesLike } from '@fuel-ts/utils';\nimport { arrayify, concat, hexlify, toUtf8Bytes } from '@fuel-ts/utils';\nimport { sha256 as sha256AsBytes } from '@noble/hashes/sha256';\n\n/**\n * The prefix for the message to be hashed\n */\nconst MESSAGE_PREFIX = '\\x19Fuel Signed Message:\\n';\n\n/**\n * - When a string is provided, we hash as a UTF-8 string using SHA-256.\n *\n * - When an object with `personalSign` property is provided, we hash using SHA-256 of the following format:\n * ```console\n * 0x19 <0x46 (F)> <uel Signed Message:\\n\" + len(message)> <message>\n * ```\n *\n * Following a similar approach to that of [EIP-191](https://eips.ethereum.org/EIPS/eip-191).\n */\nexport type HashableMessage = string | { personalSign: BytesLike };\n\n/**\n * @param data - The data to be hashed\n * @returns A sha256 hash of the data in hex format\n */\nexport function sha256(data: BytesLike): string {\n  return hexlify(sha256AsBytes(arrayify(data)));\n}\n\n/**\n * wrap sha256\n *\n * @param data - The data to be hash\n * @returns A sha256 hash of the data\n */\nexport function hash(data: BytesLike): string {\n  return sha256(data);\n}\n\n/**\n * Convert a uint64 number to a big-endian byte array\n */\nexport function uint64ToBytesBE(value: number): Uint8Array {\n  const bigIntValue = BigInt(value);\n  const buffer = new ArrayBuffer(8);\n  const dataView = new DataView(buffer);\n  dataView.setBigUint64(0, bigIntValue, false); // write the uint64 value in big-endian order\n  return new Uint8Array(dataView.buffer);\n}\n\n/**\n * Hashes a message using SHA256.\n *\n * - When a `message` string is provided, we hash as a UTF-8 string using SHA-256.\n *\n * - When a `message` object with `personalSign` property is provided, we hash using SHA-256 of the following format:\n * ```console\n * 0x19 <0x46 (F)> <uel Signed Message:\\n\" + len(message)> <message>\n * ```\n *\n * Following a similar approach to that of [EIP-191](https://eips.ethereum.org/EIPS/eip-191).\n *\n * @param message - The message to be hashed @see {@link HashableMessage}\n * @returns A sha256 hash of the message\n */\nexport function hashMessage(message: HashableMessage) {\n  if (typeof message === 'string') {\n    return sha256(toUtf8Bytes(message));\n  }\n\n  const { personalSign } = message;\n  const messageBytes: Uint8Array =\n    typeof personalSign === 'string' ? toUtf8Bytes(personalSign) : personalSign;\n  const payload = concat([\n    toUtf8Bytes(MESSAGE_PREFIX),\n    toUtf8Bytes(String(messageBytes.length)),\n    messageBytes,\n  ]);\n  return hexlify(sha256(payload));\n}\n"],"mappings":";;;;AACA,SAAS,UAAU,QAAQ,SAAS,mBAAmB;AACvD,SAAS,UAAU,qBAAqB;AAKxC,IAAM,iBAAiB;AAkBhB,SAAS,OAAO,MAAyB;AAC9C,SAAO,QAAQ,cAAc,SAAS,IAAI,CAAC,CAAC;AAC9C;AAFgB;AAUT,SAAS,KAAK,MAAyB;AAC5C,SAAO,OAAO,IAAI;AACpB;AAFgB;AAOT,SAAS,gBAAgB,OAA2B;AACzD,QAAM,cAAc,OAAO,KAAK;AAChC,QAAM,SAAS,IAAI,YAAY,CAAC;AAChC,QAAM,WAAW,IAAI,SAAS,MAAM;AACpC,WAAS,aAAa,GAAG,aAAa,KAAK;AAC3C,SAAO,IAAI,WAAW,SAAS,MAAM;AACvC;AANgB;AAuBT,SAAS,YAAY,SAA0B;AACpD,MAAI,OAAO,YAAY,UAAU;AAC/B,WAAO,OAAO,YAAY,OAAO,CAAC;AAAA,EACpC;AAEA,QAAM,EAAE,aAAa,IAAI;AACzB,QAAM,eACJ,OAAO,iBAAiB,WAAW,YAAY,YAAY,IAAI;AACjE,QAAM,UAAU,OAAO;AAAA,IACrB,YAAY,cAAc;AAAA,IAC1B,YAAY,OAAO,aAAa,MAAM,CAAC;AAAA,IACvC;AAAA,EACF,CAAC;AACD,SAAO,QAAQ,OAAO,OAAO,CAAC;AAChC;AAdgB;","names":[]}