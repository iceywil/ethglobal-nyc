import type { AddressInput } from '@fuel-ts/address';
import { Address } from '@fuel-ts/address';
import type { BigNumberish, BN } from '@fuel-ts/math';
import type { Transaction } from '@fuel-ts/transactions';
import type { BytesLike } from '@fuel-ts/utils';
import type { Account } from '../account';
import { getSdk as getOperationsSdk } from './__generated__/operations';
import type { GqlReceiptFragment as TransactionReceiptJson, GqlNodeInfoFragment as NodeInfoJson, GqlChainInfoFragment as ChainInfoJson, GqlConsensusParametersVersion, GqlContractParameters as ContractParameters, GqlDryRunFailureStatusFragment, GqlDryRunSuccessStatusFragment, GqlFeeParameters as FeeParameters, GqlGasCostsFragment as GasCosts, GqlPredicateParameters as PredicateParameters, GqlScriptParameters as ScriptParameters, GqlTxParameters as TxParameters, GqlPageInfo, GqlRelayedTransactionFailed } from './__generated__/operations';
import type { Coin } from './coin';
import type { CoinQuantity, CoinQuantityLike } from './coin-quantity';
import type { Message, MessageProof, MessageStatus } from './message';
import type { Resource } from './resource';
import { ResourceCache } from './resource-cache';
import type { TransactionRequestLike, TransactionRequest, TransactionRequestInput, ScriptTransactionRequest } from './transaction-request';
import type { TransactionResultReceipt } from './transaction-response';
import { TransactionResponse } from './transaction-response';
import type { RetryOptions } from './utils/auto-retry-fetch';
import type { ProviderCacheJson, TransactionSummaryJsonPartial } from './utils/serialization';
export declare const RESOURCES_PAGE_SIZE_LIMIT = 512;
export declare const TRANSACTIONS_PAGE_SIZE_LIMIT = 60;
export declare const BALANCES_PAGE_SIZE_LIMIT = 100;
export declare const NON_PAGINATED_BALANCES_SIZE = 10000;
export declare const BLOCKS_PAGE_SIZE_LIMIT = 5;
export declare const DEFAULT_RESOURCE_CACHE_TTL = 20000;
export declare const GAS_USED_MODIFIER = 1.2;
export type Features = {
    balancePagination: boolean;
    amount128: boolean;
};
export type DryRunFailureStatusFragment = GqlDryRunFailureStatusFragment;
export type DryRunSuccessStatusFragment = GqlDryRunSuccessStatusFragment;
export type DryRunStatus = DryRunFailureStatusFragment | DryRunSuccessStatusFragment;
export type CallResult = {
    receipts: TransactionResultReceipt[];
    dryRunStatus?: DryRunStatus;
};
export type EstimateTxDependenciesReturns = CallResult & {
    outputVariables: number;
    missingContractIds: string[];
    rawReceipts: TransactionReceiptJson[];
};
/**
 * A Fuel block
 */
export type Block = {
    id: string;
    height: BN;
    time: string;
    transactionIds: string[];
    header: {
        daHeight: BN;
        stateTransitionBytecodeVersion: string;
        transactionsCount: string;
        transactionsRoot: string;
        messageOutboxRoot: string;
        eventInboxRoot: string;
        prevRoot: string;
        applicationHash: string;
    };
};
export type ResourcesIdsToIgnore = {
    utxos?: BytesLike[];
    messages?: BytesLike[];
};
export type AccountCoinQuantity = {
    assetId: string;
    amount: BigNumberish;
    account?: Account;
    changeOutputAccount?: Account;
};
export type AssembleTxParams<T extends TransactionRequest = TransactionRequest> = {
    request: T;
    accountCoinQuantities?: AccountCoinQuantity[];
    feePayerAccount: Account;
    blockHorizon?: number;
    estimatePredicates?: boolean;
    resourcesIdsToIgnore?: ResourcesIdsToIgnore;
    reserveGas?: number;
};
export type AssembleTxResponse<T extends TransactionRequest = TransactionRequest> = {
    assembledRequest: T;
    gasPrice: BN;
    receipts: TransactionResultReceipt[];
    rawReceipts: TransactionReceiptJson[];
};
export type PageInfo = GqlPageInfo;
export type GetCoinsResponse = {
    coins: Coin[];
    pageInfo: PageInfo;
};
export type GetMessagesResponse = {
    messages: Message[];
    pageInfo: PageInfo;
};
export type GetBalancesResponse = {
    balances: CoinQuantity[];
    pageInfo?: PageInfo;
};
export type GetTransactionsResponse = {
    transactions: Transaction[];
    pageInfo: PageInfo;
};
export type GetAssetDetailsResponse = {
    subId: string;
    contractId: string;
    totalSupply: BN;
};
export type GetBlocksResponse = {
    blocks: Block[];
    pageInfo: PageInfo;
};
export type GetAddressTypeResponse = 'Account' | 'Contract' | 'Transaction' | 'Blob' | 'Asset';
/**
 * Deployed Contract bytecode and contract id
 */
export type ContractResult = {
    id: string;
    bytecode: string;
};
type ModifyStringToBN<T> = {
    [P in keyof T]: P extends 'version' ? T[P] : T[P] extends string ? BN : T[P];
};
export { TransactionReceiptJson, NodeInfoJson, ChainInfoJson, GasCosts, FeeParameters, ContractParameters, PredicateParameters, ScriptParameters, TxParameters, };
export type ConsensusParameters = {
    version: GqlConsensusParametersVersion;
    chainId: BN;
    baseAssetId: string;
    feeParameters: ModifyStringToBN<FeeParameters>;
    contractParameters: ModifyStringToBN<ContractParameters>;
    predicateParameters: ModifyStringToBN<PredicateParameters>;
    scriptParameters: ModifyStringToBN<ScriptParameters>;
    txParameters: ModifyStringToBN<TxParameters>;
    gasCosts: GasCosts;
};
/**
 * Chain information
 */
export type ChainInfo = {
    name: string;
    baseChainHeight: BN;
    consensusParameters: ConsensusParameters;
    latestBlock: {
        header: {
            consensusParametersVersion: string;
        };
    };
};
/**
 * Node information
 */
export type NodeInfo = {
    utxoValidation: boolean;
    vmBacktrace: boolean;
    maxTx: BN;
    maxDepth: BN;
    nodeVersion: string;
    indexation: {
        balances: boolean;
        coinsToSpend: boolean;
        assetMetadata: boolean;
    };
};
/** @deprecated This type is no longer used. */
export type NodeInfoAndConsensusParameters = {
    nodeVersion: string;
    gasPerByte: BN;
    gasPriceFactor: BN;
    maxGasPerTx: BN;
};
export type TransactionCost = {
    gasPrice: BN;
    gasUsed: BN;
    minGas: BN;
    minFee: BN;
    maxFee: BN;
    maxGas: BN;
    rawReceipts: TransactionReceiptJson[];
    receipts: TransactionResultReceipt[];
    outputVariables: number;
    missingContractIds: string[];
    estimatedPredicates: TransactionRequestInput[];
    requiredQuantities: CoinQuantity[];
    addedSignatures: number;
    dryRunStatus?: DryRunStatus;
    updateMaxFee?: boolean;
    transactionSummary?: TransactionSummaryJsonPartial;
};
/**
 * @hidden
 *
 * Cursor pagination arguments
 *
 * https://relay.dev/graphql/connections.htm#sec-Arguments
 */
export type CursorPaginationArgs = {
    /** Forward pagination limit */
    first?: number | null;
    /** Forward pagination cursor */
    after?: string | null;
    /** Backward pagination limit  */
    last?: number | null;
    /** Backward pagination cursor */
    before?: string | null;
};
export type ProviderOptions = {
    /**
     * Custom fetch function to use for making requests.
     */
    fetch?: (url: string, requestInit?: RequestInit, providerOptions?: Omit<ProviderOptions, 'fetch'>) => Promise<Response>;
    /**
     * Timeout [ms] after which every request will be aborted.
     */
    timeout?: number;
    /**
     * Resources cache for the given time [ms]. If set to -1, the cache will be disabled.
     */
    resourceCacheTTL?: number;
    /**
     * Retry options to use when fetching data from the node.
     */
    retryOptions?: RetryOptions;
    /**
     * Custom headers to include in the request.
     */
    headers?: RequestInit['headers'];
    /**
     * Middleware to modify the request before it is sent.
     * This can be used to add headers, modify the body, etc.
     */
    requestMiddleware?: (request: RequestInit) => RequestInit | Promise<RequestInit>;
    /**
     * The cache can be passed in to avoid re-fetching the chain + node info.
     */
    cache?: ProviderCacheJson;
};
/**
 * UTXO validation params
 */
export type UTXOValidationParams = {
    utxoValidation?: boolean;
};
/**
 * Transaction estimation params
 */
export type EstimateTransactionParams = {
    /**
     * Estimate the transaction dependencies.
     */
    estimateTxDependencies?: boolean;
};
export type TransactionCostParams = EstimateTransactionParams & {
    /**
     * The quantities to forward to the contract.
     */
    quantities?: CoinQuantity[];
    /**
     * A callback to sign the transaction.
     *
     * @param request - The transaction request to sign.
     * @returns A promise that resolves to the signed transaction request.
     */
    signatureCallback?: (request: ScriptTransactionRequest) => Promise<ScriptTransactionRequest>;
    /**
     * The gas price to use for the transaction.
     */
    gasPrice?: BN;
};
export type EstimateTxDependenciesParams = {
    /**
     * The gas price to use for the transaction.
     */
    gasPrice?: BN;
};
export type EstimateTxGasAndFeeParams = {
    /**
     * The transaction request to estimate the gas and fee for.
     */
    transactionRequest: TransactionRequest;
    /**
     * The gas price to use for the transaction.
     */
    gasPrice?: BN;
};
/**
 * Provider Call transaction params
 */
export type ProviderCallParams = UTXOValidationParams & EstimateTransactionParams;
/**
 * Provider Send transaction params
 */
export type ProviderSendTxParams = EstimateTransactionParams & {
    /**
     * Whether to enable asset burn for the transaction.
     */
    enableAssetBurn?: boolean;
    /**
     * Whether to include the pre-confirmation status for the transaction.
     */
    includePreConfirmation?: boolean;
};
type Operations = ReturnType<typeof getOperationsSdk>;
type SdkOperations = Omit<Operations, 'statusChange' | 'submitAndAwaitStatus'> & {
    statusChange: (...args: Parameters<Operations['statusChange']>) => Promise<ReturnType<Operations['statusChange']>>;
    submitAndAwaitStatus: (...args: Parameters<Operations['submitAndAwaitStatus']>) => Promise<ReturnType<Operations['submitAndAwaitStatus']>>;
    getBlobs: (variables: {
        blobIds: string[];
    }) => Promise<{
        blob: {
            id: string;
        } | null;
    }[]>;
};
/**
 * A provider for connecting to a node
 */
export default class Provider {
    #private;
    operations: SdkOperations;
    cache?: ResourceCache;
    /**
     * @hidden
     * @param url - If provided, clears cache only for given url
     */
    static clearChainAndNodeCaches(url?: string): void;
    /** @hidden */
    url: string;
    /** @hidden */
    private urlWithoutAuth;
    /**
     * Governs whether to include the required block height in the request body
     * for block-sensitive operations like when submitting a transaction.
     *
     * This ensures that the operation is executed at the correct block height,
     * regardless of which node in the network the request is routed to.
     *
     * `true` by default.
     */
    static ENABLE_RPC_CONSISTENCY: boolean;
    /** @hidden */
    private static inflightFetchChainAndNodeInfoRequests;
    /** @hidden */
    private static chainInfoCache;
    /** @hidden */
    private static nodeInfoCache;
    /** @hidden */
    private static currentBlockHeightCache;
    /** @hidden */
    private static incompatibleNodeVersionMessage;
    /** @hidden */
    consensusParametersTimestamp?: number;
    options: ProviderOptions;
    private static extractOperationName;
    private static isWriteOperation;
    private static normalizeUrl;
    private static hasWriteOperationHappened;
    /**
     * @hidden
     */
    private static getFetchFn;
    private static applyBlockHeight;
    private static fetchAndProcessBlockHeight;
    private static setCurrentBlockHeight;
    /**
     * Constructor to initialize a Provider.
     *
     * @param url - GraphQL endpoint of the Fuel node
     * @param options - Additional options for the provider
     * @hidden
     */
    constructor(url: string, options?: ProviderOptions);
    private static extractBasicAuth;
    /**
     * Initialize Provider async stuff
     */
    init(): Promise<Provider>;
    /**
     * Returns the `chainInfo` for the current network.
     *
     * @returns the chain information configuration.
     */
    getChain(): Promise<ChainInfo>;
    /**
     * Returns the `nodeInfo` for the current network.
     *
     * @returns the node information configuration.
     */
    getNode(): Promise<NodeInfo>;
    /**
     * Returns some helpful parameters related to gas fees.
     */
    getGasConfig(): Promise<{
        maxGasPerTx: BN;
        maxGasPerPredicate: BN;
        gasPriceFactor: BN;
        gasPerByte: BN;
        gasCosts: GasCosts;
    }>;
    /**
     * Updates the URL for the provider and fetches the consensus parameters for the new URL, if needed.
     *
     * @param url - The URL to connect to.
     * @param options - Additional options for the provider.
     */
    connect(url: string, options?: ProviderOptions): Promise<void>;
    /**
     * Return the chain and node information.
     * @param ignoreCache - If true, ignores the cache and re-fetch configs.
     * @returns A promise that resolves to the Chain and NodeInfo.
     */
    fetchChainAndNodeInfo(ignoreCache?: boolean): Promise<{
        chain: ChainInfo;
        nodeInfo: NodeInfo;
    }>;
    /**
     * @hidden
     */
    private static setIncompatibleNodeVersionMessage;
    /**
     * Create GraphQL client and set operations.
     *
     * @returns The operation SDK object
     * @hidden
     */
    private createOperations;
    /**
     * Returns the version of the connected node.
     *
     * @returns A promise that resolves to the version string.
     */
    getVersion(): Promise<string>;
    /**
     * Returns the latest block number.
     *
     * @returns A promise that resolves to the latest block number.
     */
    getBlockNumber(): Promise<BN>;
    /**
     * Returns the node information for the current provider network.
     *
     * @returns a promise that resolves to the node information.
     */
    fetchNode(): Promise<NodeInfo>;
    /**
     * Returns the chain information for the current provider network.
     *
     * @returns a promise that resolves to the chain information.
     */
    fetchChain(): Promise<ChainInfo>;
    /**
     * Returns the chain ID for the current provider network.
     *
     * @returns A promise that resolves to the chain ID number.
     */
    getChainId(): Promise<number>;
    /**
     * Returns the base asset ID for the current provider network.
     *
     * @returns the base asset ID.
     */
    getBaseAssetId(): Promise<string>;
    /**
     * Retrieves the details of an asset given its ID.
     *
     * @param assetId - The unique identifier of the asset.
     * @returns A promise that resolves to an object containing the asset details.
     */
    getAssetDetails(assetId: string): Promise<GetAssetDetailsResponse>;
    /**
     * @hidden
     */
    validateTransaction(tx: TransactionRequest): Promise<void>;
    /**
     * Submits a transaction to the chain to be executed.
     *
     * If the transaction is missing any dependencies,
     * the transaction will be mutated and those dependencies will be added.
     *
     * @param transactionRequestLike - The transaction request object.
     * @param sendTransactionParams - The provider send transaction parameters (optional).
     * @returns A promise that resolves to the transaction response object.
     */
    sendTransaction(transactionRequestLike: TransactionRequestLike, { enableAssetBurn, estimateTxDependencies, includePreConfirmation: _includePreConfirmation, }?: ProviderSendTxParams): Promise<TransactionResponse>;
    /**
     * Executes a transaction without actually submitting it to the chain.
     *
     * If the transaction is missing any dependencies,
     * the transaction will be mutated and those dependencies will be added.
     *
     * @param transactionRequestLike - The transaction request object.
     * @param sendTransactionParams - The provider call parameters (optional).
     * @returns A promise that resolves to the call result object.
     */
    dryRun(transactionRequestLike: TransactionRequestLike, { utxoValidation, estimateTxDependencies }?: ProviderCallParams): Promise<CallResult>;
    /**
     * Estimates the gas usage for predicates in a transaction request.
     *
     * @template T - The type of the transaction request object.
     *
     * @param transactionRequest - The transaction request to estimate predicates for.
     * @returns A promise that resolves to the updated transaction request with estimated gas usage for predicates.
     */
    estimatePredicates<T extends TransactionRequest>(transactionRequest: T): Promise<T>;
    /**
     * Estimates the gas price and predicates for a given transaction request and block horizon.
     *
     * @param transactionRequest - The transaction request to estimate predicates and gas price for.
     * @param blockHorizon - The block horizon to use for gas price estimation.
     * @returns A promise that resolves to an object containing the updated transaction
     * request and the estimated gas price.
     */
    estimatePredicatesAndGasPrice<T extends TransactionRequest>(transactionRequest: T, blockHorizon: number): Promise<{
        transactionRequest: T;
        gasPrice: BN;
    }>;
    /**
     * Will dryRun a transaction and check for missing dependencies.
     *
     * If there are missing variable outputs,
     * `addVariableOutputs` is called on the transaction.
     *
     * @param transactionRequest - The transaction request object.
     * @param gasPrice - The gas price to use for the transaction, if not provided it will be fetched.
     * @returns A promise that resolves to the estimate transaction dependencies.
     */
    estimateTxDependencies(transactionRequest: TransactionRequest, { gasPrice: gasPriceParam }?: EstimateTxDependenciesParams): Promise<EstimateTxDependenciesReturns>;
    /**
     * Dry runs multiple transactions and checks for missing dependencies in batches.
     *
     * Transactions are dry run in batches. After each dry run, transactions requiring
     * further modifications are identified. The method iteratively updates these transactions
     * and performs subsequent dry runs until all dependencies for each transaction are satisfied.
     *
     * @param transactionRequests - Array of transaction request objects.
     * @returns A promise that resolves to an array of results for each transaction.
     */
    estimateMultipleTxDependencies(transactionRequests: TransactionRequest[]): Promise<EstimateTxDependenciesReturns[]>;
    /**
     * Dry runs multiple transactions.
     *
     * @param transactionRequests - Array of transaction request objects.
     * @param sendTransactionParams - The provider call parameters (optional).
     *
     * @returns A promise that resolves to an array of results for each transaction call.
     */
    dryRunMultipleTransactions(transactionRequests: TransactionRequest[], { utxoValidation, estimateTxDependencies }?: ProviderCallParams): Promise<CallResult[]>;
    autoRefetchConfigs(): Promise<void>;
    /**
     * Estimates the transaction gas and fee based on the provided transaction request.
     * @param params - The parameters for estimating the transaction gas and fee.
     * @returns An object containing the estimated minimum gas, minimum fee, maximum gas, and maximum fee.
     */
    estimateTxGasAndFee(params: EstimateTxGasAndFeeParams): Promise<{
        minGas: BN;
        minFee: BN;
        maxGas: BN;
        maxFee: BN;
        gasPrice: BN;
        gasLimit: BN;
    }>;
    /**
     * Executes a signed transaction without applying the states changes
     * on the chain.
     *
     * If the transaction is missing any dependencies,
     * the transaction will be mutated and those dependencies will be added
     *
     * @param transactionRequestLike - The transaction request object.
     * @param estimateTxParams - The estimate transaction params (optional).
     * @returns A promise that resolves to the call result object.
     */
    simulate(transactionRequestLike: TransactionRequestLike, { estimateTxDependencies }?: EstimateTransactionParams): Promise<CallResult>;
    /**
     * @hidden
     *
     * Returns a transaction cost to enable user
     * to set gasLimit and also reserve balance amounts
     * on the transaction.
     *
     * @param transactionRequestLike - The transaction request object.
     * @param transactionCostParams - The transaction cost parameters (optional).
     *
     * @returns A promise that resolves to the transaction cost object.
     *
     * @deprecated Use provider.assembleTx instead
     * Check the migration guide https://docs.fuel.network/guide/assembling-transactions/migration-guide.html for more information.
     */
    getTransactionCost(transactionRequestLike: TransactionRequestLike, { signatureCallback, gasPrice: gasPriceParam }?: TransactionCostParams): Promise<Omit<TransactionCost, 'requiredQuantities'>>;
    /**
     * Assembles a transaction by completely estimating and funding it.
     *
     * @param params - Parameters used to assemble the transaction.
     *
     * @returns The assembled transaction request, estimated gas price, and receipts
     */
    assembleTx<T extends TransactionRequest>(params: AssembleTxParams<T>): Promise<AssembleTxResponse<T>>;
    /**
     * Returns coins for the given owner.
     *
     * @param owner - The address to get coins for.
     * @param assetId - The asset ID of coins to get (optional).
     * @param paginationArgs - Pagination arguments (optional).
     *
     * @returns A promise that resolves to the coins.
     */
    getCoins(owner: AddressInput, assetId?: BytesLike, paginationArgs?: CursorPaginationArgs): Promise<GetCoinsResponse>;
    /**
     * Returns resources for the given owner satisfying the spend query.
     *
     * @param owner - The address to get resources for.
     * @param quantities - The coin quantities to get.
     * @param resourcesIdsToIgnore - IDs of excluded resources from the selection (optional).
     * @returns A promise that resolves to the resources.
     */
    getResourcesToSpend(owner: AddressInput, quantities: CoinQuantityLike[], resourcesIdsToIgnore?: ResourcesIdsToIgnore): Promise<Resource[]>;
    /**
     * Returns an array of blobIds that exist on chain, for a given array of blobIds.
     *
     * @param blobIds - blobIds to check.
     * @returns - A promise that resolves to an array of blobIds that exist on chain.
     */
    getBlobs(blobIds: string[]): Promise<string[]>;
    /**
     * Returns block matching the given ID or height.
     *
     * @param idOrHeight - ID or height of the block.
     * @returns A promise that resolves to the block or null.
     */
    getBlock(idOrHeight: BigNumberish | 'latest'): Promise<Block | null>;
    /**
     * Returns all the blocks matching the given parameters.
     *
     * @param params - The parameters to query blocks.
     * @returns A promise that resolves to the blocks.
     */
    getBlocks(params?: CursorPaginationArgs): Promise<GetBlocksResponse>;
    /**
     * Returns block matching the given ID or type, including transaction data.
     *
     * @param idOrHeight - ID or height of the block.
     * @returns A promise that resolves to the block.
     */
    getBlockWithTransactions(
    /** ID or height of the block */
    idOrHeight: BigNumberish | 'latest'): Promise<(Block & {
        transactions: Transaction[];
    }) | null>;
    /**
     * Get transaction with the given ID.
     *
     * @param transactionId - ID of the transaction.
     * @returns A promise that resolves to the transaction.
     */
    getTransaction<TTransactionType = void>(transactionId: string): Promise<Transaction<TTransactionType> | null>;
    /**
     * Retrieves transactions based on the provided pagination arguments.
     * @param paginationArgs - The pagination arguments for retrieving transactions.
     * @returns A promise that resolves to an object containing the retrieved transactions and pagination information.
     */
    getTransactions(paginationArgs?: CursorPaginationArgs): Promise<GetTransactionsResponse>;
    /**
     * Fetches a compressed block at the specified height.
     *
     * @param height - The height of the block to fetch.
     * @returns The compressed block if available, otherwise `null`.
     */
    daCompressedBlock(height: string): Promise<{
        bytes: string;
    } | null>;
    /**
     * Get deployed contract with the given ID.
     *
     * @param contractId - ID of the contract.
     * @returns A promise that resolves to the contract.
     */
    getContract(contractId: string): Promise<ContractResult | null>;
    /**
     * Returns the balance for the given contract for the given asset ID.
     *
     * @param contractId - The contract ID to get the balance for.
     * @param assetId - The asset ID of coins to get.
     * @returns A promise that resolves to the balance.
     */
    getContractBalance(
    /** The contract ID to get the balance for */
    contractId: string | Address, 
    /** The asset ID of coins to get */
    assetId: BytesLike): Promise<BN>;
    /**
     * Returns the balance for the given owner for the given asset ID.
     *
     * @param owner - The address to get coins for.
     * @param assetId - The asset ID of coins to get.
     * @returns A promise that resolves to the balance.
     */
    getBalance(
    /** The address to get coins for */
    owner: AddressInput, 
    /** The asset ID of coins to get */
    assetId: BytesLike): Promise<BN>;
    /**
     * Returns balances for the given owner.
     *
     * @param owner - The address to get coins for.
     * @param paginationArgs - Pagination arguments (optional).
     * @returns A promise that resolves to the balances.
     */
    getBalances(owner: string | Address, paginationArgs?: CursorPaginationArgs): Promise<GetBalancesResponse>;
    /**
     * Returns message for the given address.
     *
     * @param address - The address to get message from.
     * @param paginationArgs - Pagination arguments (optional).
     * @returns A promise that resolves to the messages.
     */
    getMessages(address: AddressInput, paginationArgs?: CursorPaginationArgs): Promise<GetMessagesResponse>;
    /**
     * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
     *
     * @param transactionId - The transaction to get message from.
     * @param messageId - The message id from MessageOut receipt.
     * @param commitBlockId - The commit block id (optional).
     * @param commitBlockHeight - The commit block height (optional).
     * @returns A promise that resolves to the message proof.
     */
    getMessageProof(transactionId: string, nonce: string, commitBlockId?: string, commitBlockHeight?: BN): Promise<MessageProof>;
    /**
     * Get the latest gas price from the node.
     *
     * @returns A promise that resolves to the latest gas price.
     */
    getLatestGasPrice(): Promise<BN>;
    /**
     * Returns the estimate gas price for the given block horizon.
     *
     * @param blockHorizon - The block horizon to estimate gas price for.
     * @returns A promise that resolves to the estimated gas price.
     */
    estimateGasPrice(blockHorizon: number): Promise<BN>;
    /**
     * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
     *
     * @param nonce - The nonce of the message to get status from.
     * @returns A promise that resolves to the message status
     */
    getMessageStatus(
    /** The nonce of the message to get status from */
    nonce: string): Promise<MessageStatus>;
    /**
     * Lets you produce blocks with custom timestamps and the block number of the last block produced.
     *
     * @param amount - The amount of blocks to produce.
     * @param startTime - The UNIX timestamp (milliseconds) to set for the first produced block (optional).
     * @returns A promise that resolves to the block number of the last produced block.
     */
    produceBlocks(amount: number, startTime?: number): Promise<BN>;
    /**
     * Check if the given ID is an account.
     *
     * @param id - The ID to check.
     * @returns A promise that resolves to the result of the check.
     */
    isUserAccount(id: string): Promise<boolean>;
    /**
     * Determines the type of address based on the provided ID.
     *
     * @param id - The ID to be checked.
     * @returns A promise that resolves to a string indicating the type of address.
     */
    getAddressType(id: string): Promise<GetAddressTypeResponse>;
    /**
     * Get the transaction response for the given transaction ID.
     *
     * @param transactionId - The transaction ID to get the response for.
     * @returns A promise that resolves to the transaction response.
     */
    getTransactionResponse(transactionId: string): Promise<TransactionResponse>;
    /**
     * Returns Message for given nonce.
     *
     * @param nonce - The nonce of the message to retrieve.
     * @returns A promise that resolves to the Message object or null.
     */
    getMessageByNonce(nonce: string): Promise<Message | null>;
    /**
     * Get the relayed transaction for the given transaction ID.
     *
     * @param relayedTransactionId - The relayed transaction ID to get the response for.
     * @returns A promise that resolves to the relayed transaction.
     */
    getRelayedTransactionStatus(relayedTransactionId: string): Promise<GqlRelayedTransactionFailed | null>;
    /**
     * @hidden
     */
    private extractDryRunError;
    /**
     * @hidden
     */
    getNodeFeatures(): Promise<{
        assetMetadata: boolean;
        balancesPagination: boolean;
        coinsToSpend: boolean;
    }>;
    /**
     * @hidden
     */
    private parseEstimatePredicatesResponse;
    /**
     * @hidden
     *
     * This helper adjusts the resources to be excluded for a given set of addresses.
     * Supporting multiple addresses is important because of the `assembleTx` method,
     * which may be invoked with different addresses. It handles both messages and UTXOs,
     * ensuring the total number of inputs does not exceed the maximum allowed by the chain's
     * consensus parameters. The resources specified in the `resourcesIdsToIgnore` parameter have priority
     * over those retrieved from the cache.
     */
    private adjustResourcesToIgnoreForAddresses;
}
//# sourceMappingURL=provider.d.ts.map