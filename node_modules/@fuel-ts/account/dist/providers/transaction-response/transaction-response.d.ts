import type { BN } from '@fuel-ts/math';
import type { ReceiptCall, ReceiptLog, ReceiptLogData, ReceiptPanic, ReceiptReturn, ReceiptReturnData, ReceiptRevert, ReceiptTransfer, ReceiptTransferOut, ReceiptScriptResult, ReceiptMessageOut, ReceiptMint, ReceiptBurn } from '@fuel-ts/transactions';
import type Provider from '../provider';
import type { TransactionRequest, JsonAbisFromAllCalls } from '../transaction-request';
import type { TransactionSummary, GqlTransaction, AbiMap, PreConfirmationTransactionSummary } from '../transaction-summary/types';
import type { ProviderCacheJson } from '../utils/serialization';
import { type DecodedLogs } from './getAllDecodedLogs';
/** @hidden */
export type TransactionResultCallReceipt = ReceiptCall;
/** @hidden */
export type TransactionResultReturnReceipt = ReceiptReturn;
/** @hidden */
export type TransactionResultReturnDataReceipt = ReceiptReturnData & {
    data: string;
};
/** @hidden */
export type TransactionResultPanicReceipt = ReceiptPanic;
/** @hidden */
export type TransactionResultRevertReceipt = ReceiptRevert;
/** @hidden */
export type TransactionResultLogReceipt = ReceiptLog;
/** @hidden */
export type TransactionResultLogDataReceipt = ReceiptLogData & {
    data: string;
};
/** @hidden */
export type TransactionResultTransferReceipt = ReceiptTransfer;
/** @hidden */
export type TransactionResultTransferOutReceipt = ReceiptTransferOut;
/** @hidden */
export type TransactionResultScriptResultReceipt = ReceiptScriptResult;
/** @hidden */
export type TransactionResultMessageOutReceipt = ReceiptMessageOut;
export type TransactionResultMintReceipt = ReceiptMint;
export type TransactionResultBurnReceipt = ReceiptBurn;
/** @hidden */
export type TransactionResultReceipt = ReceiptCall | ReceiptReturn | (ReceiptReturnData & {
    data: string;
}) | ReceiptPanic | ReceiptRevert | ReceiptLog | (ReceiptLogData & {
    data: string;
}) | ReceiptTransfer | ReceiptTransferOut | ReceiptScriptResult | ReceiptMessageOut | TransactionResultMintReceipt | TransactionResultBurnReceipt;
/** @hidden */
export type TransactionResult<TTransactionType = void> = TransactionSummary<TTransactionType> & {
    logs?: DecodedLogs['logs'];
    groupedLogs?: DecodedLogs['groupedLogs'];
};
export type PreConfirmationTransactionResult = PreConfirmationTransactionSummary & {
    logs?: DecodedLogs['logs'];
    groupedLogs?: DecodedLogs['groupedLogs'];
};
type SubmitAndAwaitStatusSubscriptionIterable = Awaited<ReturnType<Provider['operations']['submitAndAwaitStatus']>>;
type StatusChangeSubscription = Awaited<ReturnType<Provider['operations']['statusChange']>> extends AsyncIterable<infer R> ? R : never;
export type TransactionResponseJson = {
    id: string;
    providerUrl: string;
    abis?: JsonAbisFromAllCalls;
    status?: StatusChangeSubscription['statusChange'];
    preConfirmationStatus?: StatusChangeSubscription['statusChange'];
    providerCache: ProviderCacheJson;
    gqlTransaction?: GqlTransaction;
    requestJson?: string;
};
/**
 * Represents a response for a transaction.
 */
export declare class TransactionResponse {
    private submitTxSubscription?;
    /** Transaction ID */
    id: string;
    /** Current provider */
    provider: Provider;
    /** Gas used on the transaction */
    gasUsed: BN;
    /** The graphql Transaction with receipts object. */
    gqlTransaction?: GqlTransaction;
    request?: TransactionRequest;
    status?: StatusChangeSubscription['statusChange'];
    abis?: JsonAbisFromAllCalls;
    preConfirmationStatus?: StatusChangeSubscription['statusChange'];
    private waitingForStreamData;
    private statusResolvers;
    /**
     * Constructor for `TransactionResponse`.
     *
     * @param tx - The transaction ID or TransactionRequest.
     * @param provider - The provider.
     */
    constructor(tx: string | TransactionRequest, provider: Provider, chainId: number, abis?: JsonAbisFromAllCalls, submitTxSubscription?: SubmitAndAwaitStatusSubscriptionIterable | undefined);
    /**
     * Async constructor for `TransactionResponse`. This method can be used to create
     * an instance of `TransactionResponse` and wait for the transaction to be fetched
     * from the chain, ensuring that the `gqlTransaction` property is set.
     *
     * @param id - The transaction ID.
     * @param provider - The provider.
     */
    static create(id: string, provider: Provider, abis?: JsonAbisFromAllCalls): Promise<TransactionResponse>;
    private applyMalleableSubscriptionFields;
    private getTransaction;
    /**
     *
     * NOTE: This method is only called within `getTransactionSummary`, which is invoked after `getTransaction`.
     * Since `getTransaction` only resolves once the transaction has been processed,
     * the status at this point is guaranteed to be either `SuccessStatus` or `FailureStatus`.
     */
    private getReceipts;
    /**
     * Fetch the transaction with receipts from the provider.
     *
     * @returns Transaction with receipts query result.
     */
    fetch(): Promise<GqlTransaction>;
    /**
     * Retrieves the TransactionSummary. If the `gqlTransaction` is not set, it will
     * fetch it from the provider
     *
     * @param contractsAbiMap - The contracts ABI map.
     * @returns
     */
    getTransactionSummary<TTransactionType = void>(contractsAbiMap?: AbiMap): Promise<TransactionSummary<TTransactionType>>;
    getPreConfirmationTransactionSummary(contractsAbiMap?: AbiMap): Promise<PreConfirmationTransactionSummary>;
    private resolveStatus;
    private waitForStatus;
    /**
     * Waits for the status change of the transaction.
     * If the transaction is already in a final state, it will return immediately.
     * If the transaction is not in a final state, it will wait for the status change.
     * If we are already subscribed to the status change, it will return immediately.
     */
    private waitForStatusChange;
    private waitForConfirmationStatuses;
    private waitForPreConfirmationStatuses;
    /**
     * Assembles the result of a transaction by retrieving the transaction summary,
     * decoding logs (if available), and handling transaction failure.
     *
     * This method can be used to obtain the result of a transaction that has just
     * been submitted or one that has already been processed.
     *
     * @template TTransactionType - The type of the transaction.
     * @param contractsAbiMap - The map of contract ABIs.
     * @returns - The assembled transaction result.
     * @throws If the transaction status is a failure.
     */
    assembleResult<TTransactionType = void>(contractsAbiMap?: AbiMap): Promise<TransactionResult<TTransactionType>>;
    assemblePreConfirmationResult(contractsAbiMap?: AbiMap): Promise<PreConfirmationTransactionResult>;
    /**
     * Waits for transaction to complete and returns the result.
     *
     * @returns The completed transaction result
     */
    waitForResult<TTransactionType = void>(contractsAbiMap?: AbiMap): Promise<TransactionResult<TTransactionType>>;
    /**
     * Waits for the transaction's pre-confirmation and returns the result.
     *
     * @param contractsAbiMap - The contracts ABI map.
     * @returns The pre-confirmed transaction result
     */
    waitForPreConfirmation(contractsAbiMap?: AbiMap): Promise<PreConfirmationTransactionResult>;
    /**
     * Waits for transaction to complete and returns the result.
     *
     * @param contractsAbiMap - The contracts ABI map.
     */
    wait<TTransactionType = void>(contractsAbiMap?: AbiMap): Promise<TransactionResult<TTransactionType>>;
    private unsetResourceCache;
    private getTransactionStatus;
}
export {};
//# sourceMappingURL=transaction-response.d.ts.map