var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/test-utils/launchNode.ts
import { BYTES_32 } from "@fuel-ts/abi-coder";
import { randomBytes as randomBytes2, randomUUID } from "@fuel-ts/crypto";
import { FuelError } from "@fuel-ts/errors";
import { defaultConsensusKey, hexlify as hexlify2, defaultSnapshotConfigs } from "@fuel-ts/utils";
import { existsSync, mkdirSync, rmSync, writeFileSync } from "fs";
import os from "os";
import path from "path";

// src/signer/signer.ts
import { Address } from "@fuel-ts/address";
import { randomBytes } from "@fuel-ts/crypto";
import { hash } from "@fuel-ts/hasher";
import { toBytes } from "@fuel-ts/math";
import { hexlify, concat, arrayify } from "@fuel-ts/utils";
import { secp256k1 } from "@noble/curves/secp256k1";
var Signer = class _Signer {
  static {
    __name(this, "Signer");
  }
  address;
  publicKey;
  compressedPublicKey;
  privateKey;
  /**
   * Create a Signer instance from a given private key
   *
   * @param privateKey - The private key to use for signing
   * @returns A new Signer instance
   */
  constructor(privateKey) {
    if (typeof privateKey === "string") {
      if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
        privateKey = `0x${privateKey}`;
      }
    }
    const privateKeyBytes = toBytes(privateKey, 32);
    this.privateKey = hexlify(privateKeyBytes);
    this.publicKey = hexlify(secp256k1.getPublicKey(privateKeyBytes, false).slice(1));
    this.compressedPublicKey = hexlify(secp256k1.getPublicKey(privateKeyBytes, true));
    this.address = new Address(this.publicKey);
  }
  /**
   * Sign data using the Signer instance
   *
   * Signature is a 64 byte array of the concatenated r and s values with the compressed recoveryParam byte.
   * @ignore
   * [Read more](FuelLabs/fuel-specs/specs/protocol/cryptographic_primitives.md#public-key-cryptography)
   *
   * @param data - The data to be sign
   * @returns hashed signature
   */
  sign(data) {
    const signature = secp256k1.sign(arrayify(data), arrayify(this.privateKey));
    const r = toBytes(`0x${signature.r.toString(16)}`, 32);
    const s = toBytes(`0x${signature.s.toString(16)}`, 32);
    s[0] |= (signature.recovery || 0) << 7;
    return hexlify(concat([r, s]));
  }
  /**
   * Add point on the current elliptic curve
   *
   * @param point - Point to add on the curve
   * @returns compressed point on the curve
   */
  addPoint(point) {
    const p0 = secp256k1.ProjectivePoint.fromHex(arrayify(this.compressedPublicKey));
    const p1 = secp256k1.ProjectivePoint.fromHex(arrayify(point));
    const result = p0.add(p1);
    return `0x${result.toHex(true)}`;
  }
  /**
   * Recover the public key from a signature performed with [`sign`](#sign).
   *
   * @param data - Data
   * @param signature - hashed signature
   * @returns public key from signature from the
   */
  static recoverPublicKey(data, signature) {
    const signedMessageBytes = arrayify(signature);
    const r = signedMessageBytes.slice(0, 32);
    const s = signedMessageBytes.slice(32, 64);
    const recoveryParam = (s[0] & 128) >> 7;
    s[0] &= 127;
    const sig = new secp256k1.Signature(BigInt(hexlify(r)), BigInt(hexlify(s))).addRecoveryBit(
      recoveryParam
    );
    const publicKey = sig.recoverPublicKey(arrayify(data)).toRawBytes(false).slice(1);
    return hexlify(publicKey);
  }
  /**
   * Recover the address from a signature performed with [`sign`](#sign).
   *
   * @param data - Data
   * @param signature - Signature
   * @returns Address from signature
   */
  static recoverAddress(data, signature) {
    return new Address(_Signer.recoverPublicKey(data, signature));
  }
  /**
   * Generate a random privateKey
   *
   * @param entropy - Adds extra entropy to generate the privateKey
   * @returns random 32-byte hashed
   */
  static generatePrivateKey(entropy) {
    return entropy ? hash(concat([randomBytes(32), arrayify(entropy)])) : randomBytes(32);
  }
  /**
   * Extended publicKey from a compact publicKey
   *
   * @param publicKey - Compact publicKey
   * @returns extended publicKey
   */
  static extendPublicKey(publicKey) {
    const point = secp256k1.ProjectivePoint.fromHex(arrayify(publicKey));
    return hexlify(point.toRawBytes(false).slice(1));
  }
};

// src/test-utils/launchNode.ts
var getFlagValueFromArgs = /* @__PURE__ */ __name((args, flag) => {
  const flagIndex = args.indexOf(flag);
  if (flagIndex === -1) {
    return void 0;
  }
  return args[flagIndex + 1];
}, "getFlagValueFromArgs");
var extractRemainingArgs = /* @__PURE__ */ __name((args, flagsToRemove) => {
  const newArgs = [...args];
  flagsToRemove.forEach((flag) => {
    const flagIndex = newArgs.indexOf(flag);
    if (flagIndex !== -1) {
      newArgs.splice(flagIndex, 2);
    }
  });
  return newArgs;
}, "extractRemainingArgs");
function getFinalStateConfigJSON({
  stateConfig,
  chainConfig,
  includeInitialState = false
}) {
  const defaultCoins = defaultSnapshotConfigs.stateConfig.coins.map((coin) => ({
    ...coin,
    amount: "18446744073709551615"
  }));
  const defaultMessages = defaultSnapshotConfigs.stateConfig.messages.map((message) => ({
    ...message,
    amount: "18446744073709551615"
  }));
  const coins = defaultCoins.concat(stateConfig.coins.map((coin) => ({ ...coin, amount: coin.amount.toString() }))).filter((coin, index, self) => self.findIndex((c) => c.tx_id === coin.tx_id) === index);
  const messages = defaultMessages.concat(stateConfig.messages.map((msg) => ({ ...msg, amount: msg.amount.toString() }))).filter((msg, index, self) => self.findIndex((m) => m.nonce === msg.nonce) === index);
  if (includeInitialState) {
    coins.push({
      tx_id: "0x0000000000000000000000000000000000000000000000000000000000000001",
      output_index: 0,
      tx_pointer_block_height: 0,
      tx_pointer_tx_idx: 0,
      owner: "0x94ffcc53b892684acefaebc8a3d4a595e528a8cf664eeb3ef36f1020b0809d0d",
      amount: "18446744073709551615",
      asset_id: "0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07"
    });
    coins.push({
      tx_id: "0x0000000000000000000000000000000000000000000000000000000000000002",
      output_index: 0,
      tx_pointer_block_height: 0,
      tx_pointer_tx_idx: 0,
      owner: "0x09c0b2d1a486c439a87bcba6b46a7a1a23f3897cc83a94521a96da5c23bc58db",
      amount: "18446744073709551615",
      asset_id: "0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07"
    });
  }
  if (!process.env.GENESIS_SECRET) {
    const pk = Signer.generatePrivateKey();
    const signer = new Signer(pk);
    process.env.GENESIS_SECRET = hexlify2(pk);
    coins.push({
      tx_id: hexlify2(randomBytes2(BYTES_32)),
      owner: signer.address.toHexString(),
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      amount: "18446744073709551615",
      asset_id: chainConfig.consensus_parameters.V2.base_asset_id,
      output_index: 0,
      tx_pointer_block_height: 0,
      tx_pointer_tx_idx: 0
    });
  }
  const json = JSON.stringify({
    ...stateConfig,
    coins,
    messages
  });
  const regexMakeNumber = /("amount":)"(\d+)"/gm;
  return json.replace(regexMakeNumber, "$1$2");
}
__name(getFinalStateConfigJSON, "getFinalStateConfigJSON");
var launchNode = /* @__PURE__ */ __name(async ({
  ip,
  port,
  args = [],
  fuelCorePath = process.env.FUEL_CORE_PATH || void 0,
  loggingEnabled = true,
  basePath,
  snapshotConfig = defaultSnapshotConfigs,
  includeInitialState = false,
  killProcessOnExit = false
} = {}) => (
  // eslint-disable-next-line no-async-promise-executor
  new Promise(async (resolve, reject) => {
    const remainingArgs = extractRemainingArgs(args, [
      "--snapshot",
      "--consensus-key",
      "--db-type",
      "--poa-instant",
      "--min-gas-price",
      "--native-executor-version"
    ]);
    const snapshotDir = getFlagValueFromArgs(args, "--snapshot");
    const consensusKey = getFlagValueFromArgs(args, "--consensus-key") || defaultConsensusKey;
    const dbTypeFlagValue = getFlagValueFromArgs(args, "--db-type");
    const useInMemoryDb = dbTypeFlagValue === "in-memory" || dbTypeFlagValue === void 0;
    const poaInstantFlagValue = getFlagValueFromArgs(args, "--poa-instant");
    const poaInstant = poaInstantFlagValue === "true" || poaInstantFlagValue === void 0;
    const nativeExecutorVersion = getFlagValueFromArgs(args, "--native-executor-version") || "0";
    const minGasPrice = getFlagValueFromArgs(args, "--min-gas-price") || "1";
    const startingGasPrice = getFlagValueFromArgs(args, "--starting-gas-price") || "1";
    const graphQLStartSubstring = "Binding GraphQL provider to";
    const command = fuelCorePath || "fuel-core";
    const ipToUse = ip || "0.0.0.0";
    const portToUse = port || "0";
    let snapshotDirToUse;
    const prefix = basePath || os.tmpdir();
    const suffix = basePath ? "" : randomUUID();
    const tempDir = path.join(prefix, ".fuels", suffix, "snapshotDir");
    if (snapshotDir) {
      snapshotDirToUse = snapshotDir;
    } else {
      if (!existsSync(tempDir)) {
        mkdirSync(tempDir, { recursive: true });
      }
      const { metadata } = snapshotConfig;
      const metadataPath = path.join(tempDir, "metadata.json");
      const chainConfigPath = path.join(tempDir, metadata.chain_config);
      const stateConfigPath = path.join(tempDir, metadata.table_encoding.Json.filepath);
      const stateTransitionPath = path.join(tempDir, "state_transition_bytecode.wasm");
      writeFileSync(chainConfigPath, JSON.stringify(snapshotConfig.chainConfig), "utf8");
      writeFileSync(
        stateConfigPath,
        getFinalStateConfigJSON({
          ...snapshotConfig,
          includeInitialState
        }),
        "utf8"
      );
      writeFileSync(metadataPath, JSON.stringify(metadata), "utf8");
      writeFileSync(stateTransitionPath, JSON.stringify(""));
      snapshotDirToUse = tempDir;
    }
    const { spawn } = await import("child_process");
    const child = spawn(
      command,
      [
        "run",
        ["--ip", ipToUse],
        ["--port", portToUse],
        useInMemoryDb ? ["--db-type", "in-memory"] : ["--db-path", tempDir],
        ["--min-gas-price", minGasPrice],
        ["--starting-gas-price", startingGasPrice],
        poaInstant ? ["--poa-instant", "true"] : [],
        ["--native-executor-version", nativeExecutorVersion],
        ["--consensus-key", consensusKey],
        ["--snapshot", snapshotDirToUse],
        "--vm-backtrace",
        "--utxo-validation",
        "--debug",
        ...remainingArgs
      ].flat(),
      { stdio: "pipe", detached: true }
    );
    if (loggingEnabled) {
      child.stderr.on("data", (chunk) => {
        console.log(chunk.toString());
      });
    }
    const removeChildListeners = /* @__PURE__ */ __name(() => {
      child.stderr.removeAllListeners();
    }, "removeChildListeners");
    const removeTempDir = /* @__PURE__ */ __name(() => {
      if (existsSync(tempDir)) {
        rmSync(tempDir, { recursive: true });
      }
    }, "removeTempDir");
    const childState = {
      isDead: false
    };
    const cleanup = /* @__PURE__ */ __name(() => {
      if (childState.isDead) {
        return;
      }
      childState.isDead = true;
      removeChildListeners();
      if (child.pid !== void 0) {
        try {
          process.kill(-child.pid);
        } catch (e) {
          const error = e;
          if (error.code === "ESRCH") {
            console.log(
              `fuel-core node under pid ${child.pid} does not exist. The node might have been killed before cleanup was called. Exiting cleanly.`
            );
          } else if (error.message.includes("pid must be a positive integer")) {
            process.kill(+child.pid);
          } else {
            throw e;
          }
        }
      } else {
        console.error("No PID available for the child process, unable to kill launched node");
      }
      removeTempDir();
    }, "cleanup");
    child.stderr.on("data", (chunk) => {
      const text = typeof chunk === "string" ? chunk : chunk.toString();
      if (text.indexOf(graphQLStartSubstring) !== -1) {
        const rows = text.split("\n");
        const rowWithUrl = rows.find((row) => row.indexOf(graphQLStartSubstring) !== -1);
        const [realIp, realPort] = rowWithUrl.split(" ").at(-1).trim().split(":");
        resolve({
          cleanup,
          ip: realIp,
          port: realPort,
          url: `http://${realIp}:${realPort}/v1/graphql`,
          snapshotDir: snapshotDirToUse,
          pid: child.pid
        });
      }
      if (/error/i.test(text)) {
        console.log(text);
        reject(new FuelError(FuelError.CODES.NODE_LAUNCH_FAILED, text));
      }
    });
    process.setMaxListeners(100);
    process.on("exit", cleanup);
    process.on("SIGINT", cleanup);
    process.on("SIGUSR1", cleanup);
    process.on("SIGUSR2", cleanup);
    process.on("beforeExit", cleanup);
    process.on("uncaughtException", cleanup);
    child.on("exit", (code, _signal) => {
      removeChildListeners();
      removeTempDir();
      if (killProcessOnExit) {
        process.exit(code);
      }
    });
    child.on("error", (err) => {
      removeChildListeners();
      removeTempDir();
      reject(err);
    });
  })
), "launchNode");

// src/test-utils/setup-test-provider-and-wallets.ts
import { defaultSnapshotConfigs as defaultSnapshotConfigs3 } from "@fuel-ts/utils";
import { mergeDeepRight } from "ramda";

// src/providers/coin-quantity.ts
import { bn } from "@fuel-ts/math";
import { hexlify as hexlify3 } from "@fuel-ts/utils";
var coinQuantityfy = /* @__PURE__ */ __name((coinQuantityLike) => {
  let assetId;
  let amount;
  let max;
  if (Array.isArray(coinQuantityLike)) {
    amount = coinQuantityLike[0];
    assetId = coinQuantityLike[1];
    max = coinQuantityLike[2] ?? void 0;
  } else {
    amount = coinQuantityLike.amount;
    assetId = coinQuantityLike.assetId;
    max = coinQuantityLike.max ?? void 0;
  }
  return {
    assetId: hexlify3(assetId),
    amount: bn(amount),
    max: max ? bn(max) : void 0
  };
}, "coinQuantityfy");
var addAmountToCoinQuantities = /* @__PURE__ */ __name((params) => {
  const { amount, assetId } = params;
  const coinQuantities = [...params.coinQuantities];
  const assetIdx = coinQuantities.findIndex((coinQuantity) => coinQuantity.assetId === assetId);
  if (assetIdx !== -1) {
    coinQuantities[assetIdx].amount = coinQuantities[assetIdx].amount.add(amount);
  } else {
    coinQuantities.push({ assetId, amount });
  }
  return coinQuantities;
}, "addAmountToCoinQuantities");

// src/providers/provider.ts
import { Address as Address3, isB256 } from "@fuel-ts/address";
import { ErrorCode as ErrorCode17, FuelError as FuelError20 } from "@fuel-ts/errors";
import { bn as bn18 } from "@fuel-ts/math";
import { InputMessageCoder as InputMessageCoder2, TransactionCoder as TransactionCoder6, TransactionType as TransactionType11 } from "@fuel-ts/transactions";
import { arrayify as arrayify13, hexlify as hexlify19, DateTime as DateTime2, isDefined as isDefined3, sleep as sleep2 } from "@fuel-ts/utils";
import { checkFuelCoreVersionCompatibility, versions } from "@fuel-ts/versions";
import { GraphQLClient } from "graphql-request";
import gql2 from "graphql-tag";
import { clone as clone8 } from "ramda";

// src/providers/__generated__/operations.ts
import gql from "graphql-tag";
var InputCoinFragmentDoc = gql`
    fragment InputCoinFragment on InputCoin {
  type: __typename
  utxoId
  owner
  amount
  assetId
  txPointer
  coinWitnessIndex: witnessIndex
  predicateGasUsed
  predicate
  predicateData
}
    `;
var InputMessageFragmentDoc = gql`
    fragment InputMessageFragment on InputMessage {
  type: __typename
  sender
  recipient
  amount
  nonce
  messageWitnessIndex: witnessIndex
  predicateGasUsed
  data
  predicate
  predicateData
}
    `;
var InputContractFragmentDoc = gql`
    fragment InputContractFragment on InputContract {
  type: __typename
  utxoId
  balanceRoot
  stateRoot
  txPointer
  contractId
}
    `;
var OutputCoinFragmentDoc = gql`
    fragment OutputCoinFragment on CoinOutput {
  type: __typename
  to
  amount
  assetId
}
    `;
var OutputContractFragmentDoc = gql`
    fragment OutputContractFragment on ContractOutput {
  type: __typename
  inputIndex
  balanceRoot
  stateRoot
}
    `;
var OutputChangeFragmentDoc = gql`
    fragment OutputChangeFragment on ChangeOutput {
  type: __typename
  to
  amount
  assetId
}
    `;
var OutputVariableFragmentDoc = gql`
    fragment OutputVariableFragment on VariableOutput {
  type: __typename
  to
  amount
  assetId
}
    `;
var OutputContractCreatedFragmentDoc = gql`
    fragment OutputContractCreatedFragment on ContractCreated {
  type: __typename
  contract
  stateRoot
}
    `;
var SubmittedStatusFragmentDoc = gql`
    fragment SubmittedStatusFragment on SubmittedStatus {
  type: __typename
  time
}
    `;
var ReceiptFragmentDoc = gql`
    fragment receiptFragment on Receipt {
  id
  pc
  is
  to
  toAddress
  amount
  assetId
  gas
  param1
  param2
  val
  ptr
  digest
  reason
  ra
  rb
  rc
  rd
  len
  receiptType
  result
  gasUsed
  data
  sender
  recipient
  nonce
  contractId
  subId
}
    `;
var SuccessStatusFragmentDoc = gql`
    fragment SuccessStatusFragment on SuccessStatus {
  type: __typename
  time
  programState {
    returnType
    data
  }
  receipts {
    ...receiptFragment
  }
  totalGas
  totalFee
}
    ${ReceiptFragmentDoc}`;
var SuccessStatusWithBlockIdFragmentDoc = gql`
    fragment SuccessStatusWithBlockIdFragment on SuccessStatus {
  ...SuccessStatusFragment
  block {
    id
  }
}
    ${SuccessStatusFragmentDoc}`;
var MalleableTransactionFieldsFragmentDoc = gql`
    fragment malleableTransactionFieldsFragment on Transaction {
  receiptsRoot
  inputs {
    type: __typename
    ... on InputCoin {
      txPointer
    }
    ... on InputContract {
      txPointer
    }
  }
  outputs {
    type: __typename
    ... on CoinOutput {
      to
      amount
      assetId
    }
    ... on ContractOutput {
      inputIndex
      balanceRoot
      stateRoot
    }
    ... on ChangeOutput {
      to
      amount
      assetId
    }
    ... on VariableOutput {
      to
      amount
      assetId
    }
    ... on ContractCreated {
      contract
      stateRoot
    }
  }
}
    `;
var FailureStatusFragmentDoc = gql`
    fragment FailureStatusFragment on FailureStatus {
  type: __typename
  totalGas
  totalFee
  time
  reason
  receipts {
    ...receiptFragment
  }
}
    ${ReceiptFragmentDoc}`;
var FailureStatusWithBlockIdFragmentDoc = gql`
    fragment FailureStatusWithBlockIdFragment on FailureStatus {
  ...FailureStatusFragment
  block {
    id
  }
}
    ${FailureStatusFragmentDoc}`;
var SqueezedOutStatusFragmentDoc = gql`
    fragment SqueezedOutStatusFragment on SqueezedOutStatus {
  type: __typename
  reason
}
    `;
var PreconfirmationSuccessStatusFragmentDoc = gql`
    fragment PreconfirmationSuccessStatusFragment on PreconfirmationSuccessStatus {
  type: __typename
  totalGas
  totalFee
  resolvedOutputs {
    utxoId
    output {
      type: __typename
      ... on CoinOutput {
        to
        amount
        assetId
      }
      ... on ContractOutput {
        inputIndex
        balanceRoot
        stateRoot
      }
      ... on ChangeOutput {
        to
        amount
        assetId
      }
      ... on VariableOutput {
        to
        amount
        assetId
      }
      ... on ContractCreated {
        contract
        stateRoot
      }
    }
  }
  preconfirmationReceipts: receipts {
    ...receiptFragment
  }
}
    ${ReceiptFragmentDoc}`;
var PreconfirmationFailureStatusFragmentDoc = gql`
    fragment PreconfirmationFailureStatusFragment on PreconfirmationFailureStatus {
  type: __typename
  reason
  totalGas
  totalFee
  resolvedOutputs {
    utxoId
    output {
      type: __typename
      ... on CoinOutput {
        to
        amount
        assetId
      }
      ... on ContractOutput {
        inputIndex
        balanceRoot
        stateRoot
      }
      ... on ChangeOutput {
        to
        amount
        assetId
      }
      ... on VariableOutput {
        to
        amount
        assetId
      }
      ... on ContractCreated {
        contract
        stateRoot
      }
    }
  }
  preconfirmationReceipts: receipts {
    ...receiptFragment
  }
}
    ${ReceiptFragmentDoc}`;
var TransactionStatusSubscriptionFragmentDoc = gql`
    fragment transactionStatusSubscriptionFragment on TransactionStatus {
  ... on SubmittedStatus {
    ...SubmittedStatusFragment
  }
  ... on SuccessStatus {
    ...SuccessStatusWithBlockIdFragment
    transaction {
      ...malleableTransactionFieldsFragment
    }
  }
  ... on FailureStatus {
    ...FailureStatusWithBlockIdFragment
    transaction {
      ...malleableTransactionFieldsFragment
    }
  }
  ... on SqueezedOutStatus {
    ...SqueezedOutStatusFragment
  }
  ... on PreconfirmationSuccessStatus {
    ...PreconfirmationSuccessStatusFragment
  }
  ... on PreconfirmationFailureStatus {
    ...PreconfirmationFailureStatusFragment
  }
}
    ${SubmittedStatusFragmentDoc}
${SuccessStatusWithBlockIdFragmentDoc}
${MalleableTransactionFieldsFragmentDoc}
${FailureStatusWithBlockIdFragmentDoc}
${SqueezedOutStatusFragmentDoc}
${PreconfirmationSuccessStatusFragmentDoc}
${PreconfirmationFailureStatusFragmentDoc}`;
var TransactionStatusFragmentDoc = gql`
    fragment transactionStatusFragment on TransactionStatus {
  ... on SubmittedStatus {
    ...SubmittedStatusFragment
  }
  ... on SuccessStatus {
    ...SuccessStatusFragment
  }
  ... on FailureStatus {
    ...FailureStatusFragment
  }
  ... on SqueezedOutStatus {
    ...SqueezedOutStatusFragment
  }
}
    ${SubmittedStatusFragmentDoc}
${SuccessStatusFragmentDoc}
${FailureStatusFragmentDoc}
${SqueezedOutStatusFragmentDoc}`;
var TransactionFragmentDoc = gql`
    fragment transactionFragment on Transaction {
  id
  rawPayload
  status {
    ...transactionStatusFragment
  }
}
    ${TransactionStatusFragmentDoc}`;
var TransactionRawPayloadFragmentDoc = gql`
    fragment transactionRawPayloadFragment on Transaction {
  id
  rawPayload
}
    `;
var InputEstimatePredicatesFragmentDoc = gql`
    fragment inputEstimatePredicatesFragment on Input {
  ... on InputCoin {
    predicateGasUsed
  }
  ... on InputMessage {
    predicateGasUsed
  }
}
    `;
var TransactionEstimatePredicatesFragmentDoc = gql`
    fragment transactionEstimatePredicatesFragment on Transaction {
  inputs {
    ...inputEstimatePredicatesFragment
  }
}
    ${InputEstimatePredicatesFragmentDoc}`;
var DryRunFailureAssembleTxFragmentDoc = gql`
    fragment dryRunFailureAssembleTxFragment on DryRunFailureStatus {
  type: __typename
  reason
  receipts {
    ...receiptFragment
  }
}
    ${ReceiptFragmentDoc}`;
var DryRunSuccessAssembleTxFragmentDoc = gql`
    fragment dryRunSuccessAssembleTxFragment on DryRunSuccessStatus {
  type: __typename
  receipts {
    ...receiptFragment
  }
}
    ${ReceiptFragmentDoc}`;
var DryRunFailureStatusFragmentDoc = gql`
    fragment dryRunFailureStatusFragment on DryRunFailureStatus {
  type: __typename
  totalGas
  totalFee
  reason
  programState {
    returnType
    data
  }
}
    `;
var DryRunSuccessStatusFragmentDoc = gql`
    fragment dryRunSuccessStatusFragment on DryRunSuccessStatus {
  type: __typename
  totalGas
  totalFee
  programState {
    returnType
    data
  }
}
    `;
var DryRunTransactionStatusFragmentDoc = gql`
    fragment dryRunTransactionStatusFragment on DryRunTransactionStatus {
  ... on DryRunFailureStatus {
    ...dryRunFailureStatusFragment
  }
  ... on DryRunSuccessStatus {
    ...dryRunSuccessStatusFragment
  }
}
    ${DryRunFailureStatusFragmentDoc}
${DryRunSuccessStatusFragmentDoc}`;
var DryRunTransactionExecutionStatusFragmentDoc = gql`
    fragment dryRunTransactionExecutionStatusFragment on DryRunTransactionExecutionStatus {
  id
  status {
    ...dryRunTransactionStatusFragment
  }
  receipts {
    ...receiptFragment
  }
}
    ${DryRunTransactionStatusFragmentDoc}
${ReceiptFragmentDoc}`;
var BlockFragmentDoc = gql`
    fragment blockFragment on Block {
  id
  height
  header {
    time
    daHeight
    stateTransitionBytecodeVersion
    transactionsCount
    transactionsRoot
    messageOutboxRoot
    eventInboxRoot
    prevRoot
    applicationHash
  }
  transactions {
    id
  }
}
    `;
var CoinFragmentDoc = gql`
    fragment coinFragment on Coin {
  type: __typename
  utxoId
  amount
  assetId
  blockCreated
  txCreatedIdx
}
    `;
var MessageCoinFragmentDoc = gql`
    fragment messageCoinFragment on MessageCoin {
  type: __typename
  sender
  recipient
  nonce
  amount
  assetId
  daHeight
}
    `;
var MessageFragmentDoc = gql`
    fragment messageFragment on Message {
  amount
  sender
  recipient
  data
  daHeight
}
    `;
var GetMessageFragmentDoc = gql`
    fragment getMessageFragment on Message {
  ...messageFragment
  nonce
}
    ${MessageFragmentDoc}`;
var MessageProofFragmentDoc = gql`
    fragment messageProofFragment on MessageProof {
  messageProof {
    proofSet
    proofIndex
  }
  blockProof {
    proofSet
    proofIndex
  }
  messageBlockHeader {
    version
    id
    daHeight
    consensusParametersVersion
    stateTransitionBytecodeVersion
    transactionsCount
    messageReceiptCount
    transactionsRoot
    messageOutboxRoot
    eventInboxRoot
    height
    prevRoot
    time
    applicationHash
  }
  commitBlockHeader {
    version
    id
    daHeight
    consensusParametersVersion
    stateTransitionBytecodeVersion
    transactionsCount
    messageReceiptCount
    transactionsRoot
    messageOutboxRoot
    eventInboxRoot
    height
    prevRoot
    time
    applicationHash
  }
  sender
  recipient
  amount
  data
}
    `;
var TxParametersFragmentDoc = gql`
    fragment TxParametersFragment on TxParameters {
  version
  maxInputs
  maxOutputs
  maxWitnesses
  maxGasPerTx
  maxSize
  maxBytecodeSubsections
}
    `;
var PredicateParametersFragmentDoc = gql`
    fragment PredicateParametersFragment on PredicateParameters {
  version
  maxPredicateLength
  maxPredicateDataLength
  maxGasPerPredicate
  maxMessageDataLength
}
    `;
var ScriptParametersFragmentDoc = gql`
    fragment ScriptParametersFragment on ScriptParameters {
  version
  maxScriptLength
  maxScriptDataLength
}
    `;
var ContractParametersFragmentDoc = gql`
    fragment ContractParametersFragment on ContractParameters {
  version
  contractMaxSize
  maxStorageSlots
}
    `;
var FeeParametersFragmentDoc = gql`
    fragment FeeParametersFragment on FeeParameters {
  version
  gasPriceFactor
  gasPerByte
}
    `;
var DependentCostFragmentDoc = gql`
    fragment DependentCostFragment on DependentCost {
  ... on LightOperation {
    type: __typename
    base
    unitsPerGas
  }
  ... on HeavyOperation {
    type: __typename
    base
    gasPerUnit
  }
}
    `;
var GasCostsFragmentDoc = gql`
    fragment GasCostsFragment on GasCosts {
  contractRoot {
    ...DependentCostFragment
  }
  stateRoot {
    ...DependentCostFragment
  }
  vmInitialization {
    ...DependentCostFragment
  }
  s256 {
    ...DependentCostFragment
  }
  ecr1
  newStoragePerByte
}
    ${DependentCostFragmentDoc}`;
var ConsensusParametersFragmentDoc = gql`
    fragment consensusParametersFragment on ConsensusParameters {
  version
  txParams {
    ...TxParametersFragment
  }
  predicateParams {
    ...PredicateParametersFragment
  }
  scriptParams {
    ...ScriptParametersFragment
  }
  contractParams {
    ...ContractParametersFragment
  }
  feeParams {
    ...FeeParametersFragment
  }
  gasCosts {
    ...GasCostsFragment
  }
  baseAssetId
  chainId
}
    ${TxParametersFragmentDoc}
${PredicateParametersFragmentDoc}
${ScriptParametersFragmentDoc}
${ContractParametersFragmentDoc}
${FeeParametersFragmentDoc}
${GasCostsFragmentDoc}`;
var ChainInfoFragmentDoc = gql`
    fragment chainInfoFragment on ChainInfo {
  name
  daHeight
  consensusParameters {
    ...consensusParametersFragment
  }
  latestBlock {
    header {
      consensusParametersVersion
    }
  }
}
    ${ConsensusParametersFragmentDoc}`;
var ContractBalanceFragmentDoc = gql`
    fragment contractBalanceFragment on ContractBalance {
  contract
  amount
  assetId
}
    `;
var PageInfoFragmentDoc = gql`
    fragment pageInfoFragment on PageInfo {
  hasPreviousPage
  hasNextPage
  startCursor
  endCursor
}
    `;
var NodeInfoFragmentDoc = gql`
    fragment nodeInfoFragment on NodeInfo {
  utxoValidation
  vmBacktrace
  maxTx
  maxDepth
  nodeVersion
  indexation {
    balances
    coinsToSpend
    assetMetadata
  }
}
    `;
var RelayedTransactionStatusFragmentDoc = gql`
    fragment relayedTransactionStatusFragment on RelayedTransactionStatus {
  ... on RelayedTransactionFailed {
    blockHeight
    failure
  }
}
    `;
var GetVersionDocument = gql`
    query getVersion {
  nodeInfo {
    nodeVersion
  }
}
    `;
var GetNodeInfoDocument = gql`
    query getNodeInfo {
  nodeInfo {
    ...nodeInfoFragment
  }
}
    ${NodeInfoFragmentDoc}`;
var GetChainDocument = gql`
    query getChain {
  chain {
    ...chainInfoFragment
  }
}
    ${ChainInfoFragmentDoc}`;
var GetChainAndNodeInfoDocument = gql`
    query getChainAndNodeInfo {
  chain {
    ...chainInfoFragment
  }
  nodeInfo {
    ...nodeInfoFragment
  }
}
    ${ChainInfoFragmentDoc}
${NodeInfoFragmentDoc}`;
var GetTransactionDocument = gql`
    query getTransaction($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    ...transactionFragment
  }
}
    ${TransactionFragmentDoc}`;
var GetTransactionWithReceiptsDocument = gql`
    query getTransactionWithReceipts($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    id
    rawPayload
    status {
      ... on SubmittedStatus {
        ...SubmittedStatusFragment
      }
      ... on SuccessStatus {
        ...SuccessStatusWithBlockIdFragment
      }
      ... on FailureStatus {
        ...FailureStatusWithBlockIdFragment
      }
      ... on SqueezedOutStatus {
        ...SqueezedOutStatusFragment
      }
      ... on PreconfirmationSuccessStatus {
        ...PreconfirmationSuccessStatusFragment
      }
      ... on PreconfirmationFailureStatus {
        ...PreconfirmationFailureStatusFragment
      }
    }
  }
}
    ${SubmittedStatusFragmentDoc}
${SuccessStatusWithBlockIdFragmentDoc}
${FailureStatusWithBlockIdFragmentDoc}
${SqueezedOutStatusFragmentDoc}
${PreconfirmationSuccessStatusFragmentDoc}
${PreconfirmationFailureStatusFragmentDoc}`;
var GetTransactionsDocument = gql`
    query getTransactions($after: String, $before: String, $first: Int, $last: Int) {
  transactions(after: $after, before: $before, first: $first, last: $last) {
    edges {
      node {
        rawPayload
      }
    }
    pageInfo {
      ...pageInfoFragment
    }
  }
}
    ${PageInfoFragmentDoc}`;
var GetTransactionsByOwnerDocument = gql`
    query getTransactionsByOwner($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  transactionsByOwner(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...transactionFragment
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${TransactionFragmentDoc}`;
var EstimatePredicatesDocument = gql`
    query estimatePredicates($encodedTransaction: HexString!) {
  estimatePredicates(tx: $encodedTransaction) {
    ...transactionEstimatePredicatesFragment
  }
}
    ${TransactionEstimatePredicatesFragmentDoc}`;
var EstimatePredicatesAndGasPriceDocument = gql`
    query estimatePredicatesAndGasPrice($encodedTransaction: HexString!, $blockHorizon: U32!) {
  estimatePredicates(tx: $encodedTransaction) {
    ...transactionEstimatePredicatesFragment
  }
  estimateGasPrice(blockHorizon: $blockHorizon) {
    gasPrice
  }
}
    ${TransactionEstimatePredicatesFragmentDoc}`;
var GetLatestBlockDocument = gql`
    query getLatestBlock {
  chain {
    latestBlock {
      ...blockFragment
    }
  }
}
    ${BlockFragmentDoc}`;
var GetLatestBlockHeightDocument = gql`
    query getLatestBlockHeight {
  chain {
    latestBlock {
      height
    }
  }
}
    `;
var GetBlockDocument = gql`
    query getBlock($blockId: BlockId, $height: U32) {
  block(id: $blockId, height: $height) {
    ...blockFragment
  }
}
    ${BlockFragmentDoc}`;
var GetBlockWithTransactionsDocument = gql`
    query getBlockWithTransactions($blockId: BlockId, $blockHeight: U32) {
  block(id: $blockId, height: $blockHeight) {
    ...blockFragment
    transactions {
      ...transactionRawPayloadFragment
    }
  }
}
    ${BlockFragmentDoc}
${TransactionRawPayloadFragmentDoc}`;
var GetBlocksDocument = gql`
    query getBlocks($after: String, $before: String, $first: Int, $last: Int) {
  blocks(after: $after, before: $before, first: $first, last: $last) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...blockFragment
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${BlockFragmentDoc}`;
var GetCoinDocument = gql`
    query getCoin($coinId: UtxoId!) {
  coin(utxoId: $coinId) {
    ...coinFragment
    owner
  }
}
    ${CoinFragmentDoc}`;
var GetCoinsDocument = gql`
    query getCoins($filter: CoinFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  coins(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...coinFragment
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${CoinFragmentDoc}`;
var GetCoinsToSpendDocument = gql`
    query getCoinsToSpend($owner: Address!, $queryPerAsset: [SpendQueryElementInput!]!, $excludedIds: ExcludeInput) {
  coinsToSpend(
    owner: $owner
    queryPerAsset: $queryPerAsset
    excludedIds: $excludedIds
  ) {
    ...coinFragment
    ...messageCoinFragment
  }
}
    ${CoinFragmentDoc}
${MessageCoinFragmentDoc}`;
var GetContractDocument = gql`
    query getContract($contractId: ContractId!) {
  contract(id: $contractId) {
    bytecode
    id
  }
}
    `;
var GetContractBalanceDocument = gql`
    query getContractBalance($contract: ContractId!, $asset: AssetId!) {
  contractBalance(contract: $contract, asset: $asset) {
    ...contractBalanceFragment
  }
}
    ${ContractBalanceFragmentDoc}`;
var GetBalanceDocument = gql`
    query getBalance($owner: Address!, $assetId: AssetId!) {
  balance(owner: $owner, assetId: $assetId) {
    amount
  }
}
    `;
var GetBalanceV2Document = gql`
    query getBalanceV2($owner: Address!, $assetId: AssetId!) {
  balance(owner: $owner, assetId: $assetId) {
    amountU128
  }
}
    `;
var GetLatestGasPriceDocument = gql`
    query getLatestGasPrice {
  latestGasPrice {
    gasPrice
  }
}
    `;
var EstimateGasPriceDocument = gql`
    query estimateGasPrice($blockHorizon: U32!) {
  estimateGasPrice(blockHorizon: $blockHorizon) {
    gasPrice
  }
}
    `;
var GetBalancesDocument = gql`
    query getBalances($filter: BalanceFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  balances(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    edges {
      node {
        assetId
        amount
      }
    }
  }
}
    `;
var GetBalancesV2Document = gql`
    query getBalancesV2($filter: BalanceFilterInput!, $after: String, $before: String, $first: Int, $last: Int, $supportsPagination: Boolean!) {
  balances(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo @include(if: $supportsPagination) {
      ...pageInfoFragment
    }
    edges {
      node {
        assetId
        amountU128
      }
    }
  }
}
    ${PageInfoFragmentDoc}`;
var GetMessagesDocument = gql`
    query getMessages($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  messages(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...getMessageFragment
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${GetMessageFragmentDoc}`;
var DaCompressedBlockDocument = gql`
    query daCompressedBlock($height: U32!) {
  daCompressedBlock(height: $height) {
    bytes
  }
}
    `;
var GetMessageProofDocument = gql`
    query getMessageProof($transactionId: TransactionId!, $nonce: Nonce!, $commitBlockId: BlockId, $commitBlockHeight: U32) {
  messageProof(
    transactionId: $transactionId
    nonce: $nonce
    commitBlockId: $commitBlockId
    commitBlockHeight: $commitBlockHeight
  ) {
    ...messageProofFragment
  }
}
    ${MessageProofFragmentDoc}`;
var GetMessageStatusDocument = gql`
    query getMessageStatus($nonce: Nonce!) {
  messageStatus(nonce: $nonce) {
    state
  }
}
    `;
var GetRelayedTransactionStatusDocument = gql`
    query getRelayedTransactionStatus($relayedTransactionId: RelayedTransactionId!) {
  relayedTransactionStatus(id: $relayedTransactionId) {
    ...relayedTransactionStatusFragment
  }
}
    ${RelayedTransactionStatusFragmentDoc}`;
var GetAssetDetailsDocument = gql`
    query getAssetDetails($assetId: AssetId!) {
  assetDetails(id: $assetId) {
    subId
    contractId
    totalSupply
  }
}
    `;
var AssembleTxDocument = gql`
    query assembleTx($tx: HexString!, $blockHorizon: U32!, $requiredBalances: [RequiredBalance!]!, $feeAddressIndex: U16!, $excludeInput: ExcludeInput, $estimatePredicates: Boolean, $reserveGas: U64) {
  assembleTx(
    tx: $tx
    blockHorizon: $blockHorizon
    requiredBalances: $requiredBalances
    feeAddressIndex: $feeAddressIndex
    excludeInput: $excludeInput
    estimatePredicates: $estimatePredicates
    reserveGas: $reserveGas
  ) {
    transaction {
      id
      inputs {
        ... on InputCoin {
          ...InputCoinFragment
        }
        ... on InputContract {
          ...InputContractFragment
        }
        ... on InputMessage {
          ...InputMessageFragment
        }
      }
      outputs {
        ... on CoinOutput {
          ...OutputCoinFragment
        }
        ... on ContractOutput {
          ...OutputContractFragment
        }
        ... on ChangeOutput {
          ...OutputChangeFragment
        }
        ... on VariableOutput {
          ...OutputVariableFragment
        }
        ... on ContractCreated {
          ...OutputContractCreatedFragment
        }
      }
      policies {
        tip
        witnessLimit
        maturity
        maxFee
      }
      witnesses
      scriptGasLimit
    }
    status {
      ... on DryRunFailureStatus {
        ...dryRunFailureAssembleTxFragment
      }
      ... on DryRunSuccessStatus {
        ...dryRunSuccessAssembleTxFragment
      }
    }
    gasPrice
  }
}
    ${InputCoinFragmentDoc}
${InputContractFragmentDoc}
${InputMessageFragmentDoc}
${OutputCoinFragmentDoc}
${OutputContractFragmentDoc}
${OutputChangeFragmentDoc}
${OutputVariableFragmentDoc}
${OutputContractCreatedFragmentDoc}
${DryRunFailureAssembleTxFragmentDoc}
${DryRunSuccessAssembleTxFragmentDoc}`;
var DryRunDocument = gql`
    query dryRun($encodedTransactions: [HexString!]!, $utxoValidation: Boolean, $gasPrice: U64) {
  dryRun(
    txs: $encodedTransactions
    utxoValidation: $utxoValidation
    gasPrice: $gasPrice
  ) {
    ...dryRunTransactionExecutionStatusFragment
  }
}
    ${DryRunTransactionExecutionStatusFragmentDoc}`;
var SubmitDocument = gql`
    mutation submit($encodedTransaction: HexString!) {
  submit(tx: $encodedTransaction) {
    id
  }
}
    `;
var ProduceBlocksDocument = gql`
    mutation produceBlocks($startTimestamp: Tai64Timestamp, $blocksToProduce: U32!) {
  produceBlocks(
    blocksToProduce: $blocksToProduce
    startTimestamp: $startTimestamp
  )
}
    `;
var GetMessageByNonceDocument = gql`
    query getMessageByNonce($nonce: Nonce!) {
  message(nonce: $nonce) {
    ...messageFragment
  }
}
    ${MessageFragmentDoc}`;
var IsUserAccountDocument = gql`
    query isUserAccount($blobId: BlobId!, $contractId: ContractId!, $transactionId: TransactionId!) {
  blob(id: $blobId) {
    id
  }
  contract(id: $contractId) {
    id
  }
  transaction(id: $transactionId) {
    id
  }
}
    `;
var GetConsensusParametersVersionDocument = gql`
    query getConsensusParametersVersion {
  chain {
    latestBlock {
      header {
        consensusParametersVersion
      }
    }
  }
}
    `;
var SubmitAndAwaitStatusDocument = gql`
    subscription submitAndAwaitStatus($encodedTransaction: HexString!, $estimatePredicates: Boolean, $includePreConfirmation: Boolean) {
  submitAndAwaitStatus(
    tx: $encodedTransaction
    estimatePredicates: $estimatePredicates
    includePreconfirmation: $includePreConfirmation
  ) {
    ...transactionStatusSubscriptionFragment
  }
}
    ${TransactionStatusSubscriptionFragmentDoc}`;
var StatusChangeDocument = gql`
    subscription statusChange($transactionId: TransactionId!, $includePreConfirmation: Boolean) {
  statusChange(
    id: $transactionId
    includePreconfirmation: $includePreConfirmation
  ) {
    ...transactionStatusSubscriptionFragment
  }
}
    ${TransactionStatusSubscriptionFragmentDoc}`;
function getSdk(requester) {
  return {
    getVersion(variables, options) {
      return requester(GetVersionDocument, variables, options);
    },
    getNodeInfo(variables, options) {
      return requester(GetNodeInfoDocument, variables, options);
    },
    getChain(variables, options) {
      return requester(GetChainDocument, variables, options);
    },
    getChainAndNodeInfo(variables, options) {
      return requester(GetChainAndNodeInfoDocument, variables, options);
    },
    getTransaction(variables, options) {
      return requester(GetTransactionDocument, variables, options);
    },
    getTransactionWithReceipts(variables, options) {
      return requester(GetTransactionWithReceiptsDocument, variables, options);
    },
    getTransactions(variables, options) {
      return requester(GetTransactionsDocument, variables, options);
    },
    getTransactionsByOwner(variables, options) {
      return requester(GetTransactionsByOwnerDocument, variables, options);
    },
    estimatePredicates(variables, options) {
      return requester(EstimatePredicatesDocument, variables, options);
    },
    estimatePredicatesAndGasPrice(variables, options) {
      return requester(EstimatePredicatesAndGasPriceDocument, variables, options);
    },
    getLatestBlock(variables, options) {
      return requester(GetLatestBlockDocument, variables, options);
    },
    getLatestBlockHeight(variables, options) {
      return requester(GetLatestBlockHeightDocument, variables, options);
    },
    getBlock(variables, options) {
      return requester(GetBlockDocument, variables, options);
    },
    getBlockWithTransactions(variables, options) {
      return requester(GetBlockWithTransactionsDocument, variables, options);
    },
    getBlocks(variables, options) {
      return requester(GetBlocksDocument, variables, options);
    },
    getCoin(variables, options) {
      return requester(GetCoinDocument, variables, options);
    },
    getCoins(variables, options) {
      return requester(GetCoinsDocument, variables, options);
    },
    getCoinsToSpend(variables, options) {
      return requester(GetCoinsToSpendDocument, variables, options);
    },
    getContract(variables, options) {
      return requester(GetContractDocument, variables, options);
    },
    getContractBalance(variables, options) {
      return requester(GetContractBalanceDocument, variables, options);
    },
    getBalance(variables, options) {
      return requester(GetBalanceDocument, variables, options);
    },
    getBalanceV2(variables, options) {
      return requester(GetBalanceV2Document, variables, options);
    },
    getLatestGasPrice(variables, options) {
      return requester(GetLatestGasPriceDocument, variables, options);
    },
    estimateGasPrice(variables, options) {
      return requester(EstimateGasPriceDocument, variables, options);
    },
    getBalances(variables, options) {
      return requester(GetBalancesDocument, variables, options);
    },
    getBalancesV2(variables, options) {
      return requester(GetBalancesV2Document, variables, options);
    },
    getMessages(variables, options) {
      return requester(GetMessagesDocument, variables, options);
    },
    daCompressedBlock(variables, options) {
      return requester(DaCompressedBlockDocument, variables, options);
    },
    getMessageProof(variables, options) {
      return requester(GetMessageProofDocument, variables, options);
    },
    getMessageStatus(variables, options) {
      return requester(GetMessageStatusDocument, variables, options);
    },
    getRelayedTransactionStatus(variables, options) {
      return requester(GetRelayedTransactionStatusDocument, variables, options);
    },
    getAssetDetails(variables, options) {
      return requester(GetAssetDetailsDocument, variables, options);
    },
    assembleTx(variables, options) {
      return requester(AssembleTxDocument, variables, options);
    },
    dryRun(variables, options) {
      return requester(DryRunDocument, variables, options);
    },
    submit(variables, options) {
      return requester(SubmitDocument, variables, options);
    },
    produceBlocks(variables, options) {
      return requester(ProduceBlocksDocument, variables, options);
    },
    getMessageByNonce(variables, options) {
      return requester(GetMessageByNonceDocument, variables, options);
    },
    isUserAccount(variables, options) {
      return requester(IsUserAccountDocument, variables, options);
    },
    getConsensusParametersVersion(variables, options) {
      return requester(GetConsensusParametersVersionDocument, variables, options);
    },
    submitAndAwaitStatus(variables, options) {
      return requester(SubmitAndAwaitStatusDocument, variables, options);
    },
    statusChange(variables, options) {
      return requester(StatusChangeDocument, variables, options);
    }
  };
}
__name(getSdk, "getSdk");

// src/providers/assemble-tx-helpers.ts
import { FuelError as FuelError2, ErrorCode } from "@fuel-ts/errors";
import { bn as bn2 } from "@fuel-ts/math";
import { TransactionType } from "@fuel-ts/transactions";
import { hexlify as hexlify4, isDefined } from "@fuel-ts/utils";
var resolveAccountForAssembleTxParams = /* @__PURE__ */ __name((account) => {
  const assembleTxAccount = {};
  const accountIsPredicate = "bytes" in account;
  if (accountIsPredicate) {
    assembleTxAccount.predicate = {
      predicate: hexlify4(account.bytes),
      predicateAddress: account.address.toB256(),
      predicateData: hexlify4(account.getPredicateData())
    };
  } else {
    assembleTxAccount.address = account.address.toB256();
  }
  return assembleTxAccount;
}, "resolveAccountForAssembleTxParams");
var setAndValidateGasAndFeeForAssembledTx = /* @__PURE__ */ __name(async (params) => {
  const { gasPrice, transactionRequest, setGasLimit, setMaxFee, provider } = params;
  const gasLimitSpecified = isDefined(setGasLimit);
  const maxFeeSpecified = isDefined(setMaxFee);
  const isScriptTx = transactionRequest.type === TransactionType.Script;
  if (gasLimitSpecified && isScriptTx) {
    const requiredGasLimit = transactionRequest.gasLimit;
    if (bn2(setGasLimit).lt(bn2(requiredGasLimit))) {
      throw new FuelError2(
        ErrorCode.GAS_LIMIT_TOO_LOW,
        `Gas limit '${setGasLimit}' is lower than the required: '${requiredGasLimit}'.`
      );
    }
    transactionRequest.gasLimit = bn2(setGasLimit);
  }
  if (maxFeeSpecified) {
    const requiredMaxFee = transactionRequest.maxFee;
    if (bn2(setMaxFee).lt(requiredMaxFee)) {
      throw new FuelError2(
        ErrorCode.MAX_FEE_TOO_LOW,
        `Max fee '${setMaxFee}' is lower than the required: '${requiredMaxFee}'.`
      );
    }
    transactionRequest.maxFee = bn2(setMaxFee);
  }
  if (gasLimitSpecified && !maxFeeSpecified) {
    const { maxFee: feeForGasPrice } = await provider.estimateTxGasAndFee({
      transactionRequest,
      gasPrice
    });
    transactionRequest.maxFee = feeForGasPrice;
  }
  return transactionRequest;
}, "setAndValidateGasAndFeeForAssembledTx");

// src/providers/fuel-graphql-subscriber.ts
import { ErrorCode as ErrorCode3, FuelError as FuelError4 } from "@fuel-ts/errors";
import { print } from "graphql";

// src/providers/utils/handle-gql-error-message.ts
import { ErrorCode as ErrorCode2, FuelError as FuelError3 } from "@fuel-ts/errors";
var gqlErrorMessage = {
  RPC_CONSISTENCY: /The required fuel block height is higher than the current block height. Required: \d+, Current: \d+/,
  NOT_ENOUGH_COINS_MAX_COINS: /the target cannot be met due to no coins available or exceeding the \d+ coin limit./,
  ASSET_NOT_FOUND: /resource was not found in table/,
  MULTIPLE_CHANGE_POLICIES: /The asset ([a-fA-F0-9]{64}) has multiple change policies/,
  DUPLICATE_CHANGE_OUTPUT_ACCOUNT: /required balances contain duplicate \(asset, account\) pair/,
  INSUFFICIENT_FEE_AMOUNT: /InsufficientFeeAmount { expected: (\d+), provided: (\d+) }/
};
var mapGqlErrorMessage = /* @__PURE__ */ __name((error) => {
  if (gqlErrorMessage.NOT_ENOUGH_COINS_MAX_COINS.test(error.message)) {
    return new FuelError3(
      ErrorCode2.INSUFFICIENT_FUNDS_OR_MAX_COINS,
      `Insufficient funds or too many small value coins. Consider combining UTXOs.`,
      {},
      error
    );
  }
  if (gqlErrorMessage.MULTIPLE_CHANGE_POLICIES.test(error.message)) {
    const match = error.message.match(/asset ([a-fA-F0-9]{64})/);
    const assetId = match?.[1] || "";
    return new FuelError3(
      ErrorCode2.CHANGE_OUTPUT_COLLISION,
      `OutputChange address for asset 0x${assetId} differs between transaction request and assembleTx parameters.`,
      {},
      error
    );
  }
  if (gqlErrorMessage.DUPLICATE_CHANGE_OUTPUT_ACCOUNT.test(error.message)) {
    return new FuelError3(
      ErrorCode2.DUPLICATE_CHANGE_OUTPUT_ACCOUNT,
      `The parameter 'accountCoinQuantities' of assembleTx contains duplicate entries for the same assetId with different 'changeOutputAccount'.`,
      {},
      error
    );
  }
  if (gqlErrorMessage.ASSET_NOT_FOUND.test(error.message)) {
    return new FuelError3(
      ErrorCode2.ASSET_NOT_FOUND,
      `Asset not found for given asset id.`,
      {},
      error
    );
  }
  if (gqlErrorMessage.RPC_CONSISTENCY.test(error.message)) {
    return new FuelError3(ErrorCode2.RPC_CONSISTENCY, error.message, {}, error);
  }
  if (gqlErrorMessage.INSUFFICIENT_FEE_AMOUNT.test(error.message)) {
    const match = error.message.match(gqlErrorMessage.INSUFFICIENT_FEE_AMOUNT);
    return new FuelError3(ErrorCode2.FUNDS_TOO_LOW, match?.[0] || error.message, {}, error);
  }
  return new FuelError3(ErrorCode2.INVALID_REQUEST, error.message, {}, error);
}, "mapGqlErrorMessage");
var mapGqlErrorWithIncompatibleNodeVersion = /* @__PURE__ */ __name((error, incompatibleNodeVersionMessage) => {
  if (!incompatibleNodeVersionMessage) {
    return error;
  }
  return new FuelError3(
    error.code,
    `${error.message}

${incompatibleNodeVersionMessage}`,
    error.metadata,
    error.rawError
  );
}, "mapGqlErrorWithIncompatibleNodeVersion");
var assertGqlResponseHasNoErrors = /* @__PURE__ */ __name((errors, incompatibleNodeVersionMessage = false) => {
  if (!Array.isArray(errors)) {
    return;
  }
  const mappedErrors = errors.map(mapGqlErrorMessage);
  if (mappedErrors.length === 1) {
    throw mapGqlErrorWithIncompatibleNodeVersion(mappedErrors[0], incompatibleNodeVersionMessage);
  }
  const errorMessage = mappedErrors.map((err) => err.message).join("\n");
  throw mapGqlErrorWithIncompatibleNodeVersion(
    new FuelError3(ErrorCode2.INVALID_REQUEST, errorMessage, {}, mappedErrors),
    incompatibleNodeVersionMessage
  );
}, "assertGqlResponseHasNoErrors");

// src/providers/fuel-graphql-subscriber.ts
var FuelGraphqlSubscriber = class _FuelGraphqlSubscriber {
  constructor(stream, onEvent) {
    this.stream = stream;
    this.onEvent = onEvent;
  }
  static {
    __name(this, "FuelGraphqlSubscriber");
  }
  static incompatibleNodeVersionMessage = false;
  static textDecoder = new TextDecoder();
  static async create(options) {
    const { url, query, variables, fetchFn, operationName, onEvent } = options;
    const response = await fetchFn(`${url}-sub`, {
      method: "POST",
      body: JSON.stringify({
        query: print(query),
        variables,
        operationName
      }),
      headers: {
        "Content-Type": "application/json",
        Accept: "text/event-stream"
      }
    });
    const [errorReader, resultReader] = response.body.tee().map((stream) => stream.getReader());
    await new _FuelGraphqlSubscriber(errorReader).next();
    return new _FuelGraphqlSubscriber(resultReader, onEvent);
  }
  /**
   * This method will take a stream reader and parse the event from the stream.
   *
   * @param reader - The reader of the SSE stream
   * @param parsingLeftover - The leftover string from parsing the previous event
   * @returns The event parsed as a full GraphQL response, whether the stream is done and the leftover string after parsing
   */
  static async readEvent(reader, parsingLeftover = "") {
    let text = parsingLeftover;
    const regex = /data:.*\n\n/g;
    while (true) {
      const matches = [...text.matchAll(regex)].flatMap((match) => match);
      if (matches.length > 0) {
        try {
          const event = JSON.parse(matches[0].replace(/^data:/, ""));
          return {
            event,
            done: false,
            parsingLeftover: text.replace(matches[0], "")
          };
        } catch (e) {
          throw new FuelError4(
            ErrorCode3.STREAM_PARSING_ERROR,
            `Error while parsing stream data response: ${text}`
          );
        }
      }
      const { value, done } = await reader.read();
      if (done) {
        return { event: void 0, done, parsingLeftover: "" };
      }
      const decoded = _FuelGraphqlSubscriber.textDecoder.decode(value).replace(":keep-alive-text\n\n", "");
      text += decoded;
    }
  }
  events = [];
  parsingLeftover = "";
  /**
   * Gets automatically called when iterating in a `for-await-of` loop.
   * It can also be called manually.
   *
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/next
   */
  async next() {
    while (true) {
      const nextEvent = this.events.shift();
      if (nextEvent) {
        this.onEvent?.(nextEvent);
        assertGqlResponseHasNoErrors(
          nextEvent.errors,
          _FuelGraphqlSubscriber.incompatibleNodeVersionMessage
        );
        return { value: nextEvent.data, done: false };
      }
      const { event, done, parsingLeftover } = await _FuelGraphqlSubscriber.readEvent(
        this.stream,
        this.parsingLeftover
      );
      this.parsingLeftover = parsingLeftover;
      if (done) {
        return { value: void 0, done: true };
      }
      this.events.push(event);
    }
  }
  /**
   * Gets called when `break` is called in a `for-await-of` loop.
   */
  return() {
    return Promise.resolve({ done: true, value: void 0 });
  }
  [Symbol.asyncIterator]() {
    return this;
  }
};

// src/providers/resource-cache.ts
import { FuelError as FuelError14, ErrorCode as ErrorCode11 } from "@fuel-ts/errors";
import { hexlify as hexlify17 } from "@fuel-ts/utils";

// src/providers/transaction-request/input.ts
import { BYTES_32 as BYTES_322, UTXO_ID_LEN } from "@fuel-ts/abi-coder";
import { ZeroBytes32 } from "@fuel-ts/address/configs";
import { ErrorCode as ErrorCode4, FuelError as FuelError5 } from "@fuel-ts/errors";
import { bn as bn3, toNumber } from "@fuel-ts/math";
import { InputType } from "@fuel-ts/transactions";
import { arrayify as arrayify2, hexlify as hexlify5 } from "@fuel-ts/utils";
var inputify = /* @__PURE__ */ __name((value) => {
  const { type } = value;
  switch (value.type) {
    case InputType.Coin: {
      const predicate = arrayify2(value.predicate ?? "0x");
      const predicateData = arrayify2(value.predicateData ?? "0x");
      return {
        type: InputType.Coin,
        txID: hexlify5(arrayify2(value.id).slice(0, BYTES_322)),
        outputIndex: toNumber(arrayify2(value.id).slice(BYTES_322, UTXO_ID_LEN)),
        owner: hexlify5(value.owner),
        amount: bn3(value.amount),
        assetId: hexlify5(value.assetId),
        txPointer: {
          blockHeight: toNumber(arrayify2(value.txPointer).slice(0, 8)),
          txIndex: toNumber(arrayify2(value.txPointer).slice(8, 16))
        },
        witnessIndex: value.witnessIndex,
        predicateGasUsed: bn3(value.predicateGasUsed),
        predicateLength: bn3(predicate.length),
        predicateDataLength: bn3(predicateData.length),
        predicate: hexlify5(predicate),
        predicateData: hexlify5(predicateData)
      };
    }
    case InputType.Contract: {
      return {
        type: InputType.Contract,
        txID: hexlify5(value.txID || ZeroBytes32),
        outputIndex: 0,
        balanceRoot: ZeroBytes32,
        stateRoot: ZeroBytes32,
        txPointer: {
          blockHeight: toNumber(arrayify2(value.txPointer).slice(0, 8)),
          txIndex: toNumber(arrayify2(value.txPointer).slice(8, 16))
        },
        contractID: hexlify5(value.contractId)
      };
    }
    case InputType.Message: {
      const predicate = arrayify2(value.predicate ?? "0x");
      const predicateData = arrayify2(value.predicateData ?? "0x");
      const data = arrayify2(value.data ?? "0x");
      return {
        type: InputType.Message,
        sender: hexlify5(value.sender),
        recipient: hexlify5(value.recipient),
        amount: bn3(value.amount),
        nonce: hexlify5(value.nonce),
        witnessIndex: value.witnessIndex,
        predicateGasUsed: bn3(value.predicateGasUsed),
        predicateLength: bn3(predicate.length),
        predicateDataLength: bn3(predicateData.length),
        predicate: hexlify5(predicate),
        predicateData: hexlify5(predicateData),
        data: hexlify5(data),
        dataLength: data.length
      };
    }
    default: {
      throw new FuelError5(
        ErrorCode4.INVALID_TRANSACTION_INPUT,
        `Invalid transaction input type: ${type}.`
      );
    }
  }
}, "inputify");

// src/providers/transaction-request/output.ts
import { ZeroBytes32 as ZeroBytes322 } from "@fuel-ts/address/configs";
import { ErrorCode as ErrorCode5, FuelError as FuelError6 } from "@fuel-ts/errors";
import { bn as bn4 } from "@fuel-ts/math";
import { OutputType } from "@fuel-ts/transactions";
import { hexlify as hexlify6 } from "@fuel-ts/utils";
var outputify = /* @__PURE__ */ __name((value) => {
  const { type } = value;
  switch (type) {
    case OutputType.Coin: {
      return {
        type: OutputType.Coin,
        to: hexlify6(value.to),
        amount: bn4(value.amount),
        assetId: hexlify6(value.assetId)
      };
    }
    case OutputType.Contract: {
      return {
        type: OutputType.Contract,
        inputIndex: value.inputIndex,
        balanceRoot: ZeroBytes322,
        stateRoot: ZeroBytes322
      };
    }
    case OutputType.Change: {
      return {
        type: OutputType.Change,
        to: hexlify6(value.to),
        amount: bn4(0),
        assetId: hexlify6(value.assetId)
      };
    }
    case OutputType.Variable: {
      return {
        type: OutputType.Variable,
        to: hexlify6(value.to || ZeroBytes322),
        amount: bn4(value.amount),
        assetId: hexlify6(value.assetId || ZeroBytes322)
      };
    }
    case OutputType.ContractCreated: {
      return {
        type: OutputType.ContractCreated,
        contractId: hexlify6(value.contractId),
        stateRoot: hexlify6(value.stateRoot)
      };
    }
    default: {
      throw new FuelError6(
        ErrorCode5.INVALID_TRANSACTION_INPUT,
        `Invalid transaction output type: ${type}.`
      );
    }
  }
}, "outputify");

// src/providers/transaction-request/transaction-request.ts
import { UTXO_ID_LEN as UTXO_ID_LEN2 } from "@fuel-ts/abi-coder";
import { Address as Address2, addressify } from "@fuel-ts/address";
import { ZeroBytes32 as ZeroBytes324 } from "@fuel-ts/address/configs";
import { randomBytes as randomBytes3 } from "@fuel-ts/crypto";
import { FuelError as FuelError11 } from "@fuel-ts/errors";
import { bn as bn9 } from "@fuel-ts/math";
import {
  PolicyType,
  TransactionCoder,
  InputType as InputType4,
  OutputType as OutputType4,
  TransactionType as TransactionType2
} from "@fuel-ts/transactions";
import { concat as concat2, hexlify as hexlify11, isDefined as isDefined2 } from "@fuel-ts/utils";

// src/providers/message.ts
var isMessageCoin = /* @__PURE__ */ __name((message) => !("data" in message), "isMessageCoin");

// src/providers/resource.ts
var isCoin = /* @__PURE__ */ __name((resource) => "id" in resource, "isCoin");

// src/providers/utils/receipts.ts
import { ReceiptType as ReceiptType2 } from "@fuel-ts/transactions";
import { FAILED_TRANSFER_TO_ADDRESS_SIGNAL } from "@fuel-ts/transactions/configs";

// src/providers/utils/serialization.ts
import { ZeroBytes32 as ZeroBytes323 } from "@fuel-ts/address/configs";
import { ErrorCode as ErrorCode6, FuelError as FuelError7 } from "@fuel-ts/errors";
import { bn as bn5 } from "@fuel-ts/math";
import {
  getMintedAssetId,
  InputMessageCoder,
  InputType as InputType2,
  OutputType as OutputType2,
  ReceiptType
} from "@fuel-ts/transactions";
import { hexlify as hexlify7, arrayify as arrayify3, assertUnreachable } from "@fuel-ts/utils";
var deserializeChain = /* @__PURE__ */ __name((chain) => {
  const { name, daHeight, consensusParameters, latestBlock } = chain;
  const {
    contractParams,
    feeParams,
    predicateParams,
    scriptParams,
    txParams,
    gasCosts,
    baseAssetId,
    chainId,
    version
  } = consensusParameters;
  return {
    name,
    baseChainHeight: bn5(daHeight),
    consensusParameters: {
      version,
      chainId: bn5(chainId),
      baseAssetId,
      feeParameters: {
        version: feeParams.version,
        gasPerByte: bn5(feeParams.gasPerByte),
        gasPriceFactor: bn5(feeParams.gasPriceFactor)
      },
      contractParameters: {
        version: contractParams.version,
        contractMaxSize: bn5(contractParams.contractMaxSize),
        maxStorageSlots: bn5(contractParams.maxStorageSlots)
      },
      txParameters: {
        version: txParams.version,
        maxInputs: bn5(txParams.maxInputs),
        maxOutputs: bn5(txParams.maxOutputs),
        maxWitnesses: bn5(txParams.maxWitnesses),
        maxGasPerTx: bn5(txParams.maxGasPerTx),
        maxSize: bn5(txParams.maxSize),
        maxBytecodeSubsections: bn5(txParams.maxBytecodeSubsections)
      },
      predicateParameters: {
        version: predicateParams.version,
        maxPredicateLength: bn5(predicateParams.maxPredicateLength),
        maxPredicateDataLength: bn5(predicateParams.maxPredicateDataLength),
        maxGasPerPredicate: bn5(predicateParams.maxGasPerPredicate),
        maxMessageDataLength: bn5(predicateParams.maxMessageDataLength)
      },
      scriptParameters: {
        version: scriptParams.version,
        maxScriptLength: bn5(scriptParams.maxScriptLength),
        maxScriptDataLength: bn5(scriptParams.maxScriptDataLength)
      },
      gasCosts
    },
    latestBlock
  };
}, "deserializeChain");
var serializeChain = /* @__PURE__ */ __name((chain) => {
  const { name, baseChainHeight, consensusParameters, latestBlock } = chain;
  const {
    contractParameters,
    feeParameters,
    predicateParameters,
    scriptParameters,
    txParameters,
    gasCosts,
    baseAssetId,
    chainId,
    version
  } = consensusParameters;
  return {
    name,
    daHeight: baseChainHeight.toString(),
    consensusParameters: {
      version,
      chainId: chainId.toString(),
      baseAssetId,
      feeParams: {
        version: feeParameters.version,
        gasPerByte: feeParameters.gasPerByte.toString(),
        gasPriceFactor: feeParameters.gasPriceFactor.toString()
      },
      contractParams: {
        version: contractParameters.version,
        contractMaxSize: contractParameters.contractMaxSize.toString(),
        maxStorageSlots: contractParameters.maxStorageSlots.toString()
      },
      txParams: {
        version: txParameters.version,
        maxInputs: txParameters.maxInputs.toString(),
        maxOutputs: txParameters.maxOutputs.toString(),
        maxWitnesses: txParameters.maxWitnesses.toString(),
        maxGasPerTx: txParameters.maxGasPerTx.toString(),
        maxSize: txParameters.maxSize.toString(),
        maxBytecodeSubsections: txParameters.maxBytecodeSubsections.toString()
      },
      predicateParams: {
        version: predicateParameters.version,
        maxPredicateLength: predicateParameters.maxPredicateLength.toString(),
        maxPredicateDataLength: predicateParameters.maxPredicateDataLength.toString(),
        maxGasPerPredicate: predicateParameters.maxGasPerPredicate.toString(),
        maxMessageDataLength: predicateParameters.maxMessageDataLength.toString()
      },
      scriptParams: {
        version: scriptParameters.version,
        maxScriptLength: scriptParameters.maxScriptLength.toString(),
        maxScriptDataLength: scriptParameters.maxScriptDataLength.toString()
      },
      gasCosts
    },
    latestBlock
  };
}, "serializeChain");
var deserializeNodeInfo = /* @__PURE__ */ __name((nodeInfo) => {
  const { maxDepth, maxTx, nodeVersion, utxoValidation, vmBacktrace, indexation } = nodeInfo;
  return {
    maxDepth: bn5(maxDepth),
    maxTx: bn5(maxTx),
    nodeVersion,
    utxoValidation,
    vmBacktrace,
    indexation
  };
}, "deserializeNodeInfo");
var serializeNodeInfo = /* @__PURE__ */ __name((nodeInfo) => {
  const { maxDepth, maxTx, nodeVersion, utxoValidation, vmBacktrace, indexation } = nodeInfo;
  return {
    maxDepth: maxDepth.toString(),
    maxTx: maxTx.toString(),
    nodeVersion,
    utxoValidation,
    vmBacktrace,
    indexation
  };
}, "serializeNodeInfo");
var deserializeProviderCache = /* @__PURE__ */ __name((cache2) => ({
  consensusParametersTimestamp: cache2.consensusParametersTimestamp,
  chain: deserializeChain(cache2.chain),
  nodeInfo: deserializeNodeInfo(cache2.nodeInfo)
}), "deserializeProviderCache");
var serializeProviderCache = /* @__PURE__ */ __name(async (provider) => ({
  consensusParametersTimestamp: provider.consensusParametersTimestamp,
  chain: serializeChain(await provider.getChain()),
  nodeInfo: serializeNodeInfo(await provider.getNode())
}), "serializeProviderCache");
var hexOrZero = /* @__PURE__ */ __name((hex) => hex || ZeroBytes323, "hexOrZero");
var deserializeReceipt = /* @__PURE__ */ __name((receipt) => {
  const { receiptType } = receipt;
  switch (receiptType) {
    case "CALL" /* Call */: {
      const id = hexOrZero(receipt.id || receipt.contractId);
      const callReceipt = {
        type: ReceiptType.Call,
        id,
        to: hexOrZero(receipt?.to),
        amount: bn5(receipt.amount),
        assetId: hexOrZero(receipt.assetId),
        gas: bn5(receipt.gas),
        param1: bn5(receipt.param1),
        param2: bn5(receipt.param2),
        pc: bn5(receipt.pc),
        is: bn5(receipt.is)
      };
      return callReceipt;
    }
    case "RETURN" /* Return */: {
      const returnReceipt = {
        type: ReceiptType.Return,
        id: hexOrZero(receipt.id || receipt.contractId),
        val: bn5(receipt.val),
        pc: bn5(receipt.pc),
        is: bn5(receipt.is)
      };
      return returnReceipt;
    }
    case "RETURN_DATA" /* ReturnData */: {
      const returnDataReceipt = {
        type: ReceiptType.ReturnData,
        id: hexOrZero(receipt.id || receipt.contractId),
        ptr: bn5(receipt.ptr),
        len: bn5(receipt.len),
        digest: hexOrZero(receipt.digest),
        pc: bn5(receipt.pc),
        data: hexOrZero(receipt.data),
        is: bn5(receipt.is)
      };
      return returnDataReceipt;
    }
    case "PANIC" /* Panic */: {
      const panicReceipt = {
        type: ReceiptType.Panic,
        id: hexOrZero(receipt.id),
        reason: bn5(receipt.reason),
        pc: bn5(receipt.pc),
        is: bn5(receipt.is),
        contractId: hexOrZero(receipt.contractId)
      };
      return panicReceipt;
    }
    case "REVERT" /* Revert */: {
      const revertReceipt = {
        type: ReceiptType.Revert,
        id: hexOrZero(receipt.id || receipt.contractId),
        val: bn5(receipt.ra),
        pc: bn5(receipt.pc),
        is: bn5(receipt.is)
      };
      return revertReceipt;
    }
    case "LOG" /* Log */: {
      const ra = bn5(receipt.ra);
      const rb = bn5(receipt.rb);
      const rc = bn5(receipt.rc);
      const rd = bn5(receipt.rd);
      const logReceipt = {
        type: ReceiptType.Log,
        id: hexOrZero(receipt.id || receipt.contractId),
        ra,
        rb,
        rc,
        rd,
        pc: bn5(receipt.pc),
        is: bn5(receipt.is)
      };
      return logReceipt;
    }
    case "LOG_DATA" /* LogData */: {
      const ra = bn5(receipt.ra);
      const rb = bn5(receipt.rb);
      const logDataReceipt = {
        type: ReceiptType.LogData,
        id: hexOrZero(receipt.id || receipt.contractId),
        ra,
        rb,
        ptr: bn5(receipt.ptr),
        len: bn5(receipt.len),
        digest: hexOrZero(receipt.digest),
        pc: bn5(receipt.pc),
        data: hexOrZero(receipt.data),
        is: bn5(receipt.is)
      };
      return logDataReceipt;
    }
    case "TRANSFER" /* Transfer */: {
      const id = hexOrZero(receipt.id || receipt.contractId);
      const transferReceipt = {
        type: ReceiptType.Transfer,
        id,
        to: hexOrZero(receipt.toAddress || receipt?.to),
        amount: bn5(receipt.amount),
        assetId: hexOrZero(receipt.assetId),
        pc: bn5(receipt.pc),
        is: bn5(receipt.is)
      };
      return transferReceipt;
    }
    case "TRANSFER_OUT" /* TransferOut */: {
      const id = hexOrZero(receipt.id || receipt.contractId);
      const transferOutReceipt = {
        type: ReceiptType.TransferOut,
        id,
        to: hexOrZero(receipt.toAddress || receipt.to),
        amount: bn5(receipt.amount),
        assetId: hexOrZero(receipt.assetId),
        pc: bn5(receipt.pc),
        is: bn5(receipt.is)
      };
      return transferOutReceipt;
    }
    case "SCRIPT_RESULT" /* ScriptResult */: {
      const scriptResultReceipt = {
        type: ReceiptType.ScriptResult,
        result: bn5(receipt.result),
        gasUsed: bn5(receipt.gasUsed)
      };
      return scriptResultReceipt;
    }
    case "MESSAGE_OUT" /* MessageOut */: {
      const sender = hexOrZero(receipt.sender);
      const recipient = hexOrZero(receipt.recipient);
      const nonce = hexOrZero(receipt.nonce);
      const amount = bn5(receipt.amount);
      const data = receipt.data ? arrayify3(receipt.data) : Uint8Array.from([]);
      const digest = hexOrZero(receipt.digest);
      const len = bn5(receipt.len).toNumber();
      const messageId = InputMessageCoder.getMessageId({
        sender,
        recipient,
        nonce,
        amount,
        data: hexlify7(data)
      });
      const receiptMessageOut = {
        type: ReceiptType.MessageOut,
        sender,
        recipient,
        amount,
        nonce,
        len,
        data,
        digest,
        messageId
      };
      return receiptMessageOut;
    }
    case "MINT" /* Mint */: {
      const contractId = hexOrZero(receipt.id || receipt.contractId);
      const subId = hexOrZero(receipt.subId);
      const assetId = getMintedAssetId(contractId, subId);
      const mintReceipt = {
        type: ReceiptType.Mint,
        subId,
        contractId,
        assetId,
        val: bn5(receipt.val),
        pc: bn5(receipt.pc),
        is: bn5(receipt.is)
      };
      return mintReceipt;
    }
    case "BURN" /* Burn */: {
      const contractId = hexOrZero(receipt.id || receipt.contractId);
      const subId = hexOrZero(receipt.subId);
      const assetId = getMintedAssetId(contractId, subId);
      const burnReceipt = {
        type: ReceiptType.Burn,
        subId,
        contractId,
        assetId,
        val: bn5(receipt.val),
        pc: bn5(receipt.pc),
        is: bn5(receipt.is)
      };
      return burnReceipt;
    }
    default:
      throw new FuelError7(ErrorCode6.INVALID_RECEIPT_TYPE, `Invalid receipt type: ${receiptType}.`);
  }
}, "deserializeReceipt");
var deserializeInput = /* @__PURE__ */ __name((input) => {
  let parsedInput;
  switch (input.type) {
    case "InputCoin":
      parsedInput = {
        type: InputType2.Coin,
        id: input.utxoId,
        amount: bn5(input.amount),
        assetId: input.assetId,
        owner: input.owner,
        txPointer: `0x${input.txPointer}`,
        witnessIndex: Number(input.coinWitnessIndex),
        predicate: input.predicate,
        predicateData: input.predicateData,
        predicateGasUsed: bn5(input.predicateGasUsed)
      };
      break;
    case "InputMessage":
      parsedInput = {
        type: InputType2.Message,
        nonce: input.nonce,
        amount: bn5(input.amount),
        recipient: input.recipient,
        sender: input.sender,
        data: input.data,
        witnessIndex: Number(input.messageWitnessIndex),
        predicate: input.predicate,
        predicateData: input.predicateData,
        predicateGasUsed: bn5(input.predicateGasUsed)
      };
      break;
    case "InputContract":
      parsedInput = {
        type: InputType2.Contract,
        contractId: input.contractId,
        txPointer: `0x${input.txPointer}`,
        txID: hexlify7(arrayify3(input.utxoId).slice(0, 32))
      };
      break;
    default:
      assertUnreachable(input);
  }
  return parsedInput;
}, "deserializeInput");
var deserializeOutput = /* @__PURE__ */ __name((output) => {
  let parsedOutput;
  switch (output.type) {
    case "CoinOutput":
      parsedOutput = {
        type: OutputType2.Coin,
        amount: bn5(output.amount),
        assetId: output.assetId,
        to: output.to
      };
      break;
    case "ContractOutput":
      parsedOutput = {
        type: OutputType2.Contract,
        inputIndex: Number(output.inputIndex)
      };
      break;
    case "ChangeOutput":
      parsedOutput = {
        type: OutputType2.Change,
        assetId: output.assetId,
        to: output.to
      };
      break;
    case "ContractCreated":
      parsedOutput = {
        type: OutputType2.ContractCreated,
        stateRoot: output.stateRoot,
        contractId: output.contract
      };
      break;
    case "VariableOutput":
      parsedOutput = {
        type: OutputType2.Variable,
        amount: bn5(output.amount),
        assetId: output.assetId,
        to: output.to
      };
      break;
    default:
      assertUnreachable(output);
  }
  return parsedOutput;
}, "deserializeOutput");
var deserializeProcessedTxOutput = /* @__PURE__ */ __name((output) => {
  let parsedOutput;
  switch (output.type) {
    case "CoinOutput":
      parsedOutput = {
        type: OutputType2.Coin,
        amount: bn5(output.amount),
        assetId: output.assetId,
        to: output.to
      };
      break;
    case "ContractOutput":
      parsedOutput = {
        type: OutputType2.Contract,
        inputIndex: Number(output.inputIndex),
        balanceRoot: output.balanceRoot,
        stateRoot: output.stateRoot
      };
      break;
    case "ChangeOutput":
      parsedOutput = {
        type: OutputType2.Change,
        assetId: output.assetId,
        to: output.to,
        amount: bn5(output.amount)
      };
      break;
    case "ContractCreated":
      parsedOutput = {
        type: OutputType2.ContractCreated,
        stateRoot: output.stateRoot,
        contractId: output.contract
      };
      break;
    case "VariableOutput":
      parsedOutput = {
        type: OutputType2.Variable,
        amount: bn5(output.amount),
        assetId: output.assetId,
        to: output.to
      };
      break;
    default:
      assertUnreachable(output);
  }
  return parsedOutput;
}, "deserializeProcessedTxOutput");

// src/providers/utils/receipts.ts
var doesReceiptHaveMissingOutputVariables = /* @__PURE__ */ __name((receipt) => receipt.type === ReceiptType2.Revert && receipt.val.toString("hex") === FAILED_TRANSFER_TO_ADDRESS_SIGNAL, "doesReceiptHaveMissingOutputVariables");
var doesReceiptHaveMissingContractId = /* @__PURE__ */ __name((receipt) => receipt.type === ReceiptType2.Panic && receipt.contractId !== "0x0000000000000000000000000000000000000000000000000000000000000000", "doesReceiptHaveMissingContractId");
var getReceiptsWithMissingData = /* @__PURE__ */ __name((receipts) => receipts.reduce(
  (memo, receipt) => {
    if (doesReceiptHaveMissingOutputVariables(receipt)) {
      memo.missingOutputVariables.push(receipt);
    }
    if (doesReceiptHaveMissingContractId(receipt)) {
      memo.missingOutputContractIds.push(receipt);
    }
    return memo;
  },
  {
    missingOutputVariables: [],
    missingOutputContractIds: []
  }
), "getReceiptsWithMissingData");

// src/providers/utils/block-explorer.ts
import { ErrorCode as ErrorCode7, FuelError as FuelError8 } from "@fuel-ts/errors";

// src/providers/utils/gas.ts
import { bn as bn6 } from "@fuel-ts/math";
import { ReceiptType as ReceiptType3 } from "@fuel-ts/transactions";
import { arrayify as arrayify4 } from "@fuel-ts/utils";
var getGasUsedFromReceipts = /* @__PURE__ */ __name((receipts) => {
  const scriptResult = receipts.filter(
    (receipt) => receipt.type === ReceiptType3.ScriptResult
  );
  const gasUsed = scriptResult.reduce((prev, receipt) => prev.add(receipt.gasUsed), bn6(0));
  return gasUsed;
}, "getGasUsedFromReceipts");
function resolveGasDependentCosts(byteSize, gasDependentCost) {
  const base = bn6(gasDependentCost.base);
  let dependentValue = bn6(0);
  if ("unitsPerGas" in gasDependentCost) {
    dependentValue = bn6(byteSize).div(bn6(gasDependentCost.unitsPerGas));
  } else {
    dependentValue = bn6(byteSize).mul(bn6(gasDependentCost.gasPerUnit));
  }
  return base.add(dependentValue);
}
__name(resolveGasDependentCosts, "resolveGasDependentCosts");
function gasUsedByInputs(inputs, txBytesSize, gasCosts) {
  const witnessCache = [];
  const chargeableInputs = inputs.filter((input) => {
    const isCoinOrMessage = "owner" in input || "sender" in input;
    if (isCoinOrMessage) {
      if ("predicate" in input && input.predicate && input.predicate !== "0x") {
        return true;
      }
      if (!witnessCache.includes(input.witnessIndex)) {
        witnessCache.push(input.witnessIndex);
        return true;
      }
    }
    return false;
  });
  const vmInitializationCost = resolveGasDependentCosts(txBytesSize, gasCosts.vmInitialization);
  const totalGas = chargeableInputs.reduce((total, input) => {
    if ("predicate" in input && input.predicate && input.predicate !== "0x") {
      return total.add(
        vmInitializationCost.add(resolveGasDependentCosts(arrayify4(input.predicate).length, gasCosts.contractRoot)).add(bn6(input.predicateGasUsed))
      );
    }
    return total.add(gasCosts.ecr1);
  }, bn6(0));
  return totalGas;
}
__name(gasUsedByInputs, "gasUsedByInputs");
function getMinGas(params) {
  const { gasCosts, gasPerByte, inputs, metadataGas, txBytesSize } = params;
  const vmInitGas = resolveGasDependentCosts(txBytesSize, gasCosts.vmInitialization);
  const bytesGas = bn6(txBytesSize).mul(gasPerByte);
  const inputsGas = gasUsedByInputs(inputs, txBytesSize, gasCosts);
  const minGas = vmInitGas.add(bytesGas).add(inputsGas).add(metadataGas).maxU64();
  return minGas;
}
__name(getMinGas, "getMinGas");
function getMaxGas(params) {
  const {
    gasPerByte,
    witnessesLength,
    witnessLimit,
    minGas,
    gasLimit = bn6(0),
    maxGasPerTx
  } = params;
  let remainingAllowedWitnessGas = bn6(0);
  if (witnessLimit?.gt(0) && witnessLimit.gte(witnessesLength)) {
    remainingAllowedWitnessGas = bn6(witnessLimit).sub(witnessesLength).mul(gasPerByte);
  }
  const maxGas = remainingAllowedWitnessGas.add(minGas).add(gasLimit);
  return maxGas.gte(maxGasPerTx) ? maxGasPerTx : maxGas;
}
__name(getMaxGas, "getMaxGas");
function calculateMetadataGasForTxCreate({
  gasCosts,
  stateRootSize,
  txBytesSize,
  contractBytesSize
}) {
  const contractRootGas = resolveGasDependentCosts(contractBytesSize, gasCosts.contractRoot);
  const stateRootGas = resolveGasDependentCosts(stateRootSize, gasCosts.stateRoot);
  const txIdGas = resolveGasDependentCosts(txBytesSize, gasCosts.s256);
  const contractIdInputSize = bn6(4 + 32 + 32 + 32);
  const contractIdGas = resolveGasDependentCosts(contractIdInputSize, gasCosts.s256);
  const metadataGas = contractRootGas.add(stateRootGas).add(txIdGas).add(contractIdGas);
  return metadataGas.maxU64();
}
__name(calculateMetadataGasForTxCreate, "calculateMetadataGasForTxCreate");
function calculateMetadataGasForTxScript({
  gasCosts,
  txBytesSize
}) {
  return resolveGasDependentCosts(txBytesSize, gasCosts.s256);
}
__name(calculateMetadataGasForTxScript, "calculateMetadataGasForTxScript");
function calculateMetadataGasForTxBlob({
  gasCosts,
  txBytesSize,
  witnessBytesSize
}) {
  const txId = resolveGasDependentCosts(txBytesSize, gasCosts.s256);
  const blobLen = resolveGasDependentCosts(witnessBytesSize, gasCosts.s256);
  return txId.add(blobLen);
}
__name(calculateMetadataGasForTxBlob, "calculateMetadataGasForTxBlob");
function calculateMetadataGasForTxUpgrade({
  gasCosts,
  txBytesSize,
  consensusSize
}) {
  const txId = resolveGasDependentCosts(txBytesSize, gasCosts.s256);
  if (consensusSize) {
    const consensusLen = resolveGasDependentCosts(consensusSize, gasCosts.s256);
    txId.add(consensusLen);
  }
  return txId;
}
__name(calculateMetadataGasForTxUpgrade, "calculateMetadataGasForTxUpgrade");
function calculateMetadataGasForTxUpload({
  gasCosts,
  txBytesSize,
  subsectionSize,
  subsectionsSize
}) {
  const txId = resolveGasDependentCosts(txBytesSize, gasCosts.s256);
  const subsectionLen = resolveGasDependentCosts(subsectionSize, gasCosts.s256);
  txId.add(subsectionLen);
  const subsectionsLen = resolveGasDependentCosts(subsectionsSize, gasCosts.stateRoot);
  txId.add(subsectionsLen);
  return txId;
}
__name(calculateMetadataGasForTxUpload, "calculateMetadataGasForTxUpload");
function calculateMinGasForTxUpload({
  gasCosts,
  baseMinGas,
  subsectionSize
}) {
  const additionalStoragePerByte = bn6(gasCosts.newStoragePerByte).mul(subsectionSize);
  return bn6(baseMinGas).add(additionalStoragePerByte);
}
__name(calculateMinGasForTxUpload, "calculateMinGasForTxUpload");
var calculateGasFee = /* @__PURE__ */ __name((params) => {
  const { gas, gasPrice, priceFactor, tip } = params;
  return gas.mul(gasPrice).div(priceFactor).add(bn6(tip));
}, "calculateGasFee");

// src/providers/utils/json.ts
import { hexlify as hexlify8 } from "@fuel-ts/utils";
import { clone } from "ramda";
function normalize(object) {
  Object.keys(object).forEach((key) => {
    switch (object[key]?.constructor.name) {
      case "Uint8Array":
        object[key] = hexlify8(object[key]);
        break;
      case "Array":
        object[key] = normalize(object[key]);
        break;
      case "BN":
        object[key] = object[key].toHex();
        break;
      case "Address":
        object[key] = object[key].toB256();
        break;
      case "Object":
        object[key] = normalize(object[key]);
        break;
      default:
        break;
    }
  });
  return object;
}
__name(normalize, "normalize");
function normalizeJSON(root) {
  return normalize(clone(root));
}
__name(normalizeJSON, "normalizeJSON");

// src/providers/utils/extract-tx-error.ts
import { ErrorCode as ErrorCode8, FuelError as FuelError9 } from "@fuel-ts/errors";
import { bn as bn7 } from "@fuel-ts/math";
import { ReceiptType as ReceiptType4 } from "@fuel-ts/transactions";
import {
  FAILED_REQUIRE_SIGNAL,
  FAILED_ASSERT_EQ_SIGNAL,
  FAILED_ASSERT_NE_SIGNAL,
  FAILED_ASSERT_SIGNAL,
  FAILED_TRANSFER_TO_ADDRESS_SIGNAL as FAILED_TRANSFER_TO_ADDRESS_SIGNAL2,
  PANIC_REASONS,
  PANIC_DOC_URL
} from "@fuel-ts/transactions/configs";
var assemblePanicError = /* @__PURE__ */ __name((statusReason, metadata) => {
  let errorMessage = `The transaction reverted with reason: "${statusReason}".`;
  if (PANIC_REASONS.includes(statusReason)) {
    errorMessage = `${errorMessage}

You can read more about this error at:

${PANIC_DOC_URL}#variant.${statusReason}`;
  }
  return new FuelError9(ErrorCode8.SCRIPT_REVERTED, errorMessage, {
    ...metadata,
    reason: statusReason
  });
}, "assemblePanicError");
var stringify = /* @__PURE__ */ __name((obj) => JSON.stringify(obj, null, 2), "stringify");
var assembleRevertError = /* @__PURE__ */ __name((receipts, logs, metadata) => {
  let errorMessage = "The transaction reverted with an unknown reason.";
  const revertReceipt = receipts.find(({ type }) => type === ReceiptType4.Revert);
  let reason = "";
  if (revertReceipt) {
    const reasonHex = bn7(revertReceipt.val).toHex();
    const lastLog = logs[logs.length - 1];
    const lastButOneLog = logs[logs.length - 2];
    switch (reasonHex) {
      case FAILED_REQUIRE_SIGNAL: {
        reason = "require";
        errorMessage = `The transaction reverted because a "require" statement has thrown ${logs.length ? stringify(lastLog) : "an error."}.`;
        break;
      }
      case FAILED_ASSERT_EQ_SIGNAL: {
        const suffix = logs.length >= 2 ? ` comparing ${stringify(lastLog)} and ${stringify(lastButOneLog)}.` : ".";
        reason = "assert_eq";
        errorMessage = `The transaction reverted because of an "assert_eq" statement${suffix}`;
        break;
      }
      case FAILED_ASSERT_NE_SIGNAL: {
        const suffix = logs.length >= 2 ? ` comparing ${stringify(lastButOneLog)} and ${stringify(lastLog)}.` : ".";
        reason = "assert_ne";
        errorMessage = `The transaction reverted because of an "assert_ne" statement${suffix}`;
        break;
      }
      case FAILED_ASSERT_SIGNAL:
        reason = "assert";
        errorMessage = `The transaction reverted because an "assert" statement failed to evaluate to true.`;
        break;
      case FAILED_TRANSFER_TO_ADDRESS_SIGNAL2:
        reason = "MissingOutputVariable";
        errorMessage = `The transaction reverted because it's missing an "OutputVariable".`;
        break;
      default:
        throw new FuelError9(
          ErrorCode8.UNKNOWN,
          `The transaction reverted with an unknown reason: ${revertReceipt.val}`,
          {
            ...metadata,
            reason: "unknown"
          }
        );
    }
  }
  return new FuelError9(ErrorCode8.SCRIPT_REVERTED, errorMessage, {
    ...metadata,
    reason
  });
}, "assembleRevertError");
var extractTxError = /* @__PURE__ */ __name((params) => {
  const { receipts, statusReason, logs, groupedLogs } = params;
  const isPanic = receipts.some(({ type }) => type === ReceiptType4.Panic);
  const isRevert = receipts.some(({ type }) => type === ReceiptType4.Revert);
  const metadata = {
    logs,
    groupedLogs,
    receipts,
    panic: isPanic,
    revert: isRevert,
    reason: ""
  };
  if (isPanic) {
    return assemblePanicError(statusReason, metadata);
  }
  return assembleRevertError(receipts, logs, metadata);
}, "extractTxError");

// src/providers/utils/merge-quantities.ts
var mergeQuantities = /* @__PURE__ */ __name((...coinQuantities) => {
  const resultMap = {};
  function addToMap({ amount, assetId }) {
    if (resultMap[assetId]) {
      resultMap[assetId] = resultMap[assetId].add(amount);
    } else {
      resultMap[assetId] = amount;
    }
  }
  __name(addToMap, "addToMap");
  coinQuantities.forEach((arr) => arr.forEach(addToMap));
  return Object.entries(resultMap).map(([assetId, amount]) => ({ assetId, amount }));
}, "mergeQuantities");

// src/providers/transaction-request/errors.ts
var NoWitnessAtIndexError = class extends Error {
  constructor(index) {
    super();
    this.index = index;
    this.message = `Witness at index "${index}" was not found`;
  }
  static {
    __name(this, "NoWitnessAtIndexError");
  }
  name = "NoWitnessAtIndexError";
};

// src/providers/transaction-request/helpers.ts
import { ErrorCode as ErrorCode9, FuelError as FuelError10 } from "@fuel-ts/errors";
import { bn as bn8 } from "@fuel-ts/math";
import { InputType as InputType3, OutputType as OutputType3 } from "@fuel-ts/transactions";
import { hexlify as hexlify9 } from "@fuel-ts/utils";
var isRequestInputCoin = /* @__PURE__ */ __name((input) => input.type === InputType3.Coin, "isRequestInputCoin");
var isRequestInputMessage = /* @__PURE__ */ __name((input) => input.type === InputType3.Message, "isRequestInputMessage");
var isRequestInputMessageWithoutData = /* @__PURE__ */ __name((input) => input.type === InputType3.Message && bn8(input.data).isZero(), "isRequestInputMessageWithoutData");
var isRequestInputCoinOrMessage = /* @__PURE__ */ __name((input) => isRequestInputCoin(input) || isRequestInputMessage(input), "isRequestInputCoinOrMessage");
var isRequestInputResource = /* @__PURE__ */ __name((input) => isRequestInputCoin(input) || isRequestInputMessageWithoutData(input), "isRequestInputResource");
var getRequestInputResourceOwner = /* @__PURE__ */ __name((input) => isRequestInputCoin(input) ? input.owner : input.recipient, "getRequestInputResourceOwner");
var isRequestInputResourceFromOwner = /* @__PURE__ */ __name((input, owner) => getRequestInputResourceOwner(input) === owner.toB256(), "isRequestInputResourceFromOwner");
var isPredicate = /* @__PURE__ */ __name((input) => isRequestInputCoinOrMessage(input) && !!input.predicate && hexlify9(input.predicate) !== "0x", "isPredicate");
var getAssetAmountInRequestInputs = /* @__PURE__ */ __name((inputs, assetId, baseAsset) => inputs.filter(isRequestInputResource).reduce((acc, input) => {
  if (isRequestInputCoin(input) && input.assetId === assetId) {
    return acc.add(input.amount);
  }
  if (isRequestInputMessage(input) && assetId === baseAsset) {
    return acc.add(input.amount);
  }
  return acc;
}, bn8(0)), "getAssetAmountInRequestInputs");
var cacheRequestInputsResourcesFromOwner = /* @__PURE__ */ __name((inputs, owner) => inputs.reduce(
  (acc, input) => {
    if (isRequestInputCoin(input) && input.owner === owner.toB256()) {
      acc.utxos.push(input.id);
    } else if (isRequestInputMessage(input) && input.recipient === owner.toB256()) {
      acc.messages.push(input.nonce);
    }
    return acc;
  },
  {
    utxos: [],
    messages: []
  }
), "cacheRequestInputsResourcesFromOwner");
var getBurnableAssetCount = /* @__PURE__ */ __name((baseAssetId, transactionRequest) => {
  const { inputs, outputs } = transactionRequest;
  const coinInputs = new Set(inputs.filter(isRequestInputCoin).map((input) => input.assetId));
  if (inputs.some((i) => isRequestInputMessage(i) && bn8(i.amount).gt(0))) {
    coinInputs.add(baseAssetId);
  }
  const changeOutputs = new Set(
    outputs.filter((output) => output.type === OutputType3.Change).map((output) => output.assetId)
  );
  const difference = new Set([...coinInputs].filter((x) => !changeOutputs.has(x)));
  return difference.size;
}, "getBurnableAssetCount");
var validateTransactionForAssetBurn = /* @__PURE__ */ __name((baseAssetId, transactionRequest, enableAssetBurn = false) => {
  if (enableAssetBurn === true) {
    return;
  }
  if (getBurnableAssetCount(baseAssetId, transactionRequest) <= 0) {
    return;
  }
  const message = [
    "Asset burn detected.",
    "Add the relevant change outputs to the transaction to avoid burning assets.",
    "Or enable asset burn, upon sending the transaction."
  ].join("\n");
  throw new FuelError10(ErrorCode9.ASSET_BURN_DETECTED, message);
}, "validateTransactionForAssetBurn");

// src/providers/transaction-request/witness.ts
import { arrayify as arrayify5, hexlify as hexlify10 } from "@fuel-ts/utils";
var witnessify = /* @__PURE__ */ __name((value) => {
  const data = arrayify5(value);
  return {
    data: hexlify10(data),
    dataLength: data.length
  };
}, "witnessify");

// src/providers/transaction-request/transaction-request.ts
var BaseTransactionRequest = class _BaseTransactionRequest {
  static {
    __name(this, "BaseTransactionRequest");
  }
  /** Gas price for transaction */
  tip;
  /** Block until which tx cannot be included */
  maturity;
  /** The block number after which the transaction is no longer valid. */
  expiration;
  /** The maximum fee payable by this transaction using BASE_ASSET. */
  maxFee;
  /** The maximum amount of witness data allowed for the transaction */
  witnessLimit;
  /** List of inputs */
  inputs = [];
  /** List of outputs */
  outputs = [];
  /** List of witnesses */
  witnesses = [];
  /**
   * The current status of the transaction
   */
  flag = { state: void 0, transactionId: void 0, summary: void 0 };
  /**
   * Constructor for initializing a base transaction request.
   *
   * @param baseTransactionRequest - Optional object containing properties to initialize the transaction request.
   */
  constructor({
    tip,
    maturity,
    expiration,
    maxFee,
    witnessLimit,
    inputs,
    outputs,
    witnesses,
    flag
  } = {}) {
    this.tip = tip ? bn9(tip) : void 0;
    this.maturity = maturity && maturity > 0 ? maturity : void 0;
    this.expiration = expiration && expiration > 0 ? expiration : void 0;
    this.witnessLimit = isDefined2(witnessLimit) ? bn9(witnessLimit) : void 0;
    this.maxFee = bn9(maxFee);
    this.inputs = inputs ?? [];
    this.outputs = outputs ?? [];
    this.witnesses = witnesses ?? [];
    this.flag = flag ?? { state: void 0, transactionId: void 0, summary: void 0 };
  }
  static getPolicyMeta(req) {
    let policyTypes = 0;
    const policies = [];
    const { tip, witnessLimit, maturity, expiration } = req;
    if (bn9(tip).gt(0)) {
      policyTypes += PolicyType.Tip;
      policies.push({ data: bn9(tip), type: PolicyType.Tip });
    }
    if (isDefined2(witnessLimit) && bn9(witnessLimit).gte(0)) {
      policyTypes += PolicyType.WitnessLimit;
      policies.push({ data: bn9(witnessLimit), type: PolicyType.WitnessLimit });
    }
    if (maturity && maturity > 0) {
      policyTypes += PolicyType.Maturity;
      policies.push({ data: maturity, type: PolicyType.Maturity });
    }
    policyTypes += PolicyType.MaxFee;
    policies.push({ data: req.maxFee, type: PolicyType.MaxFee });
    if (expiration && expiration > 0) {
      policyTypes += PolicyType.Expiration;
      policies.push({ data: expiration, type: PolicyType.Expiration });
    }
    return {
      policyTypes,
      policies
    };
  }
  /**
   * Method to obtain the base transaction details.
   *
   * @returns The base transaction details.
   */
  getBaseTransaction() {
    const inputs = this.inputs?.map(inputify) ?? [];
    const outputs = this.outputs?.map(outputify) ?? [];
    const witnesses = this.witnesses?.map(witnessify) ?? [];
    const { policyTypes, policies } = _BaseTransactionRequest.getPolicyMeta(this);
    return {
      policyTypes,
      inputs,
      outputs,
      policies,
      witnesses,
      inputsCount: inputs.length,
      outputsCount: outputs.length,
      witnessesCount: witnesses.length
    };
  }
  /**
   * Converts the transaction request to a byte array.
   *
   * @returns The transaction bytes.
   */
  toTransactionBytes() {
    return new TransactionCoder().encode(this.toTransaction());
  }
  /**
   * @hidden
   *
   * Pushes an input to the list without any side effects and returns the index
   */
  pushInput(input) {
    this.inputs.push(input);
    return this.inputs.length - 1;
  }
  /**
   * @hidden
   *
   * Pushes an output to the list without any side effects and returns the index
   */
  pushOutput(output) {
    this.outputs.push(output);
    return this.outputs.length - 1;
  }
  /**
   * @hidden
   *
   * Pushes a witness to the list and returns the index
   *
   * @param signature - The signature to add to the witness.
   * @returns The index of the created witness.
   */
  addWitness(signature) {
    this.witnesses.push(signature);
    return this.witnesses.length - 1;
  }
  /**
   * @hidden
   *
   * Creates an empty witness without any side effects and returns the index
   *
   * @returns The index of the created witness.
   */
  addEmptyWitness() {
    return this.addWitness(concat2([ZeroBytes324, ZeroBytes324]));
  }
  /**
   * Updates the witness for a given owner and signature.
   *
   * @param address - The address to get the coin input witness index for.
   * @param signature - The signature to update the witness with.
   */
  updateWitnessByOwner(address, signature) {
    const ownerAddress = new Address2(address);
    const witnessIndex = this.getCoinInputWitnessIndexByOwner(ownerAddress);
    if (typeof witnessIndex === "number") {
      this.updateWitness(witnessIndex, signature);
    }
  }
  /**
   * Updates an existing witness without any side effects.
   *
   * @param index - The index of the witness to update.
   * @param witness - The new witness.
   * @throws If the witness does not exist.
   */
  updateWitness(index, witness) {
    if (!this.witnesses[index]) {
      throw new NoWitnessAtIndexError(index);
    }
    this.witnesses[index] = witness;
  }
  /**
   * Helper function to add an external signature to the transaction.
   *
   * @param account - The account/s to sign to the transaction.
   * @returns The transaction with the signature witness added.
   */
  async addAccountWitnesses(account) {
    const accounts = Array.isArray(account) ? account : [account];
    await Promise.all(
      accounts.map(async (acc) => {
        this.addWitness(await acc.signTransaction(this));
      })
    );
    return this;
  }
  /**
   * Gets the coin inputs for a transaction.
   *
   * @returns The coin inputs.
   */
  getCoinInputs() {
    return this.inputs.filter(
      (input) => input.type === InputType4.Coin
    );
  }
  /**
   * Gets the coin outputs for a transaction.
   *
   * @returns The coin outputs.
   */
  getCoinOutputs() {
    return this.outputs.filter(
      (output) => output.type === OutputType4.Coin
    );
  }
  /**
   * Gets the change outputs for a transaction.
   *
   * @returns The change outputs.
   */
  getChangeOutputs() {
    return this.outputs.filter(
      (output) => output.type === OutputType4.Change
    );
  }
  /**
   * @hidden
   *
   * Returns the witnessIndex of the found CoinInput.
   */
  getCoinInputWitnessIndexByOwner(owner) {
    const ownerAddress = addressify(owner);
    const found = this.inputs.find((input) => {
      switch (input.type) {
        case InputType4.Coin:
          return hexlify11(input.owner) === ownerAddress.toB256();
        case InputType4.Message:
          return hexlify11(input.recipient) === ownerAddress.toB256();
        default:
          return false;
      }
    });
    return found?.witnessIndex;
  }
  /**
   * Adds a single coin input to the transaction and a change output for the related
   * assetId, if one it was not added yet.
   *
   * @param coin - Coin resource.
   */
  addCoinInput(coin) {
    const { assetId, owner, amount, id, predicate, predicateData } = coin;
    let witnessIndex;
    if (coin.predicate) {
      witnessIndex = 0;
    } else {
      witnessIndex = this.getCoinInputWitnessIndexByOwner(owner);
      if (typeof witnessIndex !== "number") {
        witnessIndex = this.addEmptyWitness();
      }
    }
    const input = {
      id,
      type: InputType4.Coin,
      owner: owner.toB256(),
      amount,
      assetId,
      txPointer: "0x00000000000000000000000000000000",
      witnessIndex,
      predicate,
      predicateData
    };
    this.pushInput(input);
    this.addChangeOutput(owner, assetId);
  }
  /**
   * Adds a single message input to the transaction and a change output for the
   * asset against the message
   *
   * @param message - Message resource.
   */
  addMessageInput(message) {
    const { recipient, sender, amount, predicate, nonce, predicateData } = message;
    let witnessIndex;
    if (message.predicate) {
      witnessIndex = 0;
    } else {
      witnessIndex = this.getCoinInputWitnessIndexByOwner(recipient);
      if (typeof witnessIndex !== "number") {
        witnessIndex = this.addEmptyWitness();
      }
    }
    const input = {
      nonce,
      type: InputType4.Message,
      sender: sender.toB256(),
      recipient: recipient.toB256(),
      data: isMessageCoin(message) ? "0x" : message.data,
      amount,
      witnessIndex,
      predicate,
      predicateData
    };
    this.pushInput(input);
    if (isMessageCoin(message)) {
      this.addChangeOutput(recipient, message.assetId);
    }
  }
  /**
   * Adds a single resource to the transaction by adding a coin/message input and a
   * change output for the related assetId, if one it was not added yet.
   *
   * @param resource - The resource to add.
   * @returns This transaction.
   */
  addResource(resource) {
    if (isCoin(resource)) {
      this.addCoinInput(resource);
    } else {
      this.addMessageInput(resource);
    }
    return this;
  }
  /**
   * Adds multiple resources to the transaction by adding coin/message inputs and change
   * outputs from the related assetIds.
   *
   * @param resources - The resources to add.
   * @returns This transaction.
   */
  addResources(resources) {
    resources.forEach((resource) => this.addResource(resource));
    return this;
  }
  /**
   * Adds a coin output to the transaction.
   *
   * @param to - Address of the owner.
   * @param amount - Amount of coin.
   * @param assetId - Asset ID of coin.
   */
  addCoinOutput(to, amount, assetId) {
    this.pushOutput({
      type: OutputType4.Coin,
      to: addressify(to).toB256(),
      amount,
      assetId
    });
    return this;
  }
  /**
   * Adds multiple coin outputs to the transaction.
   *
   * @param to - Address of the destination.
   * @param quantities - Quantities of coins.
   */
  addCoinOutputs(to, quantities) {
    quantities.map(coinQuantityfy).forEach((quantity) => {
      this.pushOutput({
        type: OutputType4.Coin,
        to: addressify(to).toB256(),
        amount: quantity.amount,
        assetId: quantity.assetId
      });
    });
    return this;
  }
  /**
   * Adds a change output to the transaction.
   *
   * @param to - Address of the owner.
   * @param assetId - Asset ID of coin.
   */
  addChangeOutput(to, assetId) {
    const changeOutput = this.getChangeOutputs().find(
      (output) => hexlify11(output.assetId) === assetId
    );
    if (!changeOutput) {
      this.pushOutput({
        type: OutputType4.Change,
        to: addressify(to).toB256(),
        assetId
      });
    }
  }
  /**
   * @hidden
   */
  byteSize() {
    return this.toTransactionBytes().length;
  }
  /**
   * @hidden
   */
  metadataGas(_gasCosts) {
    throw new FuelError11(FuelError11.CODES.NOT_IMPLEMENTED, "Not implemented");
  }
  /**
   * @hidden
   */
  calculateMinGas(chainInfo) {
    const { consensusParameters } = chainInfo;
    const {
      gasCosts,
      feeParameters: { gasPerByte }
    } = consensusParameters;
    return getMinGas({
      gasPerByte,
      gasCosts,
      inputs: this.inputs,
      txBytesSize: this.byteSize(),
      metadataGas: this.metadataGas(gasCosts)
    });
  }
  calculateMaxGas(chainInfo, minGas) {
    const { consensusParameters } = chainInfo;
    const {
      feeParameters: { gasPerByte },
      txParameters: { maxGasPerTx }
    } = consensusParameters;
    const witnessesLength = this.toTransaction().witnesses.reduce(
      (acc, wit) => acc + wit.dataLength,
      0
    );
    return getMaxGas({
      gasPerByte,
      minGas,
      witnessesLength,
      witnessLimit: this.witnessLimit,
      maxGasPerTx
    });
  }
  /**
   * Funds the transaction with fake UTXOs for each assetId and amount in the
   * quantities array.
   *
   * @param quantities - CoinQuantity Array.
   * @param baseAssetId - The base asset to fund the transaction.
   * @deprecated - This method is deprecated and will be removed in future versions.
   * Please use `Account.generateFakeResources` along with `this.addResources` instead.
   */
  fundWithFakeUtxos(quantities, baseAssetId, resourcesOwner) {
    const findAssetInput = /* @__PURE__ */ __name((assetId) => this.inputs.find((input) => {
      if ("assetId" in input) {
        return input.assetId === assetId;
      }
      return false;
    }), "findAssetInput");
    const updateAssetInput = /* @__PURE__ */ __name((assetId, quantity) => {
      const assetInput = findAssetInput(assetId);
      let usedQuantity = quantity;
      if (assetId === baseAssetId) {
        usedQuantity = bn9("1000000000000000000");
      }
      if (assetInput && "assetId" in assetInput) {
        assetInput.id = hexlify11(randomBytes3(UTXO_ID_LEN2));
        assetInput.amount = usedQuantity;
      } else {
        this.addResources([
          {
            id: hexlify11(randomBytes3(UTXO_ID_LEN2)),
            amount: usedQuantity,
            assetId,
            owner: resourcesOwner || Address2.fromRandom(),
            blockCreated: bn9(1),
            txCreatedIdx: bn9(1)
          }
        ]);
      }
    }, "updateAssetInput");
    updateAssetInput(baseAssetId, bn9(1e11));
    quantities.forEach((q) => updateAssetInput(q.assetId, q.amount));
    return this;
  }
  /**
   * Retrieves an array of CoinQuantity for each coin output present in the transaction.
   * a transaction.
   *
   * @returns  CoinQuantity array.
   */
  getCoinOutputsQuantities() {
    const coinsQuantities = this.getCoinOutputs().map(({ amount, assetId }) => ({
      amount: bn9(amount),
      assetId: assetId.toString()
    }));
    return coinsQuantities;
  }
  /**
   * Return the minimum amount in native coins required to create
   * a transaction.
   *
   * @returns The transaction as a JSON object.
   */
  toJSON() {
    return normalizeJSON(this);
  }
  removeWitness(index) {
    this.witnesses.splice(index, 1);
    this.adjustWitnessIndexes(index);
  }
  adjustWitnessIndexes(removedIndex) {
    this.inputs.filter(isRequestInputResource).forEach((input) => {
      if (input.witnessIndex > removedIndex) {
        input.witnessIndex -= 1;
      }
    });
  }
  updatePredicateGasUsed(inputs) {
    const inputsToExtractGasUsed = inputs.filter(isRequestInputCoinOrMessage);
    this.inputs.filter(isRequestInputResource).forEach((i) => {
      const owner = getRequestInputResourceOwner(i);
      const correspondingInput = inputsToExtractGasUsed.find(
        (x) => isRequestInputResourceFromOwner(x, new Address2(String(owner)))
      );
      if (correspondingInput && "predicateGasUsed" in correspondingInput && bn9(correspondingInput.predicateGasUsed).gt(0)) {
        i.predicateGasUsed = correspondingInput.predicateGasUsed;
      }
    });
  }
  byteLength() {
    return this.toTransactionBytes().byteLength;
  }
  /**
   * @hidden
   *
   * Used internally to update the state of a transaction request.
   *
   * @param state - The state to update.
   */
  updateState(chainId, state, summary) {
    if (!state) {
      this.flag = { state: void 0, transactionId: void 0, summary: void 0 };
      return;
    }
    const transactionId = this.getTransactionId(chainId);
    this.flag = { state, transactionId, summary };
  }
};

// src/providers/transaction-request/blob-transaction-request.ts
import { clone as clone3 } from "ramda";

// src/providers/transaction-request/hash-transaction.ts
import { ZeroBytes32 as ZeroBytes325 } from "@fuel-ts/address/configs";
import { uint64ToBytesBE, sha256 } from "@fuel-ts/hasher";
import { bn as bn10 } from "@fuel-ts/math";
import { TransactionType as TransactionType3, InputType as InputType5, OutputType as OutputType5, TransactionCoder as TransactionCoder2 } from "@fuel-ts/transactions";
import { concat as concat3 } from "@fuel-ts/utils";
import { clone as clone2 } from "ramda";
function hashTransaction(transactionRequest, chainId) {
  const transaction = transactionRequest.toTransaction();
  if (transaction.type === TransactionType3.Script) {
    transaction.receiptsRoot = ZeroBytes325;
  }
  transaction.inputs = transaction.inputs.map((input) => {
    const inputClone = clone2(input);
    switch (inputClone.type) {
      // Zero out on signing: txPointer, predicateGasUsed
      case InputType5.Coin: {
        inputClone.txPointer = {
          blockHeight: 0,
          txIndex: 0
        };
        inputClone.predicateGasUsed = bn10(0);
        return inputClone;
      }
      // Zero out on signing: predicateGasUsed
      case InputType5.Message: {
        inputClone.predicateGasUsed = bn10(0);
        return inputClone;
      }
      // Zero out on signing: txID, outputIndex, balanceRoot, stateRoot, and txPointer
      case InputType5.Contract: {
        inputClone.txPointer = {
          blockHeight: 0,
          txIndex: 0
        };
        inputClone.txID = ZeroBytes325;
        inputClone.outputIndex = 0;
        inputClone.balanceRoot = ZeroBytes325;
        inputClone.stateRoot = ZeroBytes325;
        return inputClone;
      }
      default:
        return inputClone;
    }
  });
  transaction.outputs = transaction.outputs.map((output) => {
    const outputClone = clone2(output);
    switch (outputClone.type) {
      // Zero out on signing: balanceRoot, stateRoot
      case OutputType5.Contract: {
        outputClone.balanceRoot = ZeroBytes325;
        outputClone.stateRoot = ZeroBytes325;
        return outputClone;
      }
      // Zero out on signing: amount
      case OutputType5.Change: {
        outputClone.amount = bn10(0);
        return outputClone;
      }
      // Zero out on signing: amount, to and assetId
      case OutputType5.Variable: {
        outputClone.to = ZeroBytes325;
        outputClone.amount = bn10(0);
        outputClone.assetId = ZeroBytes325;
        return outputClone;
      }
      default:
        return outputClone;
    }
  });
  transaction.witnessesCount = 0;
  transaction.witnesses = [];
  const chainIdBytes = uint64ToBytesBE(chainId);
  const concatenatedData = concat3([chainIdBytes, new TransactionCoder2().encode(transaction)]);
  return sha256(concatenatedData);
}
__name(hashTransaction, "hashTransaction");

// src/providers/transaction-request/blob-transaction-request.ts
var BlobTransactionRequest = class extends BaseTransactionRequest {
  static {
    __name(this, "BlobTransactionRequest");
  }
  static from(obj) {
    return new this(clone3(obj));
  }
  /** Type of the transaction */
  type = TransactionType2.Blob;
  /** Blob ID */
  blobId;
  /** Witness index of the bytecode to create */
  witnessIndex;
  /**
   * Creates an instance `BlobTransactionRequest`.
   *
   * @param blobTransactionRequestLike - The initial values for the instance
   */
  constructor({ witnessIndex, blobId, ...rest }) {
    super(rest);
    this.blobId = blobId;
    this.witnessIndex = witnessIndex ?? 0;
  }
  /**
   * Converts the transaction request to a `TransactionBlob`.
   *
   * @returns The transaction create object.
   */
  toTransaction() {
    const baseTransaction = this.getBaseTransaction();
    const { witnessIndex, blobId } = this;
    return {
      type: TransactionType2.Blob,
      ...baseTransaction,
      blobId,
      witnessIndex
    };
  }
  /**
   * Gets the Transaction Request by hashing the transaction.
   *
   * @param chainId - The chain ID.
   *
   * @returns - A hash of the transaction, which is the transaction ID.
   */
  getTransactionId(chainId) {
    return hashTransaction(this, chainId);
  }
  /**
   * Calculates the metadata gas cost for a blob transaction.
   *
   * @param gasCosts - gas costs passed from the chain.
   * @returns metadata gas cost for the blob transaction.
   */
  metadataGas(gasCosts) {
    return calculateMetadataGasForTxBlob({
      gasCosts,
      txBytesSize: this.byteSize(),
      witnessBytesSize: this.witnesses[this.witnessIndex].length
    });
  }
};

// src/providers/transaction-request/create-transaction-request.ts
import { ZeroBytes32 as ZeroBytes326 } from "@fuel-ts/address/configs";
import { bn as bn11 } from "@fuel-ts/math";
import { TransactionType as TransactionType4, OutputType as OutputType6 } from "@fuel-ts/transactions";
import { arrayify as arrayify7, hexlify as hexlify13 } from "@fuel-ts/utils";
import { clone as clone4 } from "ramda";

// src/providers/transaction-request/storage-slot.ts
import { arrayify as arrayify6, hexlify as hexlify12 } from "@fuel-ts/utils";
var getStorageValue = /* @__PURE__ */ __name((value) => {
  const v = new Uint8Array(32);
  v.set(arrayify6(value));
  return v;
}, "getStorageValue");
var storageSlotify = /* @__PURE__ */ __name((storageSlot) => {
  let key;
  let value;
  if (Array.isArray(storageSlot)) {
    key = storageSlot[0];
    value = storageSlot[1];
  } else {
    key = storageSlot.key;
    value = storageSlot.value;
  }
  return {
    key: hexlify12(key),
    value: hexlify12(getStorageValue(value))
  };
}, "storageSlotify");

// src/providers/transaction-request/create-transaction-request.ts
var CreateTransactionRequest = class extends BaseTransactionRequest {
  static {
    __name(this, "CreateTransactionRequest");
  }
  static from(obj) {
    return new this(clone4(obj));
  }
  /** Type of the transaction */
  type = TransactionType4.Create;
  /** Witness index of contract bytecode to create */
  bytecodeWitnessIndex;
  /** Salt */
  salt;
  /** List of storage slots to initialize */
  storageSlots;
  /**
   * Creates an instance `CreateTransactionRequest`.
   *
   * @param createTransactionRequestLike - The initial values for the instance
   */
  constructor({ bytecodeWitnessIndex, salt, storageSlots, ...rest }) {
    super(rest);
    this.bytecodeWitnessIndex = bytecodeWitnessIndex ?? 0;
    this.salt = hexlify13(salt ?? ZeroBytes326);
    this.storageSlots = [...storageSlots ?? []];
  }
  /**
   * Converts the transaction request to a `TransactionCreate`.
   *
   * @returns The transaction create object.
   */
  toTransaction() {
    const baseTransaction = this.getBaseTransaction();
    const bytecodeWitnessIndex = this.bytecodeWitnessIndex;
    const storageSlots = this.storageSlots?.map(storageSlotify) ?? [];
    return {
      type: TransactionType4.Create,
      ...baseTransaction,
      bytecodeWitnessIndex,
      storageSlotsCount: bn11(storageSlots.length),
      salt: this.salt ? hexlify13(this.salt) : ZeroBytes326,
      storageSlots
    };
  }
  /**
   * Get contract created outputs for the transaction.
   *
   * @returns An array of contract created transaction request outputs.
   */
  getContractCreatedOutputs() {
    return this.outputs.filter(
      (output) => output.type === OutputType6.ContractCreated
    );
  }
  /**
   * Gets the Transaction Request by hashing the transaction.
   *
   * @param chainId - The chain ID.
   *
   * @returns - A hash of the transaction, which is the transaction ID.
   */
  getTransactionId(chainId) {
    return hashTransaction(this, chainId);
  }
  /**
   * Adds a contract created output to the transaction request.
   *
   * @param contractId - The contract ID.
   * @param stateRoot - The state root.
   */
  addContractCreatedOutput(contractId, stateRoot) {
    this.pushOutput({
      type: OutputType6.ContractCreated,
      contractId,
      stateRoot
    });
  }
  metadataGas(gasCosts) {
    return calculateMetadataGasForTxCreate({
      contractBytesSize: bn11(arrayify7(this.witnesses[this.bytecodeWitnessIndex] || "0x").length),
      gasCosts,
      stateRootSize: this.storageSlots.length,
      txBytesSize: this.byteSize()
    });
  }
};

// src/providers/transaction-request/script-transaction-request.ts
import { Interface } from "@fuel-ts/abi-coder";
import { addressify as addressify2 } from "@fuel-ts/address";
import { ZeroBytes32 as ZeroBytes327 } from "@fuel-ts/address/configs";
import { bn as bn12 } from "@fuel-ts/math";
import { InputType as InputType6, OutputType as OutputType7, TransactionType as TransactionType5 } from "@fuel-ts/transactions";
import { arrayify as arrayify9, hexlify as hexlify14 } from "@fuel-ts/utils";
import { clone as clone5 } from "ramda";

// src/providers/transaction-request/scripts.ts
import { arrayify as arrayify8 } from "@fuel-ts/utils";
var returnZeroScript = {
  /*
      Opcode::RET(REG_ZERO)
      Opcode::NOOP
    */
  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
  bytes: arrayify8("0x24000000"),
  encodeScriptData: /* @__PURE__ */ __name(() => new Uint8Array(0), "encodeScriptData")
};
var withdrawScript = {
  /*
          The following code loads some basic values into registers and calls SMO to create an output message
          5040C010 	- ADDI r16 $is i16   [r16 now points to memory 16 bytes from the start of this program (start of receiver data)]
          5D44C006	- LW r17 $is i6      [r17 set to the 6th word in this program (6*8=48 bytes from the start of this program)]
          4C400011	- SMO r16 r0 r0 r17  [send message out to address starting at memory position r16 with amount in r17]
          24000000	- RET                [return 0]
          00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 [recipient address]
          00000000 00000000 [amount value]
      */
  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
  bytes: arrayify8("0x5040C0105D44C0064C40001124000000"),
  encodeScriptData: /* @__PURE__ */ __name(() => new Uint8Array(0), "encodeScriptData")
};

// src/providers/transaction-request/script-transaction-request.ts
var ScriptTransactionRequest = class extends BaseTransactionRequest {
  static {
    __name(this, "ScriptTransactionRequest");
  }
  static from(obj) {
    return new this(clone5(obj));
  }
  /** Type of the transaction */
  type = TransactionType5.Script;
  /** Gas limit for transaction */
  gasLimit;
  /** Script to execute */
  script;
  /** Script input data (parameters) */
  scriptData;
  abis;
  /**
   * Constructor for `ScriptTransactionRequest`.
   *
   * @param scriptTransactionRequestLike - The initial values for the instance.
   */
  constructor({ script, scriptData, gasLimit, ...rest } = {}) {
    super(rest);
    this.gasLimit = bn12(gasLimit);
    this.script = arrayify9(script ?? returnZeroScript.bytes);
    this.scriptData = arrayify9(scriptData ?? returnZeroScript.encodeScriptData());
    this.abis = rest.abis;
  }
  /**
   * Helper function to estimate and fund the transaction request with a specified account.
   *
   * @param account - The account to fund the transaction.
   * @param params - The parameters for the transaction cost.
   * @returns The current instance of the `ScriptTransactionRequest` funded.
   *
   * @deprecated Use `provider.assembleTx` instead.
   * Check the migration guide https://docs.fuel.network/guide/assembling-transactions/migration-guide.html for more information.
   */
  async estimateAndFund(account, { signatureCallback, quantities = [] } = {}) {
    const txCost = await account.getTransactionCost(this, { signatureCallback, quantities });
    this.maxFee = txCost.maxFee;
    this.gasLimit = txCost.gasUsed;
    await account.fund(this, txCost);
    return this;
  }
  /**
   * Converts the transaction request to a `TransactionScript`.
   *
   * @returns The transaction script object.
   */
  toTransaction() {
    const script = arrayify9(this.script ?? "0x");
    const scriptData = arrayify9(this.scriptData ?? "0x");
    return {
      type: TransactionType5.Script,
      scriptGasLimit: this.gasLimit,
      ...super.getBaseTransaction(),
      scriptLength: bn12(script.length),
      scriptDataLength: bn12(scriptData.length),
      receiptsRoot: ZeroBytes327,
      script: hexlify14(script),
      scriptData: hexlify14(scriptData)
    };
  }
  /**
   * Get contract inputs for the transaction.
   *
   * @returns An array of contract transaction request inputs.
   */
  getContractInputs() {
    return this.inputs.filter(
      (input) => input.type === InputType6.Contract
    );
  }
  /**
   * Get contract outputs for the transaction.
   *
   * @returns An array of contract transaction request outputs.
   */
  getContractOutputs() {
    return this.outputs.filter(
      (output) => output.type === OutputType7.Contract
    );
  }
  /**
   * Get variable outputs for the transaction.
   *
   * @returns An array of variable transaction request outputs.
   */
  getVariableOutputs() {
    return this.outputs.filter(
      (output) => output.type === OutputType7.Variable
    );
  }
  /**
   * Set the script and its data.
   *
   * @param script - The abstract script request.
   * @param data - The script data.
   */
  setScript(script, data) {
    this.scriptData = script.encodeScriptData(data);
    this.script = script.bytes;
  }
  /**
   * Adds variable outputs to the transaction request.
   *
   * @param numberOfVariables - The number of variables to add.
   * @returns The new length of the outputs array.
   */
  addVariableOutputs(numberOfVariables = 1) {
    let outputsNumber = numberOfVariables;
    while (outputsNumber) {
      this.pushOutput({
        type: OutputType7.Variable
      });
      outputsNumber -= 1;
    }
    return this.outputs.length - 1;
  }
  /**
   * Adds a variable output to the transaction request.
   *
   * @param to - The recipient address as a BytesLike object. Defaults to ZeroBytes32 if not provided.
   * @param amount - The amount to be transferred as a BigNumberish object. Defaults to 0 if not provided.
   * @param assetId - The asset ID as a BytesLike object. Defaults to ZeroBytes32 if not provided.
   */
  addVariableOutput(to, amount, assetId) {
    this.pushOutput({
      type: OutputType7.Variable,
      to,
      amount,
      assetId
    });
  }
  /**
   * Calculates the maximum gas for the transaction.
   *
   * @param chainInfo - The chain information.
   * @param minGas - The minimum gas.
   * @returns the maximum gas.
   */
  calculateMaxGas(chainInfo, minGas) {
    const { consensusParameters } = chainInfo;
    const {
      feeParameters: { gasPerByte },
      txParameters: { maxGasPerTx }
    } = consensusParameters;
    const witnessesLength = this.toTransaction().witnesses.reduce(
      (acc, wit) => acc + wit.dataLength,
      0
    );
    return getMaxGas({
      gasPerByte,
      minGas,
      witnessesLength,
      witnessLimit: this.witnessLimit,
      gasLimit: this.gasLimit,
      maxGasPerTx
    });
  }
  /**
   * Adds a contract input and output to the transaction request.
   *
   * @param contract - The contract ID.
   * @returns The current instance of the `ScriptTransactionRequest`.
   */
  addContractInputAndOutput(contract) {
    const contractAddress = addressify2(contract);
    if (this.getContractInputs().find((i) => i.contractId === contractAddress.toB256())) {
      return this;
    }
    const inputIndex = super.pushInput({
      type: InputType6.Contract,
      contractId: contractAddress.toB256(),
      txPointer: "0x00000000000000000000000000000000"
    });
    this.pushOutput({
      type: OutputType7.Contract,
      inputIndex
    });
    return this;
  }
  /**
   * Gets the Transaction Request by hashing the transaction.
   *
   * @param chainId - The chain ID.
   *
   * @returns - A hash of the transaction, which is the transaction ID.
   */
  getTransactionId(chainId) {
    return hashTransaction(this, chainId);
  }
  /**
   * Sets the data for the transaction request.
   *
   * @param abi - Script JSON ABI.
   * @param args - The input arguments.
   * @returns The current instance of the `ScriptTransactionRequest`.
   */
  setData(abi, args) {
    const abiInterface = new Interface(abi);
    this.scriptData = abiInterface.functions.main.encodeArguments(args);
    return this;
  }
  metadataGas(gasCosts) {
    return calculateMetadataGasForTxScript({
      gasCosts,
      txBytesSize: this.byteSize()
    });
  }
};

// src/providers/transaction-request/upgrade-transaction-request.ts
import { FuelError as FuelError12 } from "@fuel-ts/errors";
import { hash as hash2 } from "@fuel-ts/hasher";
import {
  TransactionType as TransactionType6,
  UpgradePurposeTypeEnum
} from "@fuel-ts/transactions";
import { hexlify as hexlify15 } from "@fuel-ts/utils";
import { clone as clone6 } from "ramda";
var UpgradeTransactionRequest = class _UpgradeTransactionRequest extends BaseTransactionRequest {
  static {
    __name(this, "UpgradeTransactionRequest");
  }
  static from(obj) {
    if (obj instanceof _UpgradeTransactionRequest) {
      return obj;
    }
    return new this(clone6(obj));
  }
  /** The type of transaction */
  type = TransactionType6.Upgrade;
  /** The upgrade purpose */
  upgradePurpose;
  /** Witness index of consensus */
  bytecodeWitnessIndex;
  /**
   * Creates an instance `UpgradeTransactionRequest`.
   *
   * @param upgradeTransactionRequestLike - The initial values for the instance
   */
  constructor({
    upgradePurpose,
    bytecodeWitnessIndex,
    ...rest
  } = {}) {
    super(rest);
    this.bytecodeWitnessIndex = bytecodeWitnessIndex ?? 0;
    this.upgradePurpose = upgradePurpose ?? {
      type: UpgradePurposeTypeEnum.ConsensusParameters,
      checksum: "0x"
    };
  }
  /**
   * Adds a consensus parameters upgrade purpose.
   *
   * @param consensus - The consensus bytecode.
   *
   * @returns - The current instance of `UpgradeTransactionRequest`.
   */
  addConsensusParametersUpgradePurpose(consensus) {
    this.bytecodeWitnessIndex = this.addWitness(consensus);
    this.upgradePurpose = {
      type: UpgradePurposeTypeEnum.ConsensusParameters,
      checksum: hash2(consensus)
    };
    return this;
  }
  /**
   * Adds a state transition upgrade purpose.
   *
   * @param bytecodeRoot - The Merkle root of the state transition.
   *
   * @returns - The current instance of `UpgradeTransactionRequest`.
   */
  addStateTransitionUpgradePurpose(bytecodeRoot) {
    this.upgradePurpose = {
      type: UpgradePurposeTypeEnum.StateTransition,
      data: hexlify15(bytecodeRoot)
    };
    return this;
  }
  /**
   * Adds an upgrade purpose.
   *
   * @param type - The upgrade purpose type.
   * @param data - The bytecode or merkle root of upgrade purpose
   *
   * @returns - The current instance of `UpgradeTransactionRequest`.
   */
  addUpgradePurpose(type, data) {
    if (type === UpgradePurposeTypeEnum.ConsensusParameters) {
      this.addConsensusParametersUpgradePurpose(data);
    }
    if (type === UpgradePurposeTypeEnum.StateTransition) {
      this.addStateTransitionUpgradePurpose(data);
    }
    return this;
  }
  /**
   * Converts the transaction request to a `TransactionUpgrade`.
   *
   * @returns The transaction create object.
   */
  toTransaction() {
    let upgradePurpose;
    if (this.upgradePurpose.type === UpgradePurposeTypeEnum.ConsensusParameters) {
      upgradePurpose = {
        type: UpgradePurposeTypeEnum.ConsensusParameters,
        data: {
          witnessIndex: this.bytecodeWitnessIndex,
          checksum: this.upgradePurpose.checksum
        }
      };
    } else if (this.upgradePurpose.type === UpgradePurposeTypeEnum.StateTransition) {
      upgradePurpose = {
        type: UpgradePurposeTypeEnum.StateTransition,
        data: {
          bytecodeRoot: hexlify15(this.upgradePurpose.data)
        }
      };
    } else {
      throw new FuelError12(FuelError12.CODES.NOT_IMPLEMENTED, "Invalid upgrade purpose");
    }
    return {
      type: TransactionType6.Upgrade,
      ...super.getBaseTransaction(),
      upgradePurpose
    };
  }
  /**
   * Gets the Transaction ID by hashing the transaction
   *
   * @param chainId - The chain ID.
   *
   * @returns - A hash of the transaction, which is the transaction ID.
   */
  getTransactionId(chainId) {
    return hashTransaction(this, chainId);
  }
  /**
   * Calculates the metadata gas cost for an upgrade transaction.
   *
   * @param gasCosts - gas costs passed from the chain.
   *
   * @returns metadata gas cost for the upgrade transaction.
   */
  metadataGas(gasCosts) {
    const txBytesSize = this.byteSize();
    if (this.upgradePurpose.type === UpgradePurposeTypeEnum.ConsensusParameters) {
      const witnessIndex = this.bytecodeWitnessIndex;
      const consensusSize = this.witnesses[witnessIndex].length;
      return calculateMetadataGasForTxUpgrade({
        gasCosts,
        txBytesSize,
        consensusSize
      });
    }
    if (this.upgradePurpose.type === UpgradePurposeTypeEnum.StateTransition) {
      return calculateMetadataGasForTxUpgrade({
        gasCosts,
        txBytesSize
      });
    }
    throw new FuelError12(FuelError12.CODES.NOT_IMPLEMENTED, "Invalid upgrade purpose");
  }
};

// src/providers/transaction-request/upload-transaction-request.ts
import { ZeroBytes32 as ZeroBytes328 } from "@fuel-ts/address/configs";
import { TransactionType as TransactionType7 } from "@fuel-ts/transactions";
import { arrayify as arrayify10, hexlify as hexlify16 } from "@fuel-ts/utils";
import { clone as clone7 } from "ramda";
var UploadTransactionRequest = class _UploadTransactionRequest extends BaseTransactionRequest {
  static {
    __name(this, "UploadTransactionRequest");
  }
  static from(obj) {
    if (obj instanceof _UploadTransactionRequest) {
      return obj;
    }
    return new this(clone7(obj));
  }
  /** Type of the transaction */
  type = TransactionType7.Upload;
  /** The witness index of the subsection of the bytecode. */
  witnessIndex;
  /** The subsection data. */
  subsection;
  /**
   * Creates an instance `UploadTransactionRequest`.
   *
   * @param uploadTransactionRequestLike - The initial values for the instance
   */
  constructor({ witnessIndex, subsection, ...rest } = {}) {
    super(rest);
    this.witnessIndex = witnessIndex ?? 0;
    this.subsection = subsection ?? {
      proofSet: [],
      root: ZeroBytes328,
      subsectionIndex: 0,
      subsectionsNumber: 0
    };
  }
  /**
   * Adds the subsection.
   *
   * @param subsection - The subsection data.
   */
  addSubsection(subsection) {
    const { subsection: subsectionBytecode, ...rest } = subsection;
    this.subsection = rest;
    this.witnessIndex = this.addWitness(subsectionBytecode);
  }
  /**
   * Gets the Transaction Request by hashing the transaction.
   *
   * @param chainId - The chain ID.
   *
   * @returns - A hash of the transaction, which is the transaction ID.
   */
  getTransactionId(chainId) {
    return hashTransaction(this, chainId);
  }
  /**
   * Converts the transaction request to a `TransactionUpload`.
   *
   * @returns The transaction create object.
   */
  toTransaction() {
    const baseTransaction = this.getBaseTransaction();
    const { subsectionIndex, subsectionsNumber, root, proofSet } = this.subsection;
    return {
      type: TransactionType7.Upload,
      ...baseTransaction,
      subsectionIndex,
      subsectionsNumber,
      root: hexlify16(root),
      proofSet: proofSet.map(hexlify16),
      witnessIndex: this.witnessIndex,
      proofSetCount: proofSet.length
    };
  }
  /**
   * Calculates the metadata gas cost for an upload transaction.
   *
   * @param gasCosts - gas costs passed from the chain.
   *
   * @returns metadata gas cost for the upload transaction.
   */
  metadataGas(gasCosts) {
    return calculateMetadataGasForTxUpload({
      gasCosts,
      txBytesSize: this.byteSize(),
      subsectionSize: arrayify10(this.witnesses[this.witnessIndex]).length,
      subsectionsSize: this.subsection.subsectionsNumber
    });
  }
  /**
   * Calculates the minimum gas for an upload transaction.
   *
   * @param chainInfo - The chain information.
   *
   * @returns the minimum gas for the upload transaction
   */
  calculateMinGas(chainInfo) {
    const minGas = super.calculateMinGas(chainInfo);
    const { gasCosts } = chainInfo.consensusParameters;
    const bytecode = this.witnesses[this.witnessIndex] ?? ZeroBytes328;
    return calculateMinGasForTxUpload({
      gasCosts,
      baseMinGas: minGas.toNumber(),
      subsectionSize: arrayify10(bytecode).length
    });
  }
};

// src/providers/transaction-request/utils.ts
import { ErrorCode as ErrorCode10, FuelError as FuelError13 } from "@fuel-ts/errors";
import { TransactionType as TransactionType8 } from "@fuel-ts/transactions";
var transactionRequestify = /* @__PURE__ */ __name((obj) => {
  if (obj instanceof ScriptTransactionRequest || obj instanceof CreateTransactionRequest || obj instanceof BlobTransactionRequest || obj instanceof UpgradeTransactionRequest || obj instanceof UploadTransactionRequest) {
    return obj;
  }
  const { type } = obj;
  switch (obj.type) {
    case TransactionType8.Script: {
      return ScriptTransactionRequest.from(obj);
    }
    case TransactionType8.Create: {
      return CreateTransactionRequest.from(obj);
    }
    case TransactionType8.Blob: {
      return BlobTransactionRequest.from(obj);
    }
    case TransactionType8.Upgrade: {
      return UpgradeTransactionRequest.from(obj);
    }
    case TransactionType8.Upload: {
      return UploadTransactionRequest.from(obj);
    }
    default: {
      throw new FuelError13(
        ErrorCode10.UNSUPPORTED_TRANSACTION_TYPE,
        `Unsupported transaction type: ${type}.`
      );
    }
  }
}, "transactionRequestify");
var isTransactionTypeScript = /* @__PURE__ */ __name((request) => request.type === TransactionType8.Script, "isTransactionTypeScript");
var isTransactionTypeCreate = /* @__PURE__ */ __name((request) => request.type === TransactionType8.Create, "isTransactionTypeCreate");

// src/providers/resource-cache.ts
var cache = /* @__PURE__ */ new Map();
var ResourceCache = class {
  static {
    __name(this, "ResourceCache");
  }
  ttl;
  constructor(ttl) {
    this.ttl = ttl;
    if (typeof ttl !== "number" || this.ttl <= 0) {
      throw new FuelError14(
        ErrorCode11.INVALID_TTL,
        `Invalid TTL: ${this.ttl}. Use a value greater than zero.`
      );
    }
  }
  // Add resources to the cache
  set(transactionId, inputs) {
    const transactionResourceCache = this.setupResourcesCache(inputs);
    cache.set(transactionId, transactionResourceCache);
  }
  unset(transactionId) {
    cache.delete(transactionId);
  }
  getActiveData(owner) {
    const activeData = { utxos: [], messages: [] };
    const currentTime = Date.now();
    const expired = [];
    cache.forEach((resource, transactionId) => {
      const isActive = currentTime - resource.timestamp < this.ttl;
      if (isActive) {
        const resourcesFromOwner = resource.owners.get(owner);
        if (resourcesFromOwner) {
          activeData.utxos.push(...resourcesFromOwner.utxos);
          activeData.messages.push(...resourcesFromOwner.messages);
        }
      } else {
        expired.push(transactionId);
      }
    });
    expired.forEach(this.unset);
    activeData.utxos.reverse();
    activeData.messages.reverse();
    return activeData;
  }
  isCached(owner, key) {
    const currentTime = Date.now();
    let cached = false;
    const expired = [];
    for (const [transactionId, resourceData] of cache.entries()) {
      const isActive = currentTime - resourceData.timestamp < this.ttl;
      if (isActive) {
        const resourcesFromOwner = resourceData.owners.get(owner);
        if (resourcesFromOwner?.utxos.has(key) || resourcesFromOwner?.messages.has(key)) {
          cached = true;
          break;
        }
      } else {
        expired.push(transactionId);
      }
    }
    expired.forEach(this.unset);
    return cached;
  }
  clear() {
    cache.clear();
  }
  setupResourcesCache(inputs) {
    const currentTime = Date.now();
    const transactionResourcesCache = {
      owners: /* @__PURE__ */ new Map(),
      timestamp: currentTime
    };
    inputs.filter(isRequestInputCoinOrMessage).forEach((input) => {
      const { owner, key, type } = this.extractResourceData(input);
      if (!transactionResourcesCache.owners.has(owner)) {
        transactionResourcesCache.owners.set(owner, { utxos: /* @__PURE__ */ new Set(), messages: /* @__PURE__ */ new Set() });
      }
      if (type === "utxo") {
        transactionResourcesCache.owners.get(owner)?.utxos.add(key);
      } else {
        transactionResourcesCache.owners.get(owner)?.messages.add(key);
      }
    });
    return transactionResourcesCache;
  }
  extractResourceData(input) {
    if (isRequestInputCoin(input)) {
      return { owner: hexlify17(input.owner), key: hexlify17(input.id), type: "utxo" };
    }
    return { owner: hexlify17(input.recipient), key: hexlify17(input.nonce), type: "message" };
  }
};

// src/providers/transaction-response/transaction-response.ts
import { ErrorCode as ErrorCode15, FuelError as FuelError18 } from "@fuel-ts/errors";
import { bn as bn17 } from "@fuel-ts/math";
import { TransactionCoder as TransactionCoder5, TxPointerCoder } from "@fuel-ts/transactions";
import { arrayify as arrayify12 } from "@fuel-ts/utils";

// src/providers/transaction-summary/assemble-transaction-summary.ts
import { bn as bn16 } from "@fuel-ts/math";
import { PolicyType as PolicyType3, TransactionCoder as TransactionCoder4 } from "@fuel-ts/transactions";
import { DateTime, hexlify as hexlify18 } from "@fuel-ts/utils";

// src/providers/transaction-summary/calculate-tx-fee-for-summary.ts
import { bn as bn13 } from "@fuel-ts/math";
import { PolicyType as PolicyType2, TransactionCoder as TransactionCoder3, TransactionType as TransactionType9 } from "@fuel-ts/transactions";
import { arrayify as arrayify11 } from "@fuel-ts/utils";
var calculateTXFeeForSummary = /* @__PURE__ */ __name((params) => {
  const {
    gasPrice,
    rawPayload,
    tip,
    consensusParameters: { gasCosts, feeParams, maxGasPerTx }
  } = params;
  const gasPerByte = bn13(feeParams.gasPerByte);
  const gasPriceFactor = bn13(feeParams.gasPriceFactor);
  const transactionBytes = arrayify11(rawPayload);
  const [transaction] = new TransactionCoder3().decode(transactionBytes, 0);
  const { type, witnesses, inputs, policies } = transaction;
  let metadataGas = bn13(0);
  let gasLimit = bn13(0);
  if (type !== TransactionType9.Create && type !== TransactionType9.Script) {
    return bn13(0);
  }
  if (type === TransactionType9.Create) {
    const { bytecodeWitnessIndex, storageSlots } = transaction;
    const contractBytesSize = bn13(arrayify11(witnesses[bytecodeWitnessIndex].data).length);
    metadataGas = calculateMetadataGasForTxCreate({
      contractBytesSize,
      gasCosts,
      stateRootSize: storageSlots.length || 0,
      txBytesSize: transactionBytes.length
    });
  } else {
    const { scriptGasLimit } = transaction;
    if (scriptGasLimit) {
      gasLimit = scriptGasLimit;
    }
    metadataGas = calculateMetadataGasForTxScript({
      gasCosts,
      txBytesSize: transactionBytes.length
    });
  }
  const minGas = getMinGas({
    gasCosts,
    gasPerByte: bn13(gasPerByte),
    inputs,
    metadataGas,
    txBytesSize: transactionBytes.length
  });
  const witnessLimit = policies.find((policy) => policy.type === PolicyType2.WitnessLimit)?.data;
  const witnessesLength = witnesses.reduce((acc, wit) => acc + wit.dataLength, 0);
  const maxGas = getMaxGas({
    gasPerByte,
    minGas,
    witnessesLength,
    gasLimit,
    witnessLimit,
    maxGasPerTx
  });
  const maxFee = calculateGasFee({
    gasPrice,
    gas: maxGas,
    priceFactor: gasPriceFactor,
    tip
  });
  return maxFee;
}, "calculateTXFeeForSummary");

// src/providers/transaction-summary/operations.ts
import { ZeroBytes32 as ZeroBytes329 } from "@fuel-ts/address/configs";
import { ErrorCode as ErrorCode13, FuelError as FuelError16 } from "@fuel-ts/errors";
import { bn as bn14 } from "@fuel-ts/math";
import { ReceiptType as ReceiptType5, TransactionType as TransactionType10 } from "@fuel-ts/transactions";

// src/providers/transaction-summary/input.ts
import { ErrorCode as ErrorCode12, FuelError as FuelError15 } from "@fuel-ts/errors";
import { BN } from "@fuel-ts/math";
import { InputType as InputType7 } from "@fuel-ts/transactions";
function getInputsByTypes(inputs, types) {
  return inputs.filter((i) => types.includes(i.type));
}
__name(getInputsByTypes, "getInputsByTypes");
function getInputsByType(inputs, type) {
  return inputs.filter((i) => i.type === type);
}
__name(getInputsByType, "getInputsByType");
function getInputsCoin(inputs) {
  return getInputsByType(inputs, InputType7.Coin);
}
__name(getInputsCoin, "getInputsCoin");
function getInputsMessage(inputs) {
  return getInputsByType(inputs, InputType7.Message);
}
__name(getInputsMessage, "getInputsMessage");
function getInputsCoinAndMessage(inputs) {
  return getInputsByTypes(inputs, [InputType7.Coin, InputType7.Message]);
}
__name(getInputsCoinAndMessage, "getInputsCoinAndMessage");
function isInputCoin(input) {
  return input.type === InputType7.Coin;
}
__name(isInputCoin, "isInputCoin");
function getInputsContract(inputs) {
  return getInputsByType(inputs, InputType7.Contract);
}
__name(getInputsContract, "getInputsContract");
function findCoinInput(inputs, assetId) {
  const coinInputs = getInputsCoin(inputs);
  return coinInputs.find((i) => i.assetId === assetId);
}
__name(findCoinInput, "findCoinInput");
function aggregateInputsAmountsByAssetAndOwner(inputs, baseAssetId) {
  const aggregated = /* @__PURE__ */ new Map();
  getInputsCoinAndMessage(inputs).forEach((input) => {
    const assetId = isInputCoin(input) ? input.assetId : baseAssetId;
    const owner = isInputCoin(input) ? input.owner : input.recipient;
    let ownersMap = aggregated.get(assetId);
    if (!ownersMap) {
      ownersMap = /* @__PURE__ */ new Map();
      aggregated.set(assetId, ownersMap);
    }
    let ownerBalance = ownersMap.get(owner);
    if (!ownerBalance) {
      ownerBalance = new BN(0);
      ownersMap.set(owner, ownerBalance);
    }
    ownersMap.set(owner, ownerBalance.add(input.amount));
  });
  return aggregated;
}
__name(aggregateInputsAmountsByAssetAndOwner, "aggregateInputsAmountsByAssetAndOwner");
function findMessageInput(inputs) {
  return getInputsMessage(inputs)?.[0];
}
__name(findMessageInput, "findMessageInput");
function getInputFromAssetId(inputs, assetId, isBaseAsset = false) {
  const coinInput = findCoinInput(inputs, assetId);
  if (coinInput) {
    return coinInput;
  }
  if (isBaseAsset) {
    return findMessageInput(inputs);
  }
  return void 0;
}
__name(getInputFromAssetId, "getInputFromAssetId");
function getInputContractFromIndex(inputs, inputIndex) {
  if (inputIndex == null) {
    return void 0;
  }
  const contractInput = inputs?.[inputIndex];
  if (!contractInput) {
    return void 0;
  }
  if (contractInput.type !== InputType7.Contract) {
    throw new FuelError15(
      ErrorCode12.INVALID_TRANSACTION_INPUT,
      `Contract input should be of type 'contract'.`
    );
  }
  return contractInput;
}
__name(getInputContractFromIndex, "getInputContractFromIndex");
function getInputAccountAddress(input) {
  if (input.type === InputType7.Coin) {
    return input.owner.toString();
  }
  if (input.type === InputType7.Message) {
    return input.recipient.toString();
  }
  return "";
}
__name(getInputAccountAddress, "getInputAccountAddress");

// src/providers/transaction-summary/output.ts
import { OutputType as OutputType8 } from "@fuel-ts/transactions";
function getOutputsByType(outputs, type) {
  return outputs.filter((o) => o.type === type);
}
__name(getOutputsByType, "getOutputsByType");
function getOutputsContractCreated(outputs) {
  return getOutputsByType(outputs, OutputType8.ContractCreated);
}
__name(getOutputsContractCreated, "getOutputsContractCreated");
function getOutputsCoin(outputs) {
  return getOutputsByType(outputs, OutputType8.Coin);
}
__name(getOutputsCoin, "getOutputsCoin");
function getOutputsChange(outputs) {
  return getOutputsByType(outputs, OutputType8.Change);
}
__name(getOutputsChange, "getOutputsChange");
function getOutputsContract(outputs) {
  return getOutputsByType(outputs, OutputType8.Contract);
}
__name(getOutputsContract, "getOutputsContract");

// src/providers/transaction-summary/operations.ts
function getReceiptsByType(receipts, type) {
  return (receipts ?? []).filter((r) => r.type === type);
}
__name(getReceiptsByType, "getReceiptsByType");
function getTransactionTypeName(transactionType) {
  switch (transactionType) {
    case TransactionType10.Mint:
      return "Mint" /* Mint */;
    case TransactionType10.Create:
      return "Create" /* Create */;
    case TransactionType10.Script:
      return "Script" /* Script */;
    case TransactionType10.Blob:
      return "Blob" /* Blob */;
    case TransactionType10.Upgrade:
      return "Upgrade" /* Upgrade */;
    case TransactionType10.Upload:
      return "Upload" /* Upload */;
    default:
      throw new FuelError16(
        ErrorCode13.UNSUPPORTED_TRANSACTION_TYPE,
        `Unsupported transaction type: ${transactionType}.`
      );
  }
}
__name(getTransactionTypeName, "getTransactionTypeName");
function isType(transactionType, type) {
  const txType = getTransactionTypeName(transactionType);
  return txType === type;
}
__name(isType, "isType");
function isTypeMint(transactionType) {
  return isType(transactionType, "Mint" /* Mint */);
}
__name(isTypeMint, "isTypeMint");
function isTypeCreate(transactionType) {
  return isType(transactionType, "Create" /* Create */);
}
__name(isTypeCreate, "isTypeCreate");
function isTypeScript(transactionType) {
  return isType(transactionType, "Script" /* Script */);
}
__name(isTypeScript, "isTypeScript");
function isTypeUpgrade(transactionType) {
  return isType(transactionType, "Upgrade" /* Upgrade */);
}
__name(isTypeUpgrade, "isTypeUpgrade");
function isTypeUpload(transactionType) {
  return isType(transactionType, "Upload" /* Upload */);
}
__name(isTypeUpload, "isTypeUpload");
function isTypeBlob(transactionType) {
  return isType(transactionType, "Blob" /* Blob */);
}
__name(isTypeBlob, "isTypeBlob");
function getReceiptsCall(receipts) {
  return getReceiptsByType(receipts, ReceiptType5.Call);
}
__name(getReceiptsCall, "getReceiptsCall");
function getReceiptsMessageOut(receipts) {
  return getReceiptsByType(receipts, ReceiptType5.MessageOut);
}
__name(getReceiptsMessageOut, "getReceiptsMessageOut");
function mergeAssets(op1, op2) {
  const assets1 = op1.assetsSent || [];
  const assets2 = op2.assetsSent || [];
  const assetMap = /* @__PURE__ */ new Map();
  assets1.forEach((asset) => {
    assetMap.set(asset.assetId, { ...asset });
  });
  assets2.forEach((asset) => {
    const existingAsset = assetMap.get(asset.assetId);
    if (existingAsset) {
      existingAsset.amount = bn14(existingAsset.amount).add(asset.amount);
    } else {
      assetMap.set(asset.assetId, { ...asset });
    }
  });
  return Array.from(assetMap.values());
}
__name(mergeAssets, "mergeAssets");
function isSameOperation(a, b) {
  return a.name === b.name && a.from?.address === b.from?.address && a.to?.address === b.to?.address && a.from?.type === b.from?.type && a.to?.type === b.to?.type;
}
__name(isSameOperation, "isSameOperation");
function mergeAssetsSent(existing, toAdd) {
  if (!toAdd.assetsSent?.length) {
    return existing.assetsSent;
  }
  return existing.assetsSent?.length ? mergeAssets(existing, toAdd) : toAdd.assetsSent;
}
__name(mergeAssetsSent, "mergeAssetsSent");
function mergeCalls(existing, toAdd) {
  if (!toAdd.calls?.length) {
    return existing.calls;
  }
  return [...existing.calls || [], ...toAdd.calls];
}
__name(mergeCalls, "mergeCalls");
function mergeOperations(existing, toAdd) {
  return {
    ...existing,
    assetsSent: mergeAssetsSent(existing, toAdd),
    calls: mergeCalls(existing, toAdd),
    receipts: [
      ...existing.receipts || [],
      ...toAdd.receipts?.filter((r) => !existing.receipts?.some((er) => er === r)) || []
    ]
  };
}
__name(mergeOperations, "mergeOperations");
function addOperation(operations, toAdd) {
  const existingIndex = operations.findIndex((op) => isSameOperation(op, toAdd));
  if (existingIndex === -1) {
    return [...operations, toAdd];
  }
  return operations.map((op, index) => index === existingIndex ? mergeOperations(op, toAdd) : op);
}
__name(addOperation, "addOperation");
function getWithdrawFromFuelOperations({
  inputs,
  receipts,
  baseAssetId
}) {
  const messageOutReceipts = getReceiptsMessageOut(receipts);
  const withdrawFromFuelOperations = messageOutReceipts.reduce(
    (prevWithdrawFromFuelOps, receipt) => {
      const input = getInputFromAssetId(inputs, baseAssetId, true);
      if (input) {
        const inputAddress = getInputAccountAddress(input);
        const newWithdrawFromFuelOps = addOperation(prevWithdrawFromFuelOps, {
          name: "Withdraw from Fuel" /* withdrawFromFuel */,
          from: {
            type: 1 /* account */,
            address: inputAddress
          },
          to: {
            type: 1 /* account */,
            address: receipt.recipient.toString(),
            chain: "ethereum" /* ethereum */
          },
          assetsSent: [
            {
              amount: receipt.amount,
              assetId: baseAssetId
            }
          ],
          receipts: [receipt]
        });
        return newWithdrawFromFuelOps;
      }
      return prevWithdrawFromFuelOps;
    },
    []
  );
  return withdrawFromFuelOperations;
}
__name(getWithdrawFromFuelOperations, "getWithdrawFromFuelOperations");
function getContractCalls(contractInput, abiMap, _receipt, _rawPayload, _maxInputs) {
  const abi = abiMap?.[contractInput.contractID];
  if (!abi) {
    return [];
  }
  return [];
}
__name(getContractCalls, "getContractCalls");
function getAssetsSent(receipt) {
  return receipt.amount?.isZero() ? void 0 : [
    {
      amount: receipt.amount,
      assetId: receipt.assetId
    }
  ];
}
__name(getAssetsSent, "getAssetsSent");
function processCallReceipt(receipt, contractInput, inputs, abiMap, rawPayload, maxInputs, baseAssetId) {
  const assetId = receipt.assetId === ZeroBytes329 ? baseAssetId : receipt.assetId;
  const input = getInputFromAssetId(inputs, assetId, assetId === baseAssetId);
  if (!input) {
    return [];
  }
  const inputAddress = getInputAccountAddress(input);
  const calls = getContractCalls(contractInput, abiMap, receipt, rawPayload, maxInputs);
  return [
    {
      name: "Contract call" /* contractCall */,
      from: {
        type: 1 /* account */,
        address: inputAddress
      },
      to: {
        type: 0 /* contract */,
        address: receipt.to
      },
      assetsSent: getAssetsSent(receipt),
      calls,
      receipts: [receipt]
    }
  ];
}
__name(processCallReceipt, "processCallReceipt");
function getContractCallOperations({
  inputs,
  outputs,
  receipts,
  abiMap,
  rawPayload,
  maxInputs,
  baseAssetId
}) {
  const contractCallReceipts = getReceiptsCall(receipts);
  const contractOutputs = getOutputsContract(outputs);
  return contractOutputs.flatMap((output) => {
    const contractInput = getInputContractFromIndex(inputs, output.inputIndex);
    if (!contractInput) {
      return [];
    }
    return contractCallReceipts.filter((receipt) => receipt.to === contractInput.contractID).flatMap(
      (receipt) => processCallReceipt(
        receipt,
        contractInput,
        inputs,
        abiMap,
        rawPayload,
        maxInputs,
        baseAssetId
      )
    );
  });
}
__name(getContractCallOperations, "getContractCallOperations");
function extractTransferOperationFromReceipt(receipt, contractInputs, changeOutputs) {
  const { to: toAddress, assetId, amount } = receipt;
  let { id: fromAddress } = receipt;
  const toType = contractInputs.some((input) => input.contractID === toAddress) ? 0 /* contract */ : 1 /* account */;
  if (ZeroBytes329 === fromAddress) {
    const change = changeOutputs.find((output) => output.assetId === assetId);
    fromAddress = change?.to || fromAddress;
  }
  const fromType = contractInputs.some((input) => input.contractID === fromAddress) ? 0 /* contract */ : 1 /* account */;
  return {
    name: "Transfer asset" /* transfer */,
    from: {
      type: fromType,
      address: fromAddress
    },
    to: {
      type: toType,
      address: toAddress
    },
    assetsSent: [
      {
        assetId: assetId.toString(),
        amount
      }
    ],
    receipts: [receipt]
  };
}
__name(extractTransferOperationFromReceipt, "extractTransferOperationFromReceipt");
function getTransferOperations({
  inputs,
  outputs,
  receipts,
  baseAssetId
}) {
  let operations = [];
  const coinOutputs = getOutputsCoin(outputs);
  const contractInputs = getInputsContract(inputs);
  const changeOutputs = getOutputsChange(outputs);
  const aggregated = aggregateInputsAmountsByAssetAndOwner(inputs, baseAssetId);
  coinOutputs.forEach(({ amount, assetId, to }) => {
    const txPayers = aggregated.get(assetId) || /* @__PURE__ */ new Map();
    let selectedPayer;
    let fallbackPayer;
    for (const [address, payedAmount] of txPayers) {
      if (!fallbackPayer) {
        fallbackPayer = address;
      }
      if (payedAmount.gte(amount)) {
        selectedPayer = address;
        break;
      }
    }
    selectedPayer = selectedPayer || fallbackPayer;
    if (selectedPayer) {
      operations = addOperation(operations, {
        name: "Transfer asset" /* transfer */,
        from: {
          type: 1 /* account */,
          address: selectedPayer
        },
        to: {
          type: 1 /* account */,
          address: to
        },
        assetsSent: [{ assetId, amount }]
      });
    }
  });
  const transferReceipts = getReceiptsByType(
    receipts,
    ReceiptType5.Transfer
  );
  const transferOutReceipts = getReceiptsByType(
    receipts,
    ReceiptType5.TransferOut
  );
  [...transferReceipts, ...transferOutReceipts].forEach((receipt) => {
    const operation = extractTransferOperationFromReceipt(receipt, contractInputs, changeOutputs);
    operations = addOperation(operations, operation);
  });
  return operations;
}
__name(getTransferOperations, "getTransferOperations");
function getPayProducerOperations(outputs) {
  const coinOutputs = getOutputsCoin(outputs);
  const payProducerOperations = coinOutputs.reduce((prev, output) => {
    const operations = addOperation(prev, {
      name: "Pay network fee to block producer" /* payBlockProducer */,
      from: {
        type: 1 /* account */,
        address: "Network"
      },
      to: {
        type: 1 /* account */,
        address: output.to.toString()
      },
      assetsSent: [
        {
          assetId: output.assetId.toString(),
          amount: output.amount
        }
      ]
    });
    return operations;
  }, []);
  return payProducerOperations;
}
__name(getPayProducerOperations, "getPayProducerOperations");
function getContractCreatedOperations({ inputs, outputs }) {
  const contractCreatedOutputs = getOutputsContractCreated(outputs);
  const input = getInputsCoinAndMessage(inputs)[0];
  const fromAddress = getInputAccountAddress(input);
  const contractCreatedOperations = contractCreatedOutputs.reduce((prev, contractCreatedOutput) => {
    const operations = addOperation(prev, {
      name: "Contract created" /* contractCreated */,
      from: {
        type: 1 /* account */,
        address: fromAddress
      },
      to: {
        type: 0 /* contract */,
        address: contractCreatedOutput?.contractId || ""
      }
    });
    return operations;
  }, []);
  return contractCreatedOperations;
}
__name(getContractCreatedOperations, "getContractCreatedOperations");
function getOperations({
  transactionType,
  inputs,
  outputs,
  receipts,
  abiMap,
  rawPayload,
  maxInputs,
  baseAssetId
}) {
  if (isTypeCreate(transactionType)) {
    return [...getContractCreatedOperations({ inputs, outputs })];
  }
  if (isTypeScript(transactionType)) {
    return [
      ...getTransferOperations({ inputs, outputs, receipts, baseAssetId }),
      ...getContractCallOperations({
        inputs,
        outputs,
        receipts,
        abiMap,
        rawPayload,
        maxInputs,
        baseAssetId
      }),
      ...getWithdrawFromFuelOperations({ inputs, receipts, baseAssetId })
    ];
  }
  return [...getPayProducerOperations(outputs)];
}
__name(getOperations, "getOperations");

// src/providers/transaction-summary/receipt.ts
import { ReceiptType as ReceiptType6 } from "@fuel-ts/transactions";
var extractMintedAssetsFromReceipts = /* @__PURE__ */ __name((receipts) => {
  const mintedAssets = [];
  receipts.forEach((receipt) => {
    if (receipt.type === ReceiptType6.Mint) {
      mintedAssets.push({
        subId: receipt.subId,
        contractId: receipt.contractId,
        assetId: receipt.assetId,
        amount: receipt.val
      });
    }
  });
  return mintedAssets;
}, "extractMintedAssetsFromReceipts");
var extractBurnedAssetsFromReceipts = /* @__PURE__ */ __name((receipts) => {
  const burnedAssets = [];
  receipts.forEach((receipt) => {
    if (receipt.type === ReceiptType6.Burn) {
      burnedAssets.push({
        subId: receipt.subId,
        contractId: receipt.contractId,
        assetId: receipt.assetId,
        amount: receipt.val
      });
    }
  });
  return burnedAssets;
}, "extractBurnedAssetsFromReceipts");

// src/providers/transaction-summary/status.ts
import { ErrorCode as ErrorCode14, FuelError as FuelError17 } from "@fuel-ts/errors";
import { bn as bn15 } from "@fuel-ts/math";
var getTransactionStatusName = /* @__PURE__ */ __name((gqlStatus) => {
  switch (gqlStatus) {
    case "FailureStatus":
      return "failure" /* failure */;
    case "SuccessStatus":
      return "success" /* success */;
    case "SubmittedStatus":
      return "submitted" /* submitted */;
    case "SqueezedOutStatus":
      return "squeezedout" /* squeezedout */;
    case "PreconfirmationSuccessStatus":
      return "preconfirmationSuccess" /* preconfirmationSuccess */;
    case "PreconfirmationFailureStatus":
      return "preconfirmationFailure" /* preconfirmationFailure */;
    default:
      throw new FuelError17(
        ErrorCode14.INVALID_TRANSACTION_STATUS,
        `Invalid transaction status: ${gqlStatus}.`
      );
  }
}, "getTransactionStatusName");
var extractResolvedOutputs = /* @__PURE__ */ __name((serializedOutputs) => {
  const resolvedOutputs = [];
  serializedOutputs?.forEach(
    ({ utxoId, output }) => resolvedOutputs.push({
      utxoId,
      output: deserializeProcessedTxOutput(output)
    })
  );
  return resolvedOutputs;
}, "extractResolvedOutputs");
var processGraphqlStatus = /* @__PURE__ */ __name((gqlTransactionStatus) => {
  let time;
  let blockId;
  let status;
  let totalFee;
  let totalGas;
  let receipts;
  let resolvedOutputs = [];
  let errorReason;
  let isStatusFailure = false;
  let isStatusSuccess = false;
  let isStatusPending = false;
  let isStatusPreConfirmationSuccess = false;
  let isStatusPreConfirmationFailure = false;
  if (gqlTransactionStatus?.type) {
    status = getTransactionStatusName(gqlTransactionStatus.type);
    switch (gqlTransactionStatus.type) {
      case "SuccessStatus":
        time = gqlTransactionStatus.time;
        blockId = gqlTransactionStatus.block?.id;
        isStatusSuccess = true;
        receipts = gqlTransactionStatus.receipts?.map(deserializeReceipt);
        totalFee = bn15(gqlTransactionStatus.totalFee);
        totalGas = bn15(gqlTransactionStatus.totalGas);
        break;
      case "FailureStatus":
        time = gqlTransactionStatus.time;
        blockId = gqlTransactionStatus.block?.id;
        isStatusFailure = true;
        totalFee = bn15(gqlTransactionStatus.totalFee);
        receipts = gqlTransactionStatus.receipts?.map(deserializeReceipt);
        totalGas = bn15(gqlTransactionStatus.totalGas);
        break;
      case "SubmittedStatus":
        time = gqlTransactionStatus.time;
        isStatusPending = true;
        break;
      case "PreconfirmationSuccessStatus":
        isStatusPreConfirmationSuccess = true;
        totalFee = bn15(gqlTransactionStatus.totalFee);
        totalGas = bn15(gqlTransactionStatus.totalGas);
        receipts = gqlTransactionStatus.preconfirmationReceipts?.map(deserializeReceipt);
        resolvedOutputs = extractResolvedOutputs(gqlTransactionStatus.resolvedOutputs);
        break;
      case "PreconfirmationFailureStatus":
        isStatusPreConfirmationFailure = true;
        totalFee = bn15(gqlTransactionStatus.totalFee);
        totalGas = bn15(gqlTransactionStatus.totalGas);
        receipts = gqlTransactionStatus.preconfirmationReceipts?.map(deserializeReceipt);
        resolvedOutputs = extractResolvedOutputs(gqlTransactionStatus.resolvedOutputs);
        errorReason = gqlTransactionStatus.reason;
        break;
      default:
    }
  }
  const processedGraphqlStatus = {
    time,
    blockId,
    status,
    totalFee,
    totalGas,
    receipts,
    isStatusFailure,
    isStatusSuccess,
    isStatusPending,
    isStatusPreConfirmationSuccess,
    isStatusPreConfirmationFailure,
    resolvedOutputs,
    errorReason
  };
  return processedGraphqlStatus;
}, "processGraphqlStatus");
var getTotalFeeFromStatus = /* @__PURE__ */ __name((status) => status && "totalFee" in status ? bn15(status.totalFee) : void 0, "getTotalFeeFromStatus");

// src/providers/transaction-summary/assemble-transaction-summary.ts
function assembleTransactionSummary(params) {
  const {
    id,
    receipts,
    gasPerByte,
    gasPriceFactor,
    transaction,
    transactionBytes,
    gqlTransactionStatus,
    abiMap = {},
    maxInputs,
    gasCosts,
    maxGasPerTx,
    gasPrice,
    baseAssetId
  } = params;
  const gasUsed = getGasUsedFromReceipts(receipts);
  const rawPayload = hexlify18(transactionBytes);
  const operations = getOperations({
    transactionType: transaction.type,
    inputs: transaction.inputs || [],
    outputs: transaction.outputs || [],
    receipts,
    rawPayload,
    abiMap,
    maxInputs,
    baseAssetId
  });
  const typeName = getTransactionTypeName(transaction.type);
  const tip = bn16(transaction.policies?.find((policy) => policy.type === PolicyType3.Tip)?.data);
  const { isStatusFailure, isStatusPending, isStatusSuccess, blockId, status, time, totalFee } = processGraphqlStatus(gqlTransactionStatus);
  const fee = totalFee ?? calculateTXFeeForSummary({
    gasPrice,
    rawPayload,
    tip,
    consensusParameters: {
      gasCosts,
      maxGasPerTx,
      feeParams: {
        gasPerByte,
        gasPriceFactor
      }
    }
  });
  const mintedAssets = extractMintedAssetsFromReceipts(receipts);
  const burnedAssets = extractBurnedAssetsFromReceipts(receipts);
  let date;
  if (time) {
    date = DateTime.fromTai64(time);
  }
  const transactionSummary = {
    id,
    tip,
    fee,
    gasUsed,
    operations,
    type: typeName,
    blockId,
    time,
    status,
    receipts,
    mintedAssets,
    burnedAssets,
    isTypeMint: isTypeMint(transaction.type),
    isTypeCreate: isTypeCreate(transaction.type),
    isTypeScript: isTypeScript(transaction.type),
    isTypeUpgrade: isTypeUpgrade(transaction.type),
    isTypeUpload: isTypeUpload(transaction.type),
    isTypeBlob: isTypeBlob(transaction.type),
    isStatusFailure,
    isStatusSuccess,
    isStatusPending,
    date,
    transaction
  };
  return transactionSummary;
}
__name(assembleTransactionSummary, "assembleTransactionSummary");
function assemblePreConfirmationTransactionSummary(params) {
  const { id, gqlTransactionStatus, transactionRequest, baseAssetId, maxInputs, abiMap } = params;
  let type;
  let operations;
  let gasUsed;
  let tip;
  let transaction;
  let mintedAssets;
  let burnedAssets;
  const {
    isStatusFailure,
    isStatusSuccess,
    isStatusPending,
    status,
    receipts,
    resolvedOutputs,
    errorReason,
    totalFee,
    isStatusPreConfirmationFailure,
    isStatusPreConfirmationSuccess
  } = processGraphqlStatus(gqlTransactionStatus);
  if (receipts) {
    gasUsed = getGasUsedFromReceipts(receipts);
    mintedAssets = extractMintedAssetsFromReceipts(receipts);
    burnedAssets = extractBurnedAssetsFromReceipts(receipts);
  }
  if (transactionRequest) {
    transaction = transactionRequest.toTransaction();
    type = getTransactionTypeName(transaction.type);
    tip = bn16(transaction.policies?.find((policy) => policy.type === PolicyType3.Tip)?.data);
    if (receipts) {
      const rawPayload = hexlify18(new TransactionCoder4().encode(transaction));
      operations = getOperations({
        transactionType: transaction.type,
        inputs: transaction.inputs || [],
        outputs: transaction.outputs || [],
        receipts,
        rawPayload,
        abiMap,
        maxInputs,
        baseAssetId
      });
    }
  }
  const transactionSummary = {
    id,
    fee: totalFee,
    type,
    status,
    receipts,
    gasUsed,
    tip,
    isStatusPreConfirmationFailure,
    isStatusPreConfirmationSuccess,
    isStatusFailure,
    isStatusSuccess,
    isStatusPending,
    ...transaction && {
      isTypeMint: isTypeMint(transaction.type),
      isTypeCreate: isTypeCreate(transaction.type),
      isTypeScript: isTypeScript(transaction.type),
      isTypeUpgrade: isTypeUpgrade(transaction.type),
      isTypeUpload: isTypeUpload(transaction.type),
      isTypeBlob: isTypeBlob(transaction.type)
    },
    mintedAssets,
    burnedAssets,
    resolvedOutputs,
    errorReason,
    transaction,
    operations
  };
  return transactionSummary;
}
__name(assemblePreConfirmationTransactionSummary, "assemblePreConfirmationTransactionSummary");

// src/providers/transaction-response/getAllDecodedLogs.ts
import { Interface as Interface2, BigNumberCoder } from "@fuel-ts/abi-coder";
import { ZeroBytes32 as ZeroBytes3210 } from "@fuel-ts/address/configs";
import { ReceiptType as ReceiptType7 } from "@fuel-ts/transactions";
function getAllDecodedLogs(opts) {
  const { receipts, mainAbi, externalAbis = {} } = opts;
  let mainContract = "";
  if (mainAbi.programType === "contract") {
    const firstCallReceipt = receipts.find(
      (r) => r.type === ReceiptType7.Call && r.id === ZeroBytes3210
    );
    if (firstCallReceipt) {
      mainContract = firstCallReceipt.to;
    }
  }
  return receipts.reduce(
    ({ logs, groupedLogs }, receipt) => {
      if (receipt.type === ReceiptType7.LogData || receipt.type === ReceiptType7.Log) {
        const isLogFromMainAbi = receipt.id === ZeroBytes3210 || mainContract === receipt.id;
        const isDecodable = isLogFromMainAbi || externalAbis[receipt.id];
        if (isDecodable) {
          const interfaceToUse = isLogFromMainAbi ? new Interface2(mainAbi) : new Interface2(externalAbis[receipt.id]);
          const data = receipt.type === ReceiptType7.Log ? new BigNumberCoder("u64").encode(receipt.ra) : receipt.data;
          const [decodedLog] = interfaceToUse.decodeLog(data, receipt.rb.toString());
          logs.push(decodedLog);
          groupedLogs[receipt.id] = [...groupedLogs[receipt.id] || [], decodedLog];
        }
      }
      return { logs, groupedLogs };
    },
    { logs: [], groupedLogs: {} }
  );
}
__name(getAllDecodedLogs, "getAllDecodedLogs");

// src/providers/transaction-response/transaction-response.ts
var TransactionResponse = class _TransactionResponse {
  /**
   * Constructor for `TransactionResponse`.
   *
   * @param tx - The transaction ID or TransactionRequest.
   * @param provider - The provider.
   */
  constructor(tx, provider, chainId, abis, submitTxSubscription) {
    this.submitTxSubscription = submitTxSubscription;
    if (typeof tx === "string") {
      this.id = tx;
    } else {
      this.id = tx.getTransactionId(chainId);
      this.request = tx;
    }
    this.provider = provider;
    this.abis = abis;
    this.waitForResult = this.waitForResult.bind(this);
    this.waitForPreConfirmation = this.waitForPreConfirmation.bind(this);
  }
  static {
    __name(this, "TransactionResponse");
  }
  /** Transaction ID */
  id;
  /** Current provider */
  provider;
  /** Gas used on the transaction */
  gasUsed = bn17(0);
  /** The graphql Transaction with receipts object. */
  gqlTransaction;
  request;
  status;
  abis;
  preConfirmationStatus;
  waitingForStreamData = false;
  statusResolvers = /* @__PURE__ */ new Map();
  /**
   * Async constructor for `TransactionResponse`. This method can be used to create
   * an instance of `TransactionResponse` and wait for the transaction to be fetched
   * from the chain, ensuring that the `gqlTransaction` property is set.
   *
   * @param id - The transaction ID.
   * @param provider - The provider.
   */
  static async create(id, provider, abis) {
    const chainId = await provider.getChainId();
    const response = new _TransactionResponse(id, provider, chainId, abis);
    await response.fetch();
    return response;
  }
  applyMalleableSubscriptionFields(transaction) {
    const status = this.status;
    if (!status) {
      return;
    }
    const tx = transaction;
    if (status.type === "SuccessStatus" || status.type === "FailureStatus") {
      tx.inputs = tx.inputs.map((input, idx) => {
        if ("txPointer" in input) {
          const correspondingInput = status.transaction.inputs?.[idx];
          return {
            ...input,
            txPointer: TxPointerCoder.decodeFromGqlScalar(correspondingInput.txPointer)
          };
        }
        return input;
      });
      tx.outputs = status.transaction.outputs.map(deserializeProcessedTxOutput);
      if (status.transaction.receiptsRoot) {
        tx.receiptsRoot = status.transaction.receiptsRoot;
      }
    }
  }
  async getTransaction() {
    if (this.request) {
      const tx2 = this.request.toTransaction();
      this.applyMalleableSubscriptionFields(tx2);
      return {
        tx: tx2,
        bytes: this.request.toTransactionBytes()
      };
    }
    const gqlTransaction = this.gqlTransaction ?? await this.fetch();
    const { rawPayload } = gqlTransaction;
    const bytes = arrayify12(rawPayload);
    const [tx] = new TransactionCoder5().decode(bytes, 0);
    return {
      tx,
      bytes
    };
  }
  /**
   *
   * NOTE: This method is only called within `getTransactionSummary`, which is invoked after `getTransaction`.
   * Since `getTransaction` only resolves once the transaction has been processed,
   * the status at this point is guaranteed to be either `SuccessStatus` or `FailureStatus`.
   */
  getReceipts() {
    const status = this.getTransactionStatus();
    switch (status?.type) {
      case "SuccessStatus":
      case "FailureStatus":
        return status.receipts.map(deserializeReceipt);
      default:
        return [];
    }
  }
  /**
   * Fetch the transaction with receipts from the provider.
   *
   * @returns Transaction with receipts query result.
   */
  async fetch() {
    const response = await this.provider.operations.getTransactionWithReceipts({
      transactionId: this.id
    });
    if (!response.transaction) {
      const subscription = await this.provider.operations.statusChange({
        transactionId: this.id
      });
      for await (const { statusChange } of subscription) {
        if (statusChange) {
          this.status = statusChange;
          break;
        }
      }
      return this.fetch();
    }
    this.gqlTransaction = response.transaction;
    return response.transaction;
  }
  /**
   * Retrieves the TransactionSummary. If the `gqlTransaction` is not set, it will
   * fetch it from the provider
   *
   * @param contractsAbiMap - The contracts ABI map.
   * @returns
   */
  async getTransactionSummary(contractsAbiMap) {
    const { tx: transaction, bytes: transactionBytes } = await this.getTransaction();
    const { gasPerByte, gasPriceFactor, gasCosts, maxGasPerTx } = await this.provider.getGasConfig();
    const transactionStatus = this.getTransactionStatus();
    const totalFee = getTotalFeeFromStatus(transactionStatus);
    const gasPrice = totalFee ? bn17(0) : await this.provider.getLatestGasPrice();
    const maxInputs = (await this.provider.getChain()).consensusParameters.txParameters.maxInputs;
    const baseAssetId = await this.provider.getBaseAssetId();
    const transactionSummary = assembleTransactionSummary({
      id: this.id,
      receipts: this.getReceipts(),
      transaction,
      transactionBytes,
      gqlTransactionStatus: transactionStatus,
      gasPerByte,
      gasPriceFactor,
      abiMap: contractsAbiMap,
      maxInputs,
      gasCosts,
      maxGasPerTx,
      gasPrice,
      baseAssetId
    });
    return transactionSummary;
  }
  async getPreConfirmationTransactionSummary(contractsAbiMap) {
    const baseAssetId = await this.provider.getBaseAssetId();
    const maxInputs = (await this.provider.getChain()).consensusParameters.txParameters.maxInputs;
    const transactionSummary = assemblePreConfirmationTransactionSummary({
      id: this.id,
      gqlTransactionStatus: this.preConfirmationStatus || this.status,
      baseAssetId,
      maxInputs,
      abiMap: contractsAbiMap,
      transactionRequest: this.request
    });
    return transactionSummary;
  }
  resolveStatus(type) {
    const resolvers = this.statusResolvers.get(type) || [];
    resolvers.forEach((resolve) => resolve());
    this.statusResolvers.delete(type);
  }
  async waitForStatus(type) {
    return new Promise((resolve, reject) => {
      const resolvers = this.statusResolvers.get(type) || [];
      resolvers.push(() => {
        resolve();
      });
      this.statusResolvers.set(type, resolvers);
      this.waitForStatusChange().catch(reject);
    });
  }
  /**
   * Waits for the status change of the transaction.
   * If the transaction is already in a final state, it will return immediately.
   * If the transaction is not in a final state, it will wait for the status change.
   * If we are already subscribed to the status change, it will return immediately.
   */
  async waitForStatusChange() {
    const type = this.status?.type;
    if (type && (type === "FailureStatus" || type === "SuccessStatus")) {
      this.resolveStatus("preConfirmation");
      this.resolveStatus("confirmation");
      return;
    }
    if (this.waitingForStreamData) {
      return;
    }
    this.waitingForStreamData = true;
    const subscription = this.submitTxSubscription ?? await this.provider.operations.statusChange({
      transactionId: this.id,
      includePreConfirmation: true
    });
    for await (const sub of subscription) {
      const statusChange = "statusChange" in sub ? sub.statusChange : sub.submitAndAwaitStatus;
      this.status = statusChange;
      if (statusChange.type === "SqueezedOutStatus") {
        throw new FuelError18(
          ErrorCode15.TRANSACTION_SQUEEZED_OUT,
          `Transaction Squeezed Out with reason: ${statusChange.reason}`
        );
      }
      if (statusChange.type === "PreconfirmationSuccessStatus" || statusChange.type === "PreconfirmationFailureStatus") {
        this.preConfirmationStatus = statusChange;
        this.resolveStatus("preConfirmation");
      }
      if (statusChange.type === "SuccessStatus" || statusChange.type === "FailureStatus") {
        this.resolveStatus("confirmation");
        this.resolveStatus("preConfirmation");
        this.waitingForStreamData = false;
        break;
      }
    }
  }
  async waitForConfirmationStatuses() {
    try {
      await this.waitForStatus("confirmation");
    } catch (error) {
      this.unsetResourceCache();
      throw error;
    }
  }
  async waitForPreConfirmationStatuses() {
    try {
      await this.waitForStatus("preConfirmation");
    } catch (error) {
      this.unsetResourceCache();
      throw error;
    }
  }
  /**
   * Assembles the result of a transaction by retrieving the transaction summary,
   * decoding logs (if available), and handling transaction failure.
   *
   * This method can be used to obtain the result of a transaction that has just
   * been submitted or one that has already been processed.
   *
   * @template TTransactionType - The type of the transaction.
   * @param contractsAbiMap - The map of contract ABIs.
   * @returns - The assembled transaction result.
   * @throws If the transaction status is a failure.
   */
  async assembleResult(contractsAbiMap) {
    const transactionSummary = await this.getTransactionSummary(contractsAbiMap);
    const transactionResult = {
      ...transactionSummary
    };
    let { logs, groupedLogs } = { logs: [], groupedLogs: {} };
    if (this.abis) {
      ({ logs, groupedLogs } = getAllDecodedLogs({
        receipts: transactionSummary.receipts,
        mainAbi: this.abis.main,
        externalAbis: this.abis.otherContractsAbis
      }));
      transactionResult.logs = logs;
      transactionResult.groupedLogs = groupedLogs;
    }
    const { receipts } = transactionResult;
    const status = this.getTransactionStatus();
    if (status?.type === "FailureStatus") {
      const { reason } = status;
      throw extractTxError({
        receipts,
        statusReason: reason,
        logs,
        groupedLogs
      });
    }
    return transactionResult;
  }
  async assemblePreConfirmationResult(contractsAbiMap) {
    const transactionSummary = await this.getPreConfirmationTransactionSummary(contractsAbiMap);
    const transactionResult = {
      ...transactionSummary,
      logs: [],
      groupedLogs: {}
    };
    let { logs, groupedLogs } = { logs: [], groupedLogs: {} };
    if (this.abis && transactionSummary.receipts) {
      ({ logs, groupedLogs } = getAllDecodedLogs({
        receipts: transactionSummary.receipts,
        mainAbi: this.abis.main,
        externalAbis: this.abis.otherContractsAbis
      }));
      transactionResult.logs = logs;
      transactionResult.groupedLogs = groupedLogs;
    }
    return transactionResult;
  }
  /**
   * Waits for transaction to complete and returns the result.
   *
   * @returns The completed transaction result
   */
  async waitForResult(contractsAbiMap) {
    await this.waitForConfirmationStatuses();
    this.unsetResourceCache();
    return this.assembleResult(contractsAbiMap);
  }
  /**
   * Waits for the transaction's pre-confirmation and returns the result.
   *
   * @param contractsAbiMap - The contracts ABI map.
   * @returns The pre-confirmed transaction result
   */
  async waitForPreConfirmation(contractsAbiMap) {
    await this.waitForPreConfirmationStatuses();
    this.unsetResourceCache();
    return this.assemblePreConfirmationResult(contractsAbiMap);
  }
  /**
   * Waits for transaction to complete and returns the result.
   *
   * @param contractsAbiMap - The contracts ABI map.
   */
  async wait(contractsAbiMap) {
    return this.waitForResult(contractsAbiMap);
  }
  unsetResourceCache() {
    this.provider.cache?.unset(this.id);
  }
  getTransactionStatus() {
    return this.status ?? this.gqlTransaction?.status;
  }
};

// src/providers/transaction-response/getDecodedLogs.ts
import { Interface as Interface3, BigNumberCoder as BigNumberCoder2 } from "@fuel-ts/abi-coder";
import { ZeroBytes32 as ZeroBytes3211 } from "@fuel-ts/address/configs";
import { ReceiptType as ReceiptType8 } from "@fuel-ts/transactions";

// src/providers/utils/auto-retry-fetch.ts
import { sleep } from "@fuel-ts/utils";
function getWaitDelay(options, retryAttemptNum) {
  const duration = options.baseDelay ?? 150;
  switch (options.backoff) {
    case "linear":
      return duration * retryAttemptNum;
    case "fixed":
      return duration;
    case "exponential":
    default:
      return 2 ** (retryAttemptNum - 1) * duration;
  }
}
__name(getWaitDelay, "getWaitDelay");
function autoRetryFetch(fetchFn, options, retryAttemptNum = 0) {
  if (options === void 0) {
    return fetchFn;
  }
  return async (...args) => {
    try {
      return await fetchFn(...args);
    } catch (_error) {
      const error = _error;
      if (error.cause?.code !== "ECONNREFUSED") {
        throw error;
      }
      const retryNum = retryAttemptNum + 1;
      if (retryNum > options.maxRetries) {
        throw error;
      }
      const delay = getWaitDelay(options, retryNum);
      await sleep(delay);
      return autoRetryFetch(fetchFn, options, retryNum)(...args);
    }
  };
}
__name(autoRetryFetch, "autoRetryFetch");

// src/providers/utils/parse-graphql-response.ts
var parseGraphqlResponse = /* @__PURE__ */ __name(async (options) => {
  const { response, isSubscription } = options;
  let extensions;
  const responseClone = response.clone();
  if (isSubscription) {
    const reader = responseClone.body?.getReader();
    const { event } = await FuelGraphqlSubscriber.readEvent(reader);
    extensions = event?.extensions;
  } else {
    extensions = (await responseClone.json()).extensions;
  }
  return {
    extensions
  };
}, "parseGraphqlResponse");

// src/providers/utils/validate-pagination-args.ts
import { FuelError as FuelError19, ErrorCode as ErrorCode16 } from "@fuel-ts/errors";
var validatePaginationArgs = /* @__PURE__ */ __name((params) => {
  const { paginationLimit, inputArgs = {} } = params;
  const { first, last, after, before } = inputArgs;
  if (after && before) {
    throw new FuelError19(
      ErrorCode16.INVALID_INPUT_PARAMETERS,
      'Pagination arguments "after" and "before" cannot be used together'
    );
  }
  if ((first || 0) > paginationLimit || (last || 0) > paginationLimit) {
    throw new FuelError19(
      ErrorCode16.INVALID_INPUT_PARAMETERS,
      `Pagination limit for this query cannot exceed ${paginationLimit} items`
    );
  }
  if (first && before) {
    throw new FuelError19(
      ErrorCode16.INVALID_INPUT_PARAMETERS,
      'The use of pagination argument "first" with "before" is not supported'
    );
  }
  if (last && after) {
    throw new FuelError19(
      ErrorCode16.INVALID_INPUT_PARAMETERS,
      'The use of pagination argument "last" with "after" is not supported'
    );
  }
  if (!first && !last) {
    inputArgs.first = paginationLimit;
  }
  return inputArgs;
}, "validatePaginationArgs");

// src/providers/provider.ts
var MAX_RETRIES = 10;
var RESOURCES_PAGE_SIZE_LIMIT = 512;
var TRANSACTIONS_PAGE_SIZE_LIMIT = 60;
var BALANCES_PAGE_SIZE_LIMIT = 100;
var NON_PAGINATED_BALANCES_SIZE = 1e4;
var BLOCKS_PAGE_SIZE_LIMIT = 5;
var DEFAULT_RESOURCE_CACHE_TTL = 2e4;
var GAS_USED_MODIFIER = 1.2;
var WRITE_OPERATIONS = [
  "submit",
  "submitAndAwaitStatus",
  "produceBlocks"
];
var Provider = class _Provider {
  static {
    __name(this, "Provider");
  }
  operations;
  cache;
  /**
   * @hidden
   * @param url - If provided, clears cache only for given url
   */
  static clearChainAndNodeCaches(url) {
    if (url) {
      delete _Provider.inflightFetchChainAndNodeInfoRequests[url];
      delete _Provider.chainInfoCache[url];
      delete _Provider.nodeInfoCache[url];
      delete _Provider.currentBlockHeightCache[url];
      return;
    }
    _Provider.inflightFetchChainAndNodeInfoRequests = {};
    _Provider.nodeInfoCache = {};
    _Provider.chainInfoCache = {};
    _Provider.currentBlockHeightCache = {};
  }
  /** @hidden */
  url;
  /** @hidden */
  urlWithoutAuth;
  /**
   * Governs whether to include the required block height in the request body
   * for block-sensitive operations like when submitting a transaction.
   *
   * This ensures that the operation is executed at the correct block height,
   * regardless of which node in the network the request is routed to.
   *
   * `true` by default.
   */
  static ENABLE_RPC_CONSISTENCY = true;
  /** @hidden */
  static inflightFetchChainAndNodeInfoRequests = {};
  /** @hidden */
  static chainInfoCache = {};
  /** @hidden */
  static nodeInfoCache = {};
  /** @hidden */
  static currentBlockHeightCache = {};
  /** @hidden */
  static incompatibleNodeVersionMessage = "";
  /** @hidden */
  consensusParametersTimestamp;
  options = {
    timeout: void 0,
    resourceCacheTTL: void 0,
    fetch: void 0,
    retryOptions: void 0,
    headers: void 0,
    cache: void 0
  };
  static extractOperationName(body) {
    return body?.toString().match(/"operationName":"(.+)"/)?.[1];
  }
  static isWriteOperation(body) {
    return WRITE_OPERATIONS.includes(this.extractOperationName(body));
  }
  static normalizeUrl(url) {
    return url.replace(/-sub$/, "");
  }
  static hasWriteOperationHappened(url) {
    return isDefined3(_Provider.currentBlockHeightCache[this.normalizeUrl(url)]);
  }
  /**
   * @hidden
   */
  static getFetchFn(options) {
    const { retryOptions, timeout, headers } = options;
    return autoRetryFetch(async (...args) => {
      const url = args[0];
      const request = args[1];
      const signal = timeout ? AbortSignal.timeout(timeout) : void 0;
      let fullRequest = {
        ...request,
        signal,
        headers: { ...request?.headers, ...headers }
      };
      if (options.requestMiddleware) {
        fullRequest = await options.requestMiddleware(fullRequest);
      }
      if (_Provider.ENABLE_RPC_CONSISTENCY && _Provider.hasWriteOperationHappened(url)) {
        _Provider.applyBlockHeight(fullRequest, url);
      }
      return _Provider.fetchAndProcessBlockHeight(url, fullRequest, options);
    }, retryOptions);
  }
  static applyBlockHeight(request, url) {
    const normalizedUrl = this.normalizeUrl(url);
    const currentBlockHeight = _Provider.currentBlockHeightCache[normalizedUrl] ?? 0;
    request.body = request.body?.toString().replace(/}$/, `,"extensions":{"required_fuel_block_height":${currentBlockHeight}}}`);
  }
  static async fetchAndProcessBlockHeight(url, request, options) {
    const fetchFn = /* @__PURE__ */ __name(() => options.fetch ? options.fetch(url, request, options) : fetch(url, request), "fetchFn");
    const isWriteOperation = _Provider.isWriteOperation(request.body);
    if (isWriteOperation && !_Provider.hasWriteOperationHappened(url)) {
      _Provider.currentBlockHeightCache[_Provider.normalizeUrl(url)] = 0;
    }
    let response = await fetchFn();
    if (!_Provider.ENABLE_RPC_CONSISTENCY) {
      return response;
    }
    const retryOptions = {
      maxRetries: 5,
      baseDelay: 500
    };
    for (let retriesLeft = retryOptions.maxRetries; retriesLeft > 0; --retriesLeft) {
      const { extensions } = await parseGraphqlResponse({
        response,
        isSubscription: url.endsWith("-sub")
      });
      _Provider.setCurrentBlockHeight(url, extensions?.current_fuel_block_height);
      if (!extensions?.fuel_block_height_precondition_failed) {
        break;
      }
      const retryAttempt = retryOptions.maxRetries - retriesLeft + 1;
      const sleepTime = getWaitDelay(retryOptions, retryAttempt);
      await sleep2(sleepTime);
      response = await fetchFn();
    }
    return response;
  }
  static setCurrentBlockHeight(url, height) {
    const writeOperationHappened = _Provider.hasWriteOperationHappened(url);
    if (!isDefined3(height) || !writeOperationHappened) {
      return;
    }
    const normalizedUrl = _Provider.normalizeUrl(url);
    if (height > _Provider.currentBlockHeightCache[normalizedUrl]) {
      _Provider.currentBlockHeightCache[normalizedUrl] = height;
    }
  }
  /**
   * Constructor to initialize a Provider.
   *
   * @param url - GraphQL endpoint of the Fuel node
   * @param options - Additional options for the provider
   * @hidden
   */
  constructor(url, options = {}) {
    const { url: rawUrl, urlWithoutAuth, headers: authHeaders } = _Provider.extractBasicAuth(url);
    this.url = rawUrl;
    this.urlWithoutAuth = urlWithoutAuth;
    this.url = url;
    const { FUELS } = versions;
    const headers = { ...authHeaders, ...options.headers, Source: `ts-sdk-${FUELS}` };
    this.options = {
      ...this.options,
      ...options,
      headers
    };
    this.operations = this.createOperations();
    const { resourceCacheTTL, cache: cache2 } = this.options;
    if (cache2) {
      const { consensusParametersTimestamp, chain, nodeInfo } = deserializeProviderCache(cache2);
      this.consensusParametersTimestamp = consensusParametersTimestamp;
      _Provider.chainInfoCache[this.urlWithoutAuth] = chain;
      _Provider.nodeInfoCache[this.urlWithoutAuth] = nodeInfo;
    }
    if (isDefined3(resourceCacheTTL)) {
      if (resourceCacheTTL !== -1) {
        this.cache = new ResourceCache(resourceCacheTTL);
      } else {
        this.cache = void 0;
      }
    } else {
      this.cache = new ResourceCache(DEFAULT_RESOURCE_CACHE_TTL);
    }
  }
  static extractBasicAuth(url) {
    let parsedUrl;
    try {
      parsedUrl = new URL(url);
    } catch (error) {
      throw new FuelError20(FuelError20.CODES.INVALID_URL, "Invalid URL provided.", { url }, error);
    }
    const username = parsedUrl.username;
    const password = parsedUrl.password;
    const urlWithoutAuth = `${parsedUrl.origin}${parsedUrl.pathname}`;
    if (!(username && password)) {
      return { url, urlWithoutAuth: url, headers: void 0 };
    }
    return {
      url,
      urlWithoutAuth,
      headers: { Authorization: `Basic ${btoa(`${username}:${password}`)}` }
    };
  }
  /**
   * Initialize Provider async stuff
   */
  async init() {
    await this.fetchChainAndNodeInfo();
    return this;
  }
  /**
   * Returns the `chainInfo` for the current network.
   *
   * @returns the chain information configuration.
   */
  async getChain() {
    await this.init();
    return _Provider.chainInfoCache[this.urlWithoutAuth];
  }
  /**
   * Returns the `nodeInfo` for the current network.
   *
   * @returns the node information configuration.
   */
  async getNode() {
    await this.init();
    return _Provider.nodeInfoCache[this.urlWithoutAuth];
  }
  /**
   * Returns some helpful parameters related to gas fees.
   */
  async getGasConfig() {
    await this.init();
    const {
      txParameters: { maxGasPerTx },
      predicateParameters: { maxGasPerPredicate },
      feeParameters: { gasPriceFactor, gasPerByte },
      gasCosts
    } = (await this.getChain()).consensusParameters;
    return {
      maxGasPerTx,
      maxGasPerPredicate,
      gasPriceFactor,
      gasPerByte,
      gasCosts
    };
  }
  /**
   * Updates the URL for the provider and fetches the consensus parameters for the new URL, if needed.
   *
   * @param url - The URL to connect to.
   * @param options - Additional options for the provider.
   */
  async connect(url, options) {
    const { url: rawUrl, urlWithoutAuth, headers } = _Provider.extractBasicAuth(url);
    this.url = rawUrl;
    this.urlWithoutAuth = urlWithoutAuth;
    this.options = options ?? this.options;
    this.options = { ...this.options, headers: { ...this.options.headers, ...headers } };
    this.operations = this.createOperations();
    await this.init();
  }
  /**
   * Return the chain and node information.
   * @param ignoreCache - If true, ignores the cache and re-fetch configs.
   * @returns A promise that resolves to the Chain and NodeInfo.
   */
  async fetchChainAndNodeInfo(ignoreCache = false) {
    const nodeInfo = _Provider.nodeInfoCache[this.urlWithoutAuth];
    const chain = _Provider.chainInfoCache[this.urlWithoutAuth];
    const hasCache = nodeInfo && chain;
    if (hasCache && !ignoreCache) {
      return { nodeInfo, chain };
    }
    const inflightRequest = _Provider.inflightFetchChainAndNodeInfoRequests[this.urlWithoutAuth];
    if (inflightRequest) {
      return inflightRequest.then((data) => {
        this.consensusParametersTimestamp = data.consensusParametersTimestamp;
        return {
          nodeInfo: _Provider.nodeInfoCache[this.urlWithoutAuth],
          chain: _Provider.chainInfoCache[this.urlWithoutAuth]
        };
      });
    }
    const getChainAndNodeInfoFromNetwork = this.operations.getChainAndNodeInfo().then((data) => ({
      chain: deserializeChain(data.chain),
      nodeInfo: deserializeNodeInfo(data.nodeInfo),
      consensusParametersTimestamp: Date.now()
    })).then((data) => {
      _Provider.setIncompatibleNodeVersionMessage(data.nodeInfo);
      _Provider.chainInfoCache[this.urlWithoutAuth] = data.chain;
      _Provider.nodeInfoCache[this.urlWithoutAuth] = data.nodeInfo;
      this.consensusParametersTimestamp = data.consensusParametersTimestamp;
      return data;
    }).catch((err) => {
      const error = new FuelError20(
        FuelError20.CODES.CONNECTION_REFUSED,
        "Unable to fetch chain and node info from the network",
        { url: this.urlWithoutAuth },
        err
      );
      error.cause = { code: "ECONNREFUSED" };
      throw error;
    }).finally(() => {
      delete _Provider.inflightFetchChainAndNodeInfoRequests[this.urlWithoutAuth];
    });
    _Provider.inflightFetchChainAndNodeInfoRequests[this.urlWithoutAuth] = getChainAndNodeInfoFromNetwork;
    return _Provider.inflightFetchChainAndNodeInfoRequests[this.urlWithoutAuth].then((data) => {
      this.consensusParametersTimestamp = data.consensusParametersTimestamp;
      return {
        nodeInfo: _Provider.nodeInfoCache[this.urlWithoutAuth],
        chain: _Provider.chainInfoCache[this.urlWithoutAuth]
      };
    });
  }
  /**
   * @hidden
   */
  static setIncompatibleNodeVersionMessage(nodeInfo) {
    const { isMajorSupported, isMinorSupported, supportedVersion } = checkFuelCoreVersionCompatibility(nodeInfo.nodeVersion);
    if (!isMajorSupported || !isMinorSupported) {
      _Provider.incompatibleNodeVersionMessage = [
        `The Fuel Node that you are trying to connect to is using fuel-core version ${nodeInfo.nodeVersion}.`,
        `The TS SDK currently supports fuel-core version ${supportedVersion}.`,
        `Things may not work as expected.`
      ].join("\n");
      FuelGraphqlSubscriber.incompatibleNodeVersionMessage = _Provider.incompatibleNodeVersionMessage;
    }
  }
  /**
   * Create GraphQL client and set operations.
   *
   * @returns The operation SDK object
   * @hidden
   */
  createOperations() {
    const fetchFn = _Provider.getFetchFn(this.options);
    const gqlClient = new GraphQLClient(this.urlWithoutAuth, {
      fetch: /* @__PURE__ */ __name((input, requestInit) => fetchFn(input.toString(), requestInit || {}, this.options), "fetch"),
      responseMiddleware: /* @__PURE__ */ __name((response) => {
        if ("response" in response) {
          const graphQlResponse = response.response;
          assertGqlResponseHasNoErrors(
            graphQlResponse.errors,
            _Provider.incompatibleNodeVersionMessage
          );
        }
      }, "responseMiddleware")
    });
    const executeQuery = /* @__PURE__ */ __name((query, vars) => {
      const opDefinition = query.definitions.find((x) => x.kind === "OperationDefinition");
      const isSubscription = opDefinition?.operation === "subscription";
      if (isSubscription) {
        return FuelGraphqlSubscriber.create({
          url: this.urlWithoutAuth,
          query,
          fetchFn: /* @__PURE__ */ __name((url, requestInit) => fetchFn(url, requestInit, this.options), "fetchFn"),
          variables: vars,
          operationName: opDefinition.name.value,
          onEvent: /* @__PURE__ */ __name((event) => {
            _Provider.setCurrentBlockHeight(
              this.urlWithoutAuth,
              event.extensions?.current_fuel_block_height
            );
          }, "onEvent")
        });
      }
      return gqlClient.request(query, vars);
    }, "executeQuery");
    const customOperations = /* @__PURE__ */ __name((requester) => ({
      getBlobs(variables) {
        const queryParams = variables.blobIds.map((_, i) => `$blobId${i}: BlobId!`).join(", ");
        const blobParams = variables.blobIds.map((_, i) => `blob${i}: blob(id: $blobId${i}) { id }`).join("\n");
        const updatedVariables = variables.blobIds.reduce(
          (acc, blobId, i) => {
            acc[`blobId${i}`] = blobId;
            return acc;
          },
          {}
        );
        const document = gql2`
          query getBlobs(${queryParams}) {
            ${blobParams}
          }
        `;
        return requester(document, updatedVariables);
      }
    }), "customOperations");
    return { ...getSdk(executeQuery), ...customOperations(executeQuery) };
  }
  /**
   * Returns the version of the connected node.
   *
   * @returns A promise that resolves to the version string.
   */
  async getVersion() {
    const {
      nodeInfo: { nodeVersion }
    } = await this.operations.getVersion();
    return nodeVersion;
  }
  /**
   * Returns the latest block number.
   *
   * @returns A promise that resolves to the latest block number.
   */
  async getBlockNumber() {
    const {
      chain: {
        latestBlock: { height }
      }
    } = await this.operations.getLatestBlockHeight();
    return bn18(height);
  }
  /**
   * Returns the node information for the current provider network.
   *
   * @returns a promise that resolves to the node information.
   */
  async fetchNode() {
    const { nodeInfo } = await this.operations.getNodeInfo();
    const processedNodeInfo = deserializeNodeInfo(nodeInfo);
    _Provider.nodeInfoCache[this.urlWithoutAuth] = processedNodeInfo;
    return processedNodeInfo;
  }
  /**
   * Returns the chain information for the current provider network.
   *
   * @returns a promise that resolves to the chain information.
   */
  async fetchChain() {
    const { chain } = await this.operations.getChain();
    const processedChain = deserializeChain(chain);
    _Provider.chainInfoCache[this.urlWithoutAuth] = processedChain;
    return processedChain;
  }
  /**
   * Returns the chain ID for the current provider network.
   *
   * @returns A promise that resolves to the chain ID number.
   */
  async getChainId() {
    const {
      consensusParameters: { chainId }
    } = await this.getChain();
    return chainId.toNumber();
  }
  /**
   * Returns the base asset ID for the current provider network.
   *
   * @returns the base asset ID.
   */
  async getBaseAssetId() {
    const all = await this.getChain();
    const {
      consensusParameters: { baseAssetId }
    } = all;
    return baseAssetId;
  }
  /**
   * Retrieves the details of an asset given its ID.
   *
   * @param assetId - The unique identifier of the asset.
   * @returns A promise that resolves to an object containing the asset details.
   */
  async getAssetDetails(assetId) {
    const { assetMetadata } = await this.getNodeFeatures();
    if (!assetMetadata) {
      throw new FuelError20(
        ErrorCode17.UNSUPPORTED_FEATURE,
        "The current node does not supports fetching asset details"
      );
    }
    const { assetDetails } = await this.operations.getAssetDetails({ assetId });
    const { contractId, subId, totalSupply } = assetDetails;
    return {
      subId,
      contractId,
      totalSupply: bn18(totalSupply)
    };
  }
  /**
   * @hidden
   */
  #cacheInputs(inputs, transactionId) {
    if (!this.cache) {
      return;
    }
    this.cache.set(transactionId, inputs);
  }
  /**
   * @hidden
   */
  async validateTransaction(tx) {
    const {
      consensusParameters: {
        txParameters: { maxInputs, maxOutputs }
      }
    } = await this.getChain();
    if (bn18(tx.inputs.length).gt(maxInputs)) {
      throw new FuelError20(
        ErrorCode17.MAX_INPUTS_EXCEEDED,
        `The transaction exceeds the maximum allowed number of inputs. Tx inputs: ${tx.inputs.length}, max inputs: ${maxInputs}`
      );
    }
    if (bn18(tx.outputs.length).gt(maxOutputs)) {
      throw new FuelError20(
        ErrorCode17.MAX_OUTPUTS_EXCEEDED,
        `The transaction exceeds the maximum allowed number of outputs. Tx outputs: ${tx.outputs.length}, max outputs: ${maxOutputs}`
      );
    }
  }
  /**
   * Submits a transaction to the chain to be executed.
   *
   * If the transaction is missing any dependencies,
   * the transaction will be mutated and those dependencies will be added.
   *
   * @param transactionRequestLike - The transaction request object.
   * @param sendTransactionParams - The provider send transaction parameters (optional).
   * @returns A promise that resolves to the transaction response object.
   */
  async sendTransaction(transactionRequestLike, {
    enableAssetBurn,
    estimateTxDependencies = true,
    includePreConfirmation: _includePreConfirmation = true
  } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    validateTransactionForAssetBurn(
      await this.getBaseAssetId(),
      transactionRequest,
      enableAssetBurn
    );
    if (estimateTxDependencies) {
      await this.estimateTxDependencies(transactionRequest);
    }
    await this.validateTransaction(transactionRequest);
    const encodedTransaction = hexlify19(transactionRequest.toTransactionBytes());
    let abis;
    if (isTransactionTypeScript(transactionRequest)) {
      abis = transactionRequest.abis;
    }
    const subscription = await this.operations.submitAndAwaitStatus({
      encodedTransaction,
      includePreConfirmation: true
    });
    this.#cacheInputs(
      transactionRequest.inputs,
      transactionRequest.getTransactionId(await this.getChainId())
    );
    const chainId = await this.getChainId();
    return new TransactionResponse(transactionRequest, this, chainId, abis, subscription);
  }
  /**
   * Executes a transaction without actually submitting it to the chain.
   *
   * If the transaction is missing any dependencies,
   * the transaction will be mutated and those dependencies will be added.
   *
   * @param transactionRequestLike - The transaction request object.
   * @param sendTransactionParams - The provider call parameters (optional).
   * @returns A promise that resolves to the call result object.
   */
  async dryRun(transactionRequestLike, { utxoValidation, estimateTxDependencies = true } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      return this.estimateTxDependencies(transactionRequest);
    }
    const encodedTransaction = hexlify19(transactionRequest.toTransactionBytes());
    const { dryRun: dryRunStatuses } = await this.operations.dryRun({
      encodedTransactions: encodedTransaction,
      utxoValidation: utxoValidation || false
    });
    const [{ receipts: rawReceipts, status: dryRunStatus }] = dryRunStatuses;
    const receipts = rawReceipts.map(deserializeReceipt);
    return { receipts, dryRunStatus };
  }
  /**
   * Estimates the gas usage for predicates in a transaction request.
   *
   * @template T - The type of the transaction request object.
   *
   * @param transactionRequest - The transaction request to estimate predicates for.
   * @returns A promise that resolves to the updated transaction request with estimated gas usage for predicates.
   */
  async estimatePredicates(transactionRequest) {
    const shouldEstimatePredicates = transactionRequest.inputs.some(
      (input) => isPredicate(input) && bn18(input.predicateGasUsed).isZero()
    );
    if (!shouldEstimatePredicates) {
      return transactionRequest;
    }
    const encodedTransaction = hexlify19(transactionRequest.toTransactionBytes());
    const response = await this.operations.estimatePredicates({
      encodedTransaction
    });
    const { estimatePredicates } = response;
    transactionRequest = this.parseEstimatePredicatesResponse(
      transactionRequest,
      estimatePredicates
    );
    return transactionRequest;
  }
  /**
   * Estimates the gas price and predicates for a given transaction request and block horizon.
   *
   * @param transactionRequest - The transaction request to estimate predicates and gas price for.
   * @param blockHorizon - The block horizon to use for gas price estimation.
   * @returns A promise that resolves to an object containing the updated transaction
   * request and the estimated gas price.
   */
  async estimatePredicatesAndGasPrice(transactionRequest, blockHorizon) {
    const shouldEstimatePredicates = transactionRequest.inputs.some(
      (input) => isPredicate(input) && bn18(input.predicateGasUsed).isZero()
    );
    if (!shouldEstimatePredicates) {
      const gasPrice2 = await this.estimateGasPrice(blockHorizon);
      return { transactionRequest, gasPrice: gasPrice2 };
    }
    const {
      estimateGasPrice: { gasPrice },
      estimatePredicates
    } = await this.operations.estimatePredicatesAndGasPrice({
      blockHorizon: String(blockHorizon),
      encodedTransaction: hexlify19(transactionRequest.toTransactionBytes())
    });
    transactionRequest = this.parseEstimatePredicatesResponse(
      transactionRequest,
      estimatePredicates
    );
    return { transactionRequest, gasPrice: bn18(gasPrice) };
  }
  /**
   * Will dryRun a transaction and check for missing dependencies.
   *
   * If there are missing variable outputs,
   * `addVariableOutputs` is called on the transaction.
   *
   * @param transactionRequest - The transaction request object.
   * @param gasPrice - The gas price to use for the transaction, if not provided it will be fetched.
   * @returns A promise that resolves to the estimate transaction dependencies.
   */
  async estimateTxDependencies(transactionRequest, { gasPrice: gasPriceParam } = {}) {
    if (isTransactionTypeCreate(transactionRequest)) {
      return {
        rawReceipts: [],
        receipts: [],
        outputVariables: 0,
        missingContractIds: []
      };
    }
    let rawReceipts = [];
    let receipts = [];
    const missingContractIds = [];
    let outputVariables = 0;
    let dryRunStatus;
    await this.validateTransaction(transactionRequest);
    const gasPrice = gasPriceParam ?? await this.estimateGasPrice(10);
    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
      const {
        dryRun: [{ receipts: serializedReceipts, status }]
      } = await this.operations.dryRun({
        encodedTransactions: [hexlify19(transactionRequest.toTransactionBytes())],
        utxoValidation: false,
        gasPrice: gasPrice.toString()
      });
      rawReceipts = serializedReceipts;
      receipts = serializedReceipts.map(deserializeReceipt);
      dryRunStatus = status;
      const { missingOutputVariables, missingOutputContractIds } = getReceiptsWithMissingData(receipts);
      const hasMissingOutputs = missingOutputVariables.length !== 0 || missingOutputContractIds.length !== 0;
      if (hasMissingOutputs && isTransactionTypeScript(transactionRequest)) {
        outputVariables += missingOutputVariables.length;
        transactionRequest.addVariableOutputs(missingOutputVariables.length);
        missingOutputContractIds.forEach(({ contractId }) => {
          transactionRequest.addContractInputAndOutput(new Address3(contractId));
          missingContractIds.push(contractId);
        });
        const { maxFee } = await this.estimateTxGasAndFee({
          transactionRequest,
          gasPrice
        });
        transactionRequest.maxFee = maxFee;
      } else {
        break;
      }
    }
    return {
      rawReceipts,
      receipts,
      outputVariables,
      missingContractIds,
      dryRunStatus
    };
  }
  /**
   * Dry runs multiple transactions and checks for missing dependencies in batches.
   *
   * Transactions are dry run in batches. After each dry run, transactions requiring
   * further modifications are identified. The method iteratively updates these transactions
   * and performs subsequent dry runs until all dependencies for each transaction are satisfied.
   *
   * @param transactionRequests - Array of transaction request objects.
   * @returns A promise that resolves to an array of results for each transaction.
   */
  async estimateMultipleTxDependencies(transactionRequests) {
    const results = transactionRequests.map(() => ({
      rawReceipts: [],
      receipts: [],
      outputVariables: 0,
      missingContractIds: [],
      dryRunStatus: void 0
    }));
    const allRequests = clone8(transactionRequests);
    const serializedTransactionsMap = /* @__PURE__ */ new Map();
    allRequests.forEach((req, index) => {
      if (isTransactionTypeScript(req)) {
        serializedTransactionsMap.set(index, hexlify19(req.toTransactionBytes()));
      }
    });
    let transactionsToProcess = Array.from(serializedTransactionsMap.keys());
    let attempt = 0;
    while (transactionsToProcess.length > 0 && attempt < MAX_RETRIES) {
      const encodedTransactions = transactionsToProcess.map(
        (index) => serializedTransactionsMap.get(index)
      );
      const dryRunResults = await this.operations.dryRun({
        encodedTransactions,
        utxoValidation: false
      });
      const nextRoundTransactions = [];
      for (let i = 0; i < dryRunResults.dryRun.length; i++) {
        const requestIdx = transactionsToProcess[i];
        const { receipts: rawReceipts, status } = dryRunResults.dryRun[i];
        const result = results[requestIdx];
        result.receipts = rawReceipts.map(deserializeReceipt);
        result.dryRunStatus = status;
        const { missingOutputVariables, missingOutputContractIds } = getReceiptsWithMissingData(
          result.receipts
        );
        const hasMissingOutputs = missingOutputVariables.length > 0 || missingOutputContractIds.length > 0;
        const request = allRequests[requestIdx];
        if (hasMissingOutputs && isTransactionTypeScript(request)) {
          result.outputVariables += missingOutputVariables.length;
          request.addVariableOutputs(missingOutputVariables.length);
          missingOutputContractIds.forEach(({ contractId }) => {
            request.addContractInputAndOutput(new Address3(contractId));
            result.missingContractIds.push(contractId);
          });
          const { maxFee } = await this.estimateTxGasAndFee({
            transactionRequest: request
          });
          request.maxFee = maxFee;
          serializedTransactionsMap.set(requestIdx, hexlify19(request.toTransactionBytes()));
          nextRoundTransactions.push(requestIdx);
        }
      }
      transactionsToProcess = nextRoundTransactions;
      attempt += 1;
    }
    return results;
  }
  /**
   * Dry runs multiple transactions.
   *
   * @param transactionRequests - Array of transaction request objects.
   * @param sendTransactionParams - The provider call parameters (optional).
   *
   * @returns A promise that resolves to an array of results for each transaction call.
   */
  async dryRunMultipleTransactions(transactionRequests, { utxoValidation, estimateTxDependencies = true } = {}) {
    if (estimateTxDependencies) {
      return this.estimateMultipleTxDependencies(transactionRequests);
    }
    const encodedTransactions = transactionRequests.map((tx) => hexlify19(tx.toTransactionBytes()));
    const { dryRun: dryRunStatuses } = await this.operations.dryRun({
      encodedTransactions,
      utxoValidation: utxoValidation || false
    });
    const results = dryRunStatuses.map(({ receipts: rawReceipts, status }) => {
      const receipts = rawReceipts.map(deserializeReceipt);
      return { receipts, dryRunStatus: status };
    });
    return results;
  }
  async autoRefetchConfigs() {
    const now = Date.now();
    const diff = now - (this.consensusParametersTimestamp ?? 0);
    if (diff < 6e4) {
      return;
    }
    if (!_Provider.chainInfoCache?.[this.urlWithoutAuth]) {
      await this.fetchChainAndNodeInfo(true);
      return;
    }
    const chainInfo = _Provider.chainInfoCache[this.urlWithoutAuth];
    const {
      latestBlock: {
        header: { consensusParametersVersion: previous }
      }
    } = chainInfo;
    const {
      chain: {
        latestBlock: {
          header: { consensusParametersVersion: current }
        }
      }
    } = await this.operations.getConsensusParametersVersion();
    if (previous !== current) {
      await this.fetchChainAndNodeInfo(true);
    }
  }
  /**
   * Estimates the transaction gas and fee based on the provided transaction request.
   * @param params - The parameters for estimating the transaction gas and fee.
   * @returns An object containing the estimated minimum gas, minimum fee, maximum gas, and maximum fee.
   */
  async estimateTxGasAndFee(params) {
    const { transactionRequest, gasPrice: gasPriceParam } = params;
    let gasPrice = gasPriceParam;
    await this.autoRefetchConfigs();
    const chainInfo = await this.getChain();
    const { gasPriceFactor, maxGasPerTx } = await this.getGasConfig();
    const minGas = transactionRequest.calculateMinGas(chainInfo);
    if (!isDefined3(gasPrice)) {
      gasPrice = await this.estimateGasPrice(10);
    }
    const minFee = calculateGasFee({
      gasPrice: bn18(gasPrice),
      gas: minGas,
      priceFactor: gasPriceFactor,
      tip: transactionRequest.tip
    }).add(1);
    let gasLimit = bn18(0);
    if (isTransactionTypeScript(transactionRequest)) {
      gasLimit = transactionRequest.gasLimit;
      if (transactionRequest.gasLimit.eq(0)) {
        transactionRequest.gasLimit = minGas;
        transactionRequest.gasLimit = maxGasPerTx.sub(
          transactionRequest.calculateMaxGas(chainInfo, minGas)
        );
        gasLimit = transactionRequest.gasLimit;
      }
    }
    const maxGas = transactionRequest.calculateMaxGas(chainInfo, minGas);
    const maxFee = calculateGasFee({
      gasPrice: bn18(gasPrice),
      gas: maxGas,
      priceFactor: gasPriceFactor,
      tip: transactionRequest.tip
    }).add(1);
    return {
      minGas,
      minFee,
      maxGas,
      maxFee,
      gasPrice,
      gasLimit
    };
  }
  /**
   * Executes a signed transaction without applying the states changes
   * on the chain.
   *
   * If the transaction is missing any dependencies,
   * the transaction will be mutated and those dependencies will be added
   *
   * @param transactionRequestLike - The transaction request object.
   * @param estimateTxParams - The estimate transaction params (optional).
   * @returns A promise that resolves to the call result object.
   */
  async simulate(transactionRequestLike, { estimateTxDependencies = true } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      return this.estimateTxDependencies(transactionRequest);
    }
    const encodedTransactions = [hexlify19(transactionRequest.toTransactionBytes())];
    const { dryRun: dryRunStatuses } = await this.operations.dryRun({
      encodedTransactions,
      utxoValidation: true
    });
    const callResult = dryRunStatuses.map((dryRunStatus) => {
      const { id, receipts, status } = dryRunStatus;
      const processedReceipts = receipts.map(deserializeReceipt);
      return { id, receipts: processedReceipts, status };
    });
    return { receipts: callResult[0].receipts };
  }
  /**
   * @hidden
   *
   * Returns a transaction cost to enable user
   * to set gasLimit and also reserve balance amounts
   * on the transaction.
   *
   * @param transactionRequestLike - The transaction request object.
   * @param transactionCostParams - The transaction cost parameters (optional).
   *
   * @returns A promise that resolves to the transaction cost object.
   *
   * @deprecated Use provider.assembleTx instead
   * Check the migration guide https://docs.fuel.network/guide/assembling-transactions/migration-guide.html for more information.
   */
  async getTransactionCost(transactionRequestLike, { signatureCallback, gasPrice: gasPriceParam } = {}) {
    const txRequestClone = clone8(transactionRequestify(transactionRequestLike));
    const updateMaxFee = txRequestClone.maxFee.eq(0);
    const isScriptTransaction = isTransactionTypeScript(txRequestClone);
    if (isScriptTransaction) {
      txRequestClone.gasLimit = bn18(0);
    }
    const signedRequest = clone8(txRequestClone);
    let addedSignatures = 0;
    if (signatureCallback && isTransactionTypeScript(signedRequest)) {
      const lengthBefore = signedRequest.witnesses.length;
      await signatureCallback(signedRequest);
      addedSignatures = signedRequest.witnesses.length - lengthBefore;
    }
    let gasPrice;
    if (gasPriceParam) {
      gasPrice = gasPriceParam;
      await this.estimatePredicates(signedRequest);
    } else {
      ({ gasPrice } = await this.estimatePredicatesAndGasPrice(signedRequest, 10));
    }
    txRequestClone.updatePredicateGasUsed(signedRequest.inputs);
    let { maxFee, maxGas, minFee, minGas, gasLimit } = await this.estimateTxGasAndFee({
      // Fetches and returns a gas price
      transactionRequest: signedRequest,
      gasPrice
    });
    let rawReceipts = [];
    let receipts = [];
    let dryRunStatus;
    let missingContractIds = [];
    let outputVariables = 0;
    let gasUsed = bn18(0);
    txRequestClone.maxFee = maxFee;
    if (isScriptTransaction) {
      txRequestClone.gasLimit = gasLimit;
      if (signatureCallback) {
        await signatureCallback(txRequestClone);
      }
      ({ rawReceipts, receipts, missingContractIds, outputVariables, dryRunStatus } = await this.estimateTxDependencies(txRequestClone, { gasPrice }));
      if (dryRunStatus && "reason" in dryRunStatus) {
        throw this.extractDryRunError(txRequestClone, receipts, dryRunStatus.reason);
      }
      const { maxGasPerTx } = await this.getGasConfig();
      const pristineGasUsed = getGasUsedFromReceipts(receipts);
      gasUsed = bn18(pristineGasUsed.muln(GAS_USED_MODIFIER)).max(maxGasPerTx.sub(minGas));
      txRequestClone.gasLimit = gasUsed;
      ({ maxFee, maxGas, minFee, minGas } = await this.estimateTxGasAndFee({
        transactionRequest: txRequestClone,
        gasPrice
      }));
    }
    const transactionSummary = {
      gasPrice: gasPrice.toString(),
      receipts: rawReceipts
    };
    return {
      rawReceipts,
      receipts,
      gasUsed,
      gasPrice,
      minGas,
      maxGas,
      minFee,
      maxFee,
      outputVariables,
      missingContractIds,
      addedSignatures,
      estimatedPredicates: txRequestClone.inputs,
      dryRunStatus,
      updateMaxFee,
      transactionSummary
    };
  }
  /**
   * Assembles a transaction by completely estimating and funding it.
   *
   * @param params - Parameters used to assemble the transaction.
   *
   * @returns The assembled transaction request, estimated gas price, and receipts
   */
  async assembleTx(params) {
    const {
      request,
      reserveGas,
      resourcesIdsToIgnore,
      feePayerAccount,
      blockHorizon = 10,
      estimatePredicates = true,
      accountCoinQuantities = []
    } = params;
    const allAddresses = /* @__PURE__ */ new Set();
    const baseAssetId = await this.getBaseAssetId();
    let feePayerIndex = -1;
    let baseAssetChange;
    const requiredBalances = accountCoinQuantities.map((quantity, index) => {
      const { amount, assetId, account = feePayerAccount, changeOutputAccount } = quantity;
      const changeAccountAddress = changeOutputAccount ? changeOutputAccount.address.toB256() : account.address.toB256();
      allAddresses.add(account.address.toB256());
      const changePolicy = {
        change: changeAccountAddress
      };
      if (assetId === baseAssetId) {
        baseAssetChange = changePolicy.change;
      }
      if (account.address.equals(feePayerAccount.address)) {
        feePayerIndex = index;
      }
      const requiredBalance = {
        account: resolveAccountForAssembleTxParams(account),
        amount: bn18(amount).toString(10),
        assetId,
        changePolicy
      };
      return requiredBalance;
    });
    if (feePayerIndex === -1) {
      allAddresses.add(feePayerAccount.address.toB256());
      const newLength = requiredBalances.push({
        account: resolveAccountForAssembleTxParams(feePayerAccount),
        amount: bn18(0).toString(10),
        // Since the correct fee amount cannot be determined yet, we can use 0
        assetId: baseAssetId,
        changePolicy: {
          change: baseAssetChange || feePayerAccount.address.toB256()
        }
      });
      feePayerIndex = newLength - 1;
    }
    const excludeInput = await this.adjustResourcesToIgnoreForAddresses(
      Array.from(allAddresses),
      resourcesIdsToIgnore
    );
    const {
      assembleTx: { status, transaction: gqlTransaction, gasPrice }
    } = await this.operations.assembleTx({
      tx: hexlify19(request.toTransactionBytes()),
      blockHorizon: String(blockHorizon),
      feeAddressIndex: String(feePayerIndex),
      requiredBalances,
      estimatePredicates,
      excludeInput,
      reserveGas: reserveGas ? reserveGas.toString(10) : void 0
    });
    if (status.type === "DryRunFailureStatus") {
      const parsedReceipts = status.receipts.map(deserializeReceipt);
      throw this.extractDryRunError(request, parsedReceipts, status.reason);
    }
    request.witnesses = gqlTransaction.witnesses || request.witnesses;
    request.inputs = gqlTransaction.inputs?.map(deserializeInput) || request.inputs;
    request.outputs = gqlTransaction.outputs?.map(deserializeOutput) || request.outputs;
    if (gqlTransaction.policies?.maxFee) {
      request.maxFee = bn18(gqlTransaction.policies.maxFee);
    }
    if (gqlTransaction.scriptGasLimit) {
      request.gasLimit = bn18(gqlTransaction.scriptGasLimit);
    }
    const rawReceipts = status.receipts;
    const chainId = await this.getChainId();
    request.updateState(chainId, "funded", {
      gasPrice: gasPrice.toString(),
      receipts: rawReceipts
    });
    return {
      assembledRequest: request,
      gasPrice: bn18(gasPrice),
      receipts: status.receipts.map(deserializeReceipt),
      rawReceipts
    };
  }
  /**
   * Returns coins for the given owner.
   *
   * @param owner - The address to get coins for.
   * @param assetId - The asset ID of coins to get (optional).
   * @param paginationArgs - Pagination arguments (optional).
   *
   * @returns A promise that resolves to the coins.
   */
  async getCoins(owner, assetId, paginationArgs) {
    const ownerAddress = new Address3(owner);
    const {
      coins: { edges, pageInfo }
    } = await this.operations.getCoins({
      ...validatePaginationArgs({
        paginationLimit: RESOURCES_PAGE_SIZE_LIMIT,
        inputArgs: paginationArgs
      }),
      filter: { owner: ownerAddress.toB256(), assetId: assetId && hexlify19(assetId) }
    });
    const coins = edges.map(({ node }) => ({
      id: node.utxoId,
      assetId: node.assetId,
      amount: bn18(node.amount),
      owner: ownerAddress,
      blockCreated: bn18(node.blockCreated),
      txCreatedIdx: bn18(node.txCreatedIdx)
    }));
    return {
      coins,
      pageInfo
    };
  }
  /**
   * Returns resources for the given owner satisfying the spend query.
   *
   * @param owner - The address to get resources for.
   * @param quantities - The coin quantities to get.
   * @param resourcesIdsToIgnore - IDs of excluded resources from the selection (optional).
   * @returns A promise that resolves to the resources.
   */
  async getResourcesToSpend(owner, quantities, resourcesIdsToIgnore) {
    const ownerAddress = new Address3(owner);
    const excludedIds = await this.adjustResourcesToIgnoreForAddresses(
      [ownerAddress.b256Address],
      resourcesIdsToIgnore
    );
    const coinsQuery = {
      owner: ownerAddress.toB256(),
      queryPerAsset: quantities.map(coinQuantityfy).map(({ assetId, amount, max: maxPerAsset }) => ({
        assetId: hexlify19(assetId),
        amount: (amount.eqn(0) ? bn18(1) : amount).toString(10),
        max: maxPerAsset ? maxPerAsset.toString(10) : void 0
      })),
      excludedIds
    };
    const result = await this.operations.getCoinsToSpend(coinsQuery);
    const coins = result.coinsToSpend.flat().map((coin) => {
      switch (coin.type) {
        case "MessageCoin":
          return {
            amount: bn18(coin.amount),
            assetId: coin.assetId,
            daHeight: bn18(coin.daHeight),
            sender: new Address3(coin.sender),
            recipient: new Address3(coin.recipient),
            nonce: coin.nonce
          };
        case "Coin":
          return {
            id: coin.utxoId,
            amount: bn18(coin.amount),
            assetId: coin.assetId,
            owner: ownerAddress,
            blockCreated: bn18(coin.blockCreated),
            txCreatedIdx: bn18(coin.txCreatedIdx)
          };
        default:
          return null;
      }
    }).filter((v) => !!v);
    return coins;
  }
  /**
   * Returns an array of blobIds that exist on chain, for a given array of blobIds.
   *
   * @param blobIds - blobIds to check.
   * @returns - A promise that resolves to an array of blobIds that exist on chain.
   */
  async getBlobs(blobIds) {
    const res = await this.operations.getBlobs({ blobIds });
    const blobs = [];
    Object.keys(res).forEach((key) => {
      const val = res[key];
      blobs.push(val?.id ?? null);
    });
    return blobs.filter((v) => v);
  }
  /**
   * Returns block matching the given ID or height.
   *
   * @param idOrHeight - ID or height of the block.
   * @returns A promise that resolves to the block or null.
   */
  async getBlock(idOrHeight) {
    let block;
    if (idOrHeight === "latest") {
      const {
        chain: { latestBlock }
      } = await this.operations.getLatestBlock();
      block = latestBlock;
    } else {
      const isblockId = typeof idOrHeight === "string" && isB256(idOrHeight);
      const variables = isblockId ? { blockId: idOrHeight } : { height: bn18(idOrHeight).toString(10) };
      const response = await this.operations.getBlock(variables);
      block = response.block;
    }
    if (!block) {
      return null;
    }
    const { header, height, id, transactions } = block;
    return {
      id,
      height: bn18(height),
      time: header.time,
      header: {
        applicationHash: header.applicationHash,
        daHeight: bn18(header.daHeight),
        eventInboxRoot: header.eventInboxRoot,
        messageOutboxRoot: header.messageOutboxRoot,
        prevRoot: header.prevRoot,
        stateTransitionBytecodeVersion: header.stateTransitionBytecodeVersion,
        transactionsCount: header.transactionsCount,
        transactionsRoot: header.transactionsRoot
      },
      transactionIds: transactions.map((tx) => tx.id)
    };
  }
  /**
   * Returns all the blocks matching the given parameters.
   *
   * @param params - The parameters to query blocks.
   * @returns A promise that resolves to the blocks.
   */
  async getBlocks(params) {
    const {
      blocks: { edges, pageInfo }
    } = await this.operations.getBlocks({
      ...validatePaginationArgs({
        paginationLimit: BLOCKS_PAGE_SIZE_LIMIT,
        inputArgs: params
      })
    });
    const blocks = edges.map(({ node: block }) => ({
      id: block.id,
      height: bn18(block.height),
      time: block.header.time,
      header: {
        applicationHash: block.header.applicationHash,
        daHeight: bn18(block.header.daHeight),
        eventInboxRoot: block.header.eventInboxRoot,
        messageOutboxRoot: block.header.messageOutboxRoot,
        prevRoot: block.header.prevRoot,
        stateTransitionBytecodeVersion: block.header.stateTransitionBytecodeVersion,
        transactionsCount: block.header.transactionsCount,
        transactionsRoot: block.header.transactionsRoot
      },
      transactionIds: block.transactions.map((tx) => tx.id)
    }));
    return { blocks, pageInfo };
  }
  /**
   * Returns block matching the given ID or type, including transaction data.
   *
   * @param idOrHeight - ID or height of the block.
   * @returns A promise that resolves to the block.
   */
  async getBlockWithTransactions(idOrHeight) {
    let variables;
    if (typeof idOrHeight === "number") {
      variables = { blockHeight: bn18(idOrHeight).toString(10) };
    } else if (idOrHeight === "latest") {
      variables = { blockHeight: (await this.getBlockNumber()).toString() };
    } else if (typeof idOrHeight === "string" && isB256(idOrHeight)) {
      variables = { blockId: idOrHeight };
    } else {
      variables = { blockHeight: bn18(idOrHeight).toString() };
    }
    const { block } = await this.operations.getBlockWithTransactions(variables);
    if (!block) {
      return null;
    }
    return {
      id: block.id,
      height: bn18(block.height, 10),
      time: block.header.time,
      header: {
        applicationHash: block.header.applicationHash,
        daHeight: bn18(block.header.daHeight),
        eventInboxRoot: block.header.eventInboxRoot,
        messageOutboxRoot: block.header.messageOutboxRoot,
        prevRoot: block.header.prevRoot,
        stateTransitionBytecodeVersion: block.header.stateTransitionBytecodeVersion,
        transactionsCount: block.header.transactionsCount,
        transactionsRoot: block.header.transactionsRoot
      },
      transactionIds: block.transactions.map((tx) => tx.id),
      transactions: block.transactions.map(
        (tx) => new TransactionCoder6().decode(arrayify13(tx.rawPayload), 0)?.[0]
      )
    };
  }
  /**
   * Get transaction with the given ID.
   *
   * @param transactionId - ID of the transaction.
   * @returns A promise that resolves to the transaction.
   */
  async getTransaction(transactionId) {
    const { transaction } = await this.operations.getTransaction({ transactionId });
    if (!transaction) {
      return null;
    }
    try {
      return new TransactionCoder6().decode(
        arrayify13(transaction.rawPayload),
        0
      )?.[0];
    } catch (error) {
      if (error instanceof FuelError20 && error.code === ErrorCode17.UNSUPPORTED_TRANSACTION_TYPE) {
        console.warn("Unsupported transaction type encountered");
        return null;
      }
      throw error;
    }
  }
  /**
   * Retrieves transactions based on the provided pagination arguments.
   * @param paginationArgs - The pagination arguments for retrieving transactions.
   * @returns A promise that resolves to an object containing the retrieved transactions and pagination information.
   */
  async getTransactions(paginationArgs) {
    const {
      transactions: { edges, pageInfo }
    } = await this.operations.getTransactions({
      ...validatePaginationArgs({
        inputArgs: paginationArgs,
        paginationLimit: TRANSACTIONS_PAGE_SIZE_LIMIT
      })
    });
    const coder = new TransactionCoder6();
    const transactions = edges.map(({ node: { rawPayload } }) => {
      try {
        return coder.decode(arrayify13(rawPayload), 0)[0];
      } catch (error) {
        if (error instanceof FuelError20 && error.code === ErrorCode17.UNSUPPORTED_TRANSACTION_TYPE) {
          console.warn("Unsupported transaction type encountered");
          return null;
        }
        throw error;
      }
    }).filter((tx) => tx !== null);
    return { transactions, pageInfo };
  }
  /**
   * Fetches a compressed block at the specified height.
   *
   * @param height - The height of the block to fetch.
   * @returns The compressed block if available, otherwise `null`.
   */
  async daCompressedBlock(height) {
    const { daCompressedBlock } = await this.operations.daCompressedBlock({
      height
    });
    if (!daCompressedBlock) {
      return null;
    }
    return daCompressedBlock;
  }
  /**
   * Get deployed contract with the given ID.
   *
   * @param contractId - ID of the contract.
   * @returns A promise that resolves to the contract.
   */
  async getContract(contractId) {
    const { contract } = await this.operations.getContract({ contractId });
    if (!contract) {
      return null;
    }
    return contract;
  }
  /**
   * Returns the balance for the given contract for the given asset ID.
   *
   * @param contractId - The contract ID to get the balance for.
   * @param assetId - The asset ID of coins to get.
   * @returns A promise that resolves to the balance.
   */
  async getContractBalance(contractId, assetId) {
    const { contractBalance } = await this.operations.getContractBalance({
      contract: new Address3(contractId).toB256(),
      asset: hexlify19(assetId)
    });
    return bn18(contractBalance.amount, 10);
  }
  /**
   * Returns the balance for the given owner for the given asset ID.
   *
   * @param owner - The address to get coins for.
   * @param assetId - The asset ID of coins to get.
   * @returns A promise that resolves to the balance.
   */
  async getBalance(owner, assetId) {
    const { balance } = await this.operations.getBalanceV2({
      owner: new Address3(owner).toB256(),
      assetId: hexlify19(assetId)
    });
    return bn18(balance.amountU128, 10);
  }
  /**
   * Returns balances for the given owner.
   *
   * @param owner - The address to get coins for.
   * @param paginationArgs - Pagination arguments (optional).
   * @returns A promise that resolves to the balances.
   */
  async getBalances(owner, paginationArgs) {
    let args = { first: NON_PAGINATED_BALANCES_SIZE };
    const { balancesPagination: supportsPagination } = await this.getNodeFeatures();
    if (supportsPagination) {
      args = validatePaginationArgs({
        inputArgs: paginationArgs,
        paginationLimit: BALANCES_PAGE_SIZE_LIMIT
      });
    }
    const {
      balances: { edges, pageInfo }
    } = await this.operations.getBalancesV2({
      ...args,
      filter: { owner: new Address3(owner).toB256() },
      supportsPagination
    });
    const balances = edges.map(({ node }) => ({
      assetId: node.assetId,
      amount: bn18(node.amountU128)
    }));
    return {
      balances,
      ...supportsPagination ? { pageInfo } : {}
    };
  }
  /**
   * Returns message for the given address.
   *
   * @param address - The address to get message from.
   * @param paginationArgs - Pagination arguments (optional).
   * @returns A promise that resolves to the messages.
   */
  async getMessages(address, paginationArgs) {
    const {
      messages: { edges, pageInfo }
    } = await this.operations.getMessages({
      ...validatePaginationArgs({
        inputArgs: paginationArgs,
        paginationLimit: RESOURCES_PAGE_SIZE_LIMIT
      }),
      owner: new Address3(address).toB256()
    });
    const messages = edges.map(({ node }) => ({
      messageId: InputMessageCoder2.getMessageId({
        sender: node.sender,
        recipient: node.recipient,
        nonce: node.nonce,
        amount: bn18(node.amount),
        data: node.data
      }),
      sender: new Address3(node.sender),
      recipient: new Address3(node.recipient),
      nonce: node.nonce,
      amount: bn18(node.amount),
      data: InputMessageCoder2.decodeData(node.data),
      daHeight: bn18(node.daHeight)
    }));
    return {
      messages,
      pageInfo
    };
  }
  /**
   * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
   *
   * @param transactionId - The transaction to get message from.
   * @param messageId - The message id from MessageOut receipt.
   * @param commitBlockId - The commit block id (optional).
   * @param commitBlockHeight - The commit block height (optional).
   * @returns A promise that resolves to the message proof.
   */
  async getMessageProof(transactionId, nonce, commitBlockId, commitBlockHeight) {
    let inputObject = {
      transactionId,
      nonce
    };
    if (commitBlockId && commitBlockHeight) {
      throw new FuelError20(
        ErrorCode17.INVALID_INPUT_PARAMETERS,
        "commitBlockId and commitBlockHeight cannot be used together"
      );
    }
    if (commitBlockId) {
      inputObject = {
        ...inputObject,
        commitBlockId
      };
    }
    if (commitBlockHeight) {
      inputObject = {
        ...inputObject,
        // Convert BN into a number string required on the query
        // This should probably be fixed on the fuel client side
        commitBlockHeight: commitBlockHeight.toNumber().toString()
      };
    }
    const result = await this.operations.getMessageProof(inputObject);
    const {
      messageProof,
      messageBlockHeader,
      commitBlockHeader,
      blockProof,
      sender,
      recipient,
      amount,
      data
    } = result.messageProof;
    return {
      messageProof: {
        proofIndex: bn18(messageProof.proofIndex),
        proofSet: messageProof.proofSet
      },
      blockProof: {
        proofIndex: bn18(blockProof.proofIndex),
        proofSet: blockProof.proofSet
      },
      messageBlockHeader: {
        id: messageBlockHeader.id,
        daHeight: bn18(messageBlockHeader.daHeight),
        transactionsCount: Number(messageBlockHeader.transactionsCount),
        transactionsRoot: messageBlockHeader.transactionsRoot,
        height: bn18(messageBlockHeader.height),
        prevRoot: messageBlockHeader.prevRoot,
        time: messageBlockHeader.time,
        applicationHash: messageBlockHeader.applicationHash,
        messageReceiptCount: Number(messageBlockHeader.messageReceiptCount),
        messageOutboxRoot: messageBlockHeader.messageOutboxRoot,
        consensusParametersVersion: Number(messageBlockHeader.consensusParametersVersion),
        eventInboxRoot: messageBlockHeader.eventInboxRoot,
        stateTransitionBytecodeVersion: Number(messageBlockHeader.stateTransitionBytecodeVersion)
      },
      commitBlockHeader: {
        id: commitBlockHeader.id,
        daHeight: bn18(commitBlockHeader.daHeight),
        transactionsCount: Number(commitBlockHeader.transactionsCount),
        transactionsRoot: commitBlockHeader.transactionsRoot,
        height: bn18(commitBlockHeader.height),
        prevRoot: commitBlockHeader.prevRoot,
        time: commitBlockHeader.time,
        applicationHash: commitBlockHeader.applicationHash,
        messageReceiptCount: Number(commitBlockHeader.messageReceiptCount),
        messageOutboxRoot: commitBlockHeader.messageOutboxRoot,
        consensusParametersVersion: Number(commitBlockHeader.consensusParametersVersion),
        eventInboxRoot: commitBlockHeader.eventInboxRoot,
        stateTransitionBytecodeVersion: Number(commitBlockHeader.stateTransitionBytecodeVersion)
      },
      sender: new Address3(sender),
      recipient: new Address3(recipient),
      nonce,
      amount: bn18(amount),
      data
    };
  }
  /**
   * Get the latest gas price from the node.
   *
   * @returns A promise that resolves to the latest gas price.
   */
  async getLatestGasPrice() {
    const { latestGasPrice } = await this.operations.getLatestGasPrice();
    return bn18(latestGasPrice.gasPrice);
  }
  /**
   * Returns the estimate gas price for the given block horizon.
   *
   * @param blockHorizon - The block horizon to estimate gas price for.
   * @returns A promise that resolves to the estimated gas price.
   */
  async estimateGasPrice(blockHorizon) {
    const { estimateGasPrice } = await this.operations.estimateGasPrice({
      blockHorizon: String(blockHorizon)
    });
    return bn18(estimateGasPrice.gasPrice);
  }
  /**
   * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
   *
   * @param nonce - The nonce of the message to get status from.
   * @returns A promise that resolves to the message status
   */
  async getMessageStatus(nonce) {
    const result = await this.operations.getMessageStatus({ nonce });
    return result.messageStatus;
  }
  /**
   * Lets you produce blocks with custom timestamps and the block number of the last block produced.
   *
   * @param amount - The amount of blocks to produce.
   * @param startTime - The UNIX timestamp (milliseconds) to set for the first produced block (optional).
   * @returns A promise that resolves to the block number of the last produced block.
   */
  async produceBlocks(amount, startTime) {
    const { produceBlocks: latestBlockHeight } = await this.operations.produceBlocks({
      blocksToProduce: bn18(amount).toString(10),
      startTimestamp: startTime ? DateTime2.fromUnixMilliseconds(startTime).toTai64() : void 0
    });
    return bn18(latestBlockHeight);
  }
  /**
   * Check if the given ID is an account.
   *
   * @param id - The ID to check.
   * @returns A promise that resolves to the result of the check.
   */
  async isUserAccount(id) {
    const type = await this.getAddressType(id);
    return type === "Account";
  }
  /**
   * Determines the type of address based on the provided ID.
   *
   * @param id - The ID to be checked.
   * @returns A promise that resolves to a string indicating the type of address.
   */
  async getAddressType(id) {
    const { contract, blob, transaction } = await this.operations.isUserAccount({
      blobId: id,
      contractId: id,
      transactionId: id
    });
    if (contract) {
      return "Contract";
    }
    if (blob) {
      return "Blob";
    }
    if (transaction) {
      return "Transaction";
    }
    try {
      const asset = await this.getAssetDetails(id);
      if (asset) {
        return "Asset";
      }
    } catch (e) {
    }
    return "Account";
  }
  /**
   * Get the transaction response for the given transaction ID.
   *
   * @param transactionId - The transaction ID to get the response for.
   * @returns A promise that resolves to the transaction response.
   */
  async getTransactionResponse(transactionId) {
    const chainId = await this.getChainId();
    return new TransactionResponse(transactionId, this, chainId);
  }
  /**
   * Returns Message for given nonce.
   *
   * @param nonce - The nonce of the message to retrieve.
   * @returns A promise that resolves to the Message object or null.
   */
  async getMessageByNonce(nonce) {
    const { message: rawMessage } = await this.operations.getMessageByNonce({ nonce });
    if (!rawMessage) {
      return null;
    }
    const message = {
      messageId: InputMessageCoder2.getMessageId({
        sender: rawMessage.sender,
        recipient: rawMessage.recipient,
        nonce,
        amount: bn18(rawMessage.amount),
        data: rawMessage.data
      }),
      sender: new Address3(rawMessage.sender),
      recipient: new Address3(rawMessage.recipient),
      nonce,
      amount: bn18(rawMessage.amount),
      data: InputMessageCoder2.decodeData(rawMessage.data),
      daHeight: bn18(rawMessage.daHeight)
    };
    return message;
  }
  /**
   * Get the relayed transaction for the given transaction ID.
   *
   * @param relayedTransactionId - The relayed transaction ID to get the response for.
   * @returns A promise that resolves to the relayed transaction.
   */
  async getRelayedTransactionStatus(relayedTransactionId) {
    const { relayedTransactionStatus } = await this.operations.getRelayedTransactionStatus({
      relayedTransactionId
    });
    if (!relayedTransactionStatus) {
      return null;
    }
    return relayedTransactionStatus;
  }
  /**
   * @hidden
   */
  extractDryRunError(transactionRequest, receipts, reason) {
    let logs = [];
    let groupedLogs = {};
    if (transactionRequest.type === TransactionType11.Script && transactionRequest.abis) {
      ({ logs, groupedLogs } = getAllDecodedLogs({
        receipts,
        mainAbi: transactionRequest.abis.main,
        externalAbis: transactionRequest.abis.otherContractsAbis
      }));
    }
    return extractTxError({
      logs,
      groupedLogs,
      receipts,
      statusReason: reason
    });
  }
  /**
   * @hidden
   */
  async getNodeFeatures() {
    const { indexation } = await this.getNode();
    return {
      assetMetadata: Boolean(indexation?.assetMetadata),
      balancesPagination: Boolean(indexation?.balances),
      coinsToSpend: Boolean(indexation?.coinsToSpend)
    };
  }
  /**
   * @hidden
   */
  parseEstimatePredicatesResponse(transactionRequest, { inputs }) {
    if (inputs) {
      inputs.forEach((input, i) => {
        if (input && "predicateGasUsed" in input && bn18(input.predicateGasUsed).gt(0)) {
          transactionRequest.inputs[i].predicateGasUsed = input.predicateGasUsed;
        }
      });
    }
    return transactionRequest;
  }
  /**
   * @hidden
   *
   * This helper adjusts the resources to be excluded for a given set of addresses.
   * Supporting multiple addresses is important because of the `assembleTx` method,
   * which may be invoked with different addresses. It handles both messages and UTXOs,
   * ensuring the total number of inputs does not exceed the maximum allowed by the chain's
   * consensus parameters. The resources specified in the `resourcesIdsToIgnore` parameter have priority
   * over those retrieved from the cache.
   */
  async adjustResourcesToIgnoreForAddresses(addresses, resourcesIdsToIgnore) {
    const final = {
      messages: resourcesIdsToIgnore?.messages?.map((nonce) => hexlify19(nonce)) || [],
      utxos: resourcesIdsToIgnore?.utxos?.map((id) => hexlify19(id)) || []
    };
    if (this.cache) {
      const cache2 = this.cache;
      const allCached = addresses.map((address) => cache2.getActiveData(address));
      const {
        consensusParameters: {
          txParameters: { maxInputs: maxInputsBn }
        }
      } = await this.getChain();
      const maxInputs = maxInputsBn.toNumber();
      for (let i = 0; i < allCached.length; i++) {
        let total = final.utxos.length + final.messages.length;
        if (total >= maxInputs) {
          break;
        }
        final.utxos = [...final.utxos, ...allCached[i].utxos.slice(0, maxInputs - total)];
        total = final.utxos.length + final.messages.length;
        if (total >= maxInputs) {
          break;
        }
        final.messages = [...final.messages, ...allCached[i].messages.slice(0, maxInputs - total)];
      }
    }
    return final;
  }
};

// src/providers/transaction-summary/get-transaction-summary.ts
import { ErrorCode as ErrorCode18, FuelError as FuelError21 } from "@fuel-ts/errors";
import { bn as bn19 } from "@fuel-ts/math";
import { TransactionCoder as TransactionCoder7 } from "@fuel-ts/transactions";
import { arrayify as arrayify14 } from "@fuel-ts/utils";

// src/providers/transaction-summary/assemble-transaction-summary-from-serialized.ts
import { bn as bn20 } from "@fuel-ts/math";
import { TransactionCoder as TransactionCoder8 } from "@fuel-ts/transactions";
import { arrayify as arrayify15 } from "@fuel-ts/utils";

// src/test-utils/test-asset-id.ts
import { randomBytes as randomBytes4 } from "@fuel-ts/crypto";
import { hexlify as hexlify20 } from "@fuel-ts/utils";
var TestAssetId = class _TestAssetId {
  constructor(value) {
    this.value = value;
  }
  static {
    __name(this, "TestAssetId");
  }
  static A = new _TestAssetId(
    "0x0101010101010101010101010101010101010101010101010101010101010101"
  );
  static B = new _TestAssetId(
    "0x0202020202020202020202020202020202020202020202020202020202020202"
  );
  static random(count = 1) {
    const assetIds = [];
    for (let i = 0; i < count; i++) {
      assetIds.push(new _TestAssetId(hexlify20(randomBytes4(32))));
    }
    return assetIds;
  }
};

// src/test-utils/wallet-config.ts
import { randomBytes as randomBytes8 } from "@fuel-ts/crypto";
import { FuelError as FuelError27 } from "@fuel-ts/errors";
import { bn as bn23 } from "@fuel-ts/math";
import { defaultSnapshotConfigs as defaultSnapshotConfigs2, hexlify as hexlify26 } from "@fuel-ts/utils";

// src/wallet/base-wallet-unlocked.ts
import { hashMessage } from "@fuel-ts/hasher";
import { hexlify as hexlify23 } from "@fuel-ts/utils";

// src/account.ts
import { UTXO_ID_LEN as UTXO_ID_LEN3 } from "@fuel-ts/abi-coder";
import { Address as Address5 } from "@fuel-ts/address";
import { randomBytes as randomBytes5 } from "@fuel-ts/crypto";
import { ErrorCode as ErrorCode19, FuelError as FuelError22 } from "@fuel-ts/errors";
import { bn as bn21 } from "@fuel-ts/math";
import { InputType as InputType8, OutputType as OutputType9 } from "@fuel-ts/transactions";
import { arrayify as arrayify17, hexlify as hexlify21, isDefined as isDefined4 } from "@fuel-ts/utils";
import { clone as clone9 } from "ramda";

// src/types.ts
var AbstractAccount = class {
  static {
    __name(this, "AbstractAccount");
  }
};

// src/utils/formatTransferToContractScriptData.ts
import { ASSET_ID_LEN, BigNumberCoder as BigNumberCoder3, CONTRACT_ID_LEN, WORD_SIZE } from "@fuel-ts/abi-coder";
import { Address as Address4 } from "@fuel-ts/address";
import { arrayify as arrayify16, concat as concat4 } from "@fuel-ts/utils";
import * as asm from "@fuels/vm-asm";
var formatTransferToContractScriptData = /* @__PURE__ */ __name((transferParams) => {
  const numberCoder = new BigNumberCoder3("u64");
  return transferParams.reduce((acc, transferParam) => {
    const { assetId, amount, contractId } = transferParam;
    const encoded = numberCoder.encode(amount);
    const scriptData = concat4([new Address4(contractId).toBytes(), encoded, arrayify16(assetId)]);
    return concat4([acc, scriptData]);
  }, new Uint8Array());
}, "formatTransferToContractScriptData");
var assembleTransferToContractScript = /* @__PURE__ */ __name(async (transferParams) => {
  const scriptData = formatTransferToContractScriptData(transferParams);
  await asm.initWasm();
  let script = new Uint8Array();
  transferParams.forEach((_, i) => {
    const offset = (CONTRACT_ID_LEN + WORD_SIZE + ASSET_ID_LEN) * i;
    script = concat4([
      script,
      // Load ScriptData into register 0x10.
      asm.gtf(16, 0, asm.GTFArgs.ScriptData).to_bytes(),
      // Add the offset to 0x10 so it will point to the current contract ID, store in 0x11.
      asm.addi(17, 16, offset).to_bytes(),
      // Add CONTRACT_ID_LEN to 0x11 to point to the amount in the ScriptData, store in 0x12.
      asm.addi(18, 17, CONTRACT_ID_LEN).to_bytes(),
      // Load word to the amount at 0x12 into register 0x13.
      asm.lw(19, 18, 0).to_bytes(),
      // Add WORD_SIZE to 0x12 to point to the asset ID in the ScriptData, store in 0x14.
      asm.addi(20, 18, WORD_SIZE).to_bytes(),
      // Perform the transfer using contract ID in 0x11, amount in 0x13, and asset ID in 0x14.
      asm.tr(17, 19, 20).to_bytes()
    ]);
  });
  script = concat4([script, asm.ret(1).to_bytes()]);
  return { script, scriptData };
}, "assembleTransferToContractScript");

// src/utils/split-coins-into-batches.ts
var splitCoinsIntoBatches = /* @__PURE__ */ __name((coins, maxBatchLength) => {
  const batchesNum = Math.ceil(coins.length / maxBatchLength);
  const batches = [];
  for (let i = 0; i < batchesNum; i += 1) {
    const batchStart = i * maxBatchLength;
    const batchEnd = (i + 1) * maxBatchLength;
    batches.push(coins.slice(batchStart, batchEnd));
  }
  return batches;
}, "splitCoinsIntoBatches");

// src/account.ts
var MAX_FUNDING_ATTEMPTS = 5;
var Account = class extends AbstractAccount {
  static {
    __name(this, "Account");
  }
  /**
   * The address associated with the account.
   */
  address;
  /**
   * The provider used to interact with the network.
   */
  _provider;
  /**
   * The connector for use with external wallets
   */
  _connector;
  /**
   * Creates a new Account instance.
   *
   * @param address - The address of the account.
   * @param provider - A Provider instance  (optional).
   * @param connector - A FuelConnector instance (optional).
   */
  constructor(address, provider, connector) {
    super();
    this._provider = provider;
    this._connector = connector;
    this.address = new Address5(address);
  }
  /**
   * The provider used to interact with the network.
   *
   * @returns A Provider instance.
   *
   * @throws `FuelError` if the provider is not set.
   */
  get provider() {
    if (!this._provider) {
      throw new FuelError22(ErrorCode19.MISSING_PROVIDER, "Provider not set");
    }
    return this._provider;
  }
  /**
   * Sets the provider for the account.
   *
   * @param provider - A Provider instance.
   */
  set provider(provider) {
    this._provider = provider;
  }
  /**
   * Changes the provider connection for the account.
   *
   * @param provider - A Provider instance.
   * @returns The updated Provider instance.
   */
  connect(provider) {
    this._provider = provider;
    return this.provider;
  }
  /**
   * Retrieves resources satisfying the spend query for the account.
   *
   * @param quantities - Quantities of resources to be obtained.
   * @param resourcesIdsToIgnore - IDs of resources to be excluded from the query (optional).
   * @returns A promise that resolves to an array of Resources.
   */
  async getResourcesToSpend(quantities, resourcesIdsToIgnore) {
    return this.provider.getResourcesToSpend(this.address, quantities, resourcesIdsToIgnore);
  }
  /**
   * Retrieves coins owned by the account.
   *
   * @param assetId - The asset ID of the coins to retrieve (optional).
   * @returns A promise that resolves to an array of Coins.
   */
  async getCoins(assetId, paginationArgs) {
    return this.provider.getCoins(this.address, assetId, paginationArgs);
  }
  /**
   * Retrieves messages owned by the account.
   *
   * @returns A promise that resolves to an array of Messages.
   */
  async getMessages(paginationArgs) {
    return this.provider.getMessages(this.address, paginationArgs);
  }
  /**
   * Retrieves the balance of the account for the given asset.
   *
   * @param assetId - The asset ID to check the balance for (optional).
   * @returns A promise that resolves to the balance amount.
   */
  async getBalance(assetId) {
    const assetIdToFetch = assetId ?? await this.provider.getBaseAssetId();
    const amount = await this.provider.getBalance(this.address, assetIdToFetch);
    return amount;
  }
  /**
   * Retrieves all the balances for the account.
   *
   * @returns A promise that resolves to an array of Coins and their quantities.
   */
  async getBalances() {
    return this.provider.getBalances(this.address);
  }
  /**
   * Funds a transaction request by adding the necessary resources.
   *
   * @typeParam T - The type of the TransactionRequest.
   * @param request - The transaction request to fund.
   * @param params - The estimated transaction parameters.
   * @returns A promise that resolves to the funded transaction request.
   *
   * @deprecated Use provider.assembleTx instead
   * Check the migration guide https://docs.fuel.network/guide/assembling-transactions/migration-guide.html for more information.
   */
  async fund(request, params) {
    const {
      addedSignatures,
      estimatedPredicates,
      requiredQuantities,
      updateMaxFee,
      gasPrice,
      transactionSummary
    } = params;
    const chainId = await this.provider.getChainId();
    const fee = request.maxFee;
    const baseAssetId = await this.provider.getBaseAssetId();
    const requiredInBaseAsset = requiredQuantities.find((quantity) => quantity.assetId === baseAssetId)?.amount || bn21(0);
    const requiredQuantitiesWithFee = addAmountToCoinQuantities({
      amount: bn21(fee),
      assetId: baseAssetId,
      coinQuantities: requiredQuantities
    });
    const quantitiesDict = {};
    requiredQuantitiesWithFee.forEach(({ amount, assetId }) => {
      quantitiesDict[assetId] = {
        required: amount,
        owned: bn21(0)
      };
    });
    request.inputs.filter(isRequestInputResource).forEach((input) => {
      const isCoin2 = isRequestInputCoin(input);
      const assetId = isCoin2 ? String(input.assetId) : baseAssetId;
      if (quantitiesDict[assetId]) {
        quantitiesDict[assetId].owned = quantitiesDict[assetId].owned.add(input.amount);
      }
    });
    let missingQuantities = [];
    Object.entries(quantitiesDict).forEach(([assetId, { owned, required }]) => {
      if (owned.lt(required)) {
        missingQuantities.push({
          assetId,
          amount: required.sub(owned)
        });
      }
    });
    let needsToBeFunded = missingQuantities.length > 0;
    let fundingAttempts = 0;
    while (needsToBeFunded && fundingAttempts < MAX_FUNDING_ATTEMPTS) {
      const resources = await this.getResourcesToSpend(
        missingQuantities,
        cacheRequestInputsResourcesFromOwner(request.inputs, this.address)
      );
      request.addResources(resources);
      request.updatePredicateGasUsed(estimatedPredicates);
      const requestToReestimate2 = clone9(request);
      if (addedSignatures) {
        Array.from({ length: addedSignatures }).forEach(
          () => requestToReestimate2.addEmptyWitness()
        );
      }
      if (!updateMaxFee) {
        needsToBeFunded = false;
        break;
      }
      const { maxFee: newFee } = await this.provider.estimateTxGasAndFee({
        transactionRequest: requestToReestimate2,
        gasPrice
      });
      const totalBaseAssetOnInputs = getAssetAmountInRequestInputs(
        request.inputs.filter(isRequestInputResource),
        baseAssetId,
        baseAssetId
      );
      const totalBaseAssetRequiredWithFee = requiredInBaseAsset.add(newFee);
      if (totalBaseAssetOnInputs.gt(totalBaseAssetRequiredWithFee)) {
        needsToBeFunded = false;
      } else {
        missingQuantities = [
          {
            amount: totalBaseAssetRequiredWithFee.sub(totalBaseAssetOnInputs),
            assetId: baseAssetId
          }
        ];
      }
      fundingAttempts += 1;
    }
    if (needsToBeFunded) {
      throw new FuelError22(
        ErrorCode19.INSUFFICIENT_FUNDS_OR_MAX_COINS,
        `The account ${this.address} does not have enough base asset funds to cover the transaction execution.`
      );
    }
    request.updateState(chainId, "funded", transactionSummary);
    await this.provider.validateTransaction(request);
    request.updatePredicateGasUsed(estimatedPredicates);
    const requestToReestimate = clone9(request);
    if (addedSignatures) {
      Array.from({ length: addedSignatures }).forEach(() => requestToReestimate.addEmptyWitness());
    }
    if (!updateMaxFee) {
      return request;
    }
    const { maxFee } = await this.provider.estimateTxGasAndFee({
      transactionRequest: requestToReestimate,
      gasPrice
    });
    request.maxFee = maxFee;
    return request;
  }
  /**
   * A helper that creates a transfer transaction request and returns it.
   *
   * @param destination - The address of the destination.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer (optional).
   * @param txParams - The transaction parameters (optional).
   * @returns A promise that resolves to the prepared transaction request.
   */
  async createTransfer(destination, amount, assetId, txParams = {}) {
    let request = new ScriptTransactionRequest(txParams);
    request = this.addTransfer(request, {
      destination,
      amount,
      assetId: assetId || await this.provider.getBaseAssetId()
    });
    const { gasPrice, transactionRequest } = await this.assembleTx(request);
    request = await setAndValidateGasAndFeeForAssembledTx({
      gasPrice,
      provider: this.provider,
      transactionRequest,
      setGasLimit: txParams?.gasLimit,
      setMaxFee: txParams?.maxFee
    });
    return request;
  }
  /**
   * Transfers coins to a destination address.
   *
   * @param destination - The address of the destination.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer (optional).
   * @param txParams - The transaction parameters (optional).
   * @returns A promise that resolves to the transaction response.
   */
  async transfer(destination, amount, assetId, txParams = {}) {
    const request = await this.createTransfer(destination, amount, assetId, txParams);
    return this.sendTransaction(request, { estimateTxDependencies: false });
  }
  /**
   * Transfers multiple amounts of a token to multiple recipients.
   *
   * @param transferParams - An array of `TransferParams` objects representing the transfers to be made.
   * @param txParams - Optional transaction parameters.
   * @returns A promise that resolves to a `TransactionResponse` object representing the transaction result.
   */
  async batchTransfer(transferParams, txParams = {}) {
    let request = new ScriptTransactionRequest(txParams);
    request = this.addBatchTransfer(request, transferParams);
    const { gasPrice, transactionRequest } = await this.assembleTx(request);
    request = await setAndValidateGasAndFeeForAssembledTx({
      gasPrice,
      provider: this.provider,
      transactionRequest,
      setGasLimit: txParams?.gasLimit,
      setMaxFee: txParams?.maxFee
    });
    return this.sendTransaction(request, { estimateTxDependencies: false });
  }
  /**
   * Adds a transfer to the given transaction request.
   *
   * @param request - The script transaction request to add transfers to.
   * @param transferParams - The object representing the transfer to be made.
   * @returns The updated transaction request with the added transfer.
   */
  addTransfer(request, transferParams) {
    const { destination, amount, assetId } = transferParams;
    this.validateTransferAmount(amount);
    request.addCoinOutput(new Address5(destination), amount, assetId);
    return request;
  }
  /**
   * Adds multiple transfers to a script transaction request.
   *
   * @param request - The script transaction request to add transfers to.
   * @param transferParams - An array of `TransferParams` objects representing the transfers to be made.
   * @returns The updated script transaction request.
   */
  addBatchTransfer(request, transferParams) {
    transferParams.forEach(({ destination, amount, assetId }) => {
      this.addTransfer(request, {
        destination,
        amount,
        assetId
      });
    });
    return request;
  }
  /**
   * Transfers coins to a contract address.
   *
   * @param contractId - The address of the contract.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer (optional).
   * @param txParams - The transaction parameters (optional).
   * @returns A promise that resolves to the transaction response.
   */
  async transferToContract(contractId, amount, assetId, txParams = {}) {
    return this.batchTransferToContracts([{ amount, assetId, contractId }], txParams);
  }
  async batchTransferToContracts(contractTransferParams, txParams = {}) {
    let request = new ScriptTransactionRequest({
      ...txParams
    });
    const quantities = [];
    const defaultAssetId = await this.provider.getBaseAssetId();
    const transferParams = contractTransferParams.map((transferParam) => {
      const amount = bn21(transferParam.amount);
      const contractAddress = new Address5(transferParam.contractId);
      const assetId = transferParam.assetId ? hexlify21(transferParam.assetId) : defaultAssetId;
      if (amount.lte(0)) {
        throw new FuelError22(
          ErrorCode19.INVALID_TRANSFER_AMOUNT,
          "Transfer amount must be a positive number."
        );
      }
      request.addContractInputAndOutput(contractAddress);
      quantities.push({ amount, assetId });
      return {
        amount,
        contractId: contractAddress.toB256(),
        assetId
      };
    });
    const { script, scriptData } = await assembleTransferToContractScript(transferParams);
    request.script = script;
    request.scriptData = scriptData;
    const { gasPrice, transactionRequest } = await this.assembleTx(request, quantities);
    request = await setAndValidateGasAndFeeForAssembledTx({
      gasPrice,
      provider: this.provider,
      transactionRequest,
      setGasLimit: txParams?.gasLimit,
      setMaxFee: txParams?.maxFee
    });
    return this.sendTransaction(request);
  }
  /**
   * Withdraws an amount of the base asset to the base chain.
   *
   * @param recipient - Address of the recipient on the base chain.
   * @param amount - Amount of base asset.
   * @param txParams - The transaction parameters (optional).
   * @returns A promise that resolves to the transaction response.
   */
  async withdrawToBaseLayer(recipient, amount, txParams = {}) {
    const recipientAddress = new Address5(recipient);
    const recipientDataArray = arrayify17(
      "0x".concat(recipientAddress.toHexString().substring(2).padStart(64, "0"))
    );
    const amountDataArray = arrayify17(
      "0x".concat(bn21(amount).toHex().substring(2).padStart(16, "0"))
    );
    const script = new Uint8Array([
      ...arrayify17(withdrawScript.bytes),
      ...recipientDataArray,
      ...amountDataArray
    ]);
    const params = { script, ...txParams };
    const baseAssetId = await this.provider.getBaseAssetId();
    let request = new ScriptTransactionRequest(params);
    const quantities = [{ amount: bn21(amount), assetId: baseAssetId }];
    const { gasPrice, transactionRequest } = await this.assembleTx(request, quantities);
    request = await setAndValidateGasAndFeeForAssembledTx({
      gasPrice,
      provider: this.provider,
      transactionRequest,
      setGasLimit: txParams?.gasLimit,
      setMaxFee: txParams?.maxFee
    });
    return this.sendTransaction(request);
  }
  /**
   * Consolidates base asset UTXOs into fewer, larger ones.
   *
   * Retrieves a limited number of base asset coins (as defined by `Provider.RESOURCES_PAGE_SIZE_LIMIT`),
   * assembles consolidation transactions, and submits them to the network.
   *
   * Note: This method currently supports only the base asset.
   *
   * @param params - The parameters for coin consolidation, including the asset ID, mode, and output number.
   * @returns A promise that resolves to the response of the submitted transactions.
   * @throws Will throw an error if the asset is not a base asset as non-base asset consolidation is not implemented.
   */
  async consolidateCoins(params) {
    const { assetId } = params;
    const { coins } = await this.getCoins(assetId);
    const baseAssetId = await this.provider.getBaseAssetId();
    const isBaseAsset = baseAssetId === assetId;
    let submitAll;
    const consolidationParams = {
      coins,
      mode: params.mode,
      outputNum: params.outputNum
    };
    if (isBaseAsset) {
      ({ submitAll } = await this.assembleBaseAssetConsolidationTxs(consolidationParams));
    } else {
      throw new FuelError22(
        ErrorCode19.UNSUPPORTED_FEATURE,
        "Consolidation for non-base assets is not supported yet."
      );
    }
    return submitAll();
  }
  /**
   * Assembles transactions for consolidating base asset coins into fewer UTXOs.
   *
   * This method splits the provided coins into batches and creates transaction requests
   * to consolidate them. It calculates the necessary fee and sets up the transactions
   * to be submitted either in parallel (default) or sequentially.
   *
   * @param params - The parameters for assembling base asset consolidation transactions.
   *
   * @returns An object containing the assembled transactions, the total fee cost, and a callback to submit all transactions.
   */
  async assembleBaseAssetConsolidationTxs(params) {
    const { coins, mode = "parallel", outputNum = 1 } = params;
    const baseAssetId = await this.provider.getBaseAssetId();
    this.validateConsolidationTxsCoins(coins, baseAssetId);
    const chainInfo = await this.provider.getChain();
    const maxInputsNumber = chainInfo.consensusParameters.txParameters.maxInputs.toNumber();
    let totalFeeCost = bn21(0);
    const txs = [];
    const coinsBatches = splitCoinsIntoBatches(coins, maxInputsNumber);
    const gasPrice = await this.provider.estimateGasPrice(10);
    const consolidateMoreThanOneCoin = outputNum > 1;
    coinsBatches.filter((batch) => batch.length > 1).forEach((coinBatch) => {
      const request = new ScriptTransactionRequest({
        script: "0x"
      });
      request.addResources(coinBatch);
      if (consolidateMoreThanOneCoin) {
        Array.from({ length: outputNum - 1 }).forEach(() => {
          request.addCoinOutput(this.address, 0, baseAssetId);
        });
      }
      const minGas = request.calculateMinGas(chainInfo);
      const fee = calculateGasFee({
        gasPrice,
        gas: minGas,
        priceFactor: chainInfo.consensusParameters.feeParameters.gasPriceFactor,
        tip: request.tip
      });
      request.maxFee = fee;
      if (consolidateMoreThanOneCoin) {
        const total = request.inputs.filter(isRequestInputCoin).reduce((acc, input) => acc.add(input.amount), bn21(0));
        const amountPerNewUtxo = total.div(outputNum + 1);
        request.outputs.forEach((output) => {
          if (output.type === OutputType9.Coin) {
            output.amount = amountPerNewUtxo;
          }
        });
      }
      totalFeeCost = totalFeeCost.add(fee);
      txs.push(request);
    });
    const submitAll = this.prepareSubmitAll({ txs, mode });
    return { txs, totalFeeCost, submitAll };
  }
  /**
   * Prepares a function to submit all transactions either sequentially or in parallel.
   *
   * @param params - The parameters for preparing the submitAll callback.
   *
   * @returns A callback that, when called, submits all transactions and returns their results and any errors encountered.
   */
  prepareSubmitAll = /* @__PURE__ */ __name((params) => {
    const { txs, mode = "sequential" } = params;
    return async () => {
      const txResponses = [];
      const errors = [];
      if (mode === "sequential") {
        for (const tx of txs) {
          try {
            const submit = await this.sendTransaction(tx);
            const response = await submit.waitForResult();
            txResponses.push(response);
          } catch (error) {
            errors.push(error);
          }
        }
      } else {
        const results = await Promise.allSettled(
          txs.map(async (tx) => {
            const submit = await this.sendTransaction(tx);
            return submit.waitForResult();
          })
        );
        results.forEach((result) => {
          if (result.status === "fulfilled") {
            txResponses.push(result.value);
          } else {
            errors.push(result.reason);
          }
        });
      }
      return { txResponses, errors };
    };
  }, "prepareSubmitAll");
  /**
   * Returns a transaction cost to enable user
   * to set gasLimit and also reserve balance amounts
   * on the transaction.
   *
   * @param transactionRequestLike - The transaction request object.
   * @param transactionCostParams - The transaction cost parameters (optional).
   *
   * @returns A promise that resolves to the transaction cost object.
   *
   * @deprecated Use provider.assembleTx instead
   * Check the migration guide https://docs.fuel.network/guide/assembling-transactions/migration-guide.html for more information.
   */
  async getTransactionCost(transactionRequestLike, { signatureCallback, quantities = [], gasPrice } = {}) {
    const txRequestClone = clone9(transactionRequestify(transactionRequestLike));
    const baseAssetId = await this.provider.getBaseAssetId();
    const coinOutputsQuantities = txRequestClone.getCoinOutputsQuantities();
    const requiredQuantities = mergeQuantities(coinOutputsQuantities, quantities);
    const transactionFeeForDryRun = [{ assetId: baseAssetId, amount: bn21("100000000000000000") }];
    const findAssetInput = /* @__PURE__ */ __name((assetId) => txRequestClone.inputs.find((input) => {
      if (input.type === InputType8.Coin) {
        return input.assetId === assetId;
      }
      if (isRequestInputMessageWithoutData(input)) {
        return baseAssetId === assetId;
      }
      return false;
    }), "findAssetInput");
    const updateAssetInput = /* @__PURE__ */ __name((assetId, quantity) => {
      const assetInput = findAssetInput(assetId);
      const usedQuantity = quantity;
      if (assetInput && "amount" in assetInput) {
        assetInput.amount = usedQuantity;
      } else {
        txRequestClone.addResources(
          this.generateFakeResources([
            {
              amount: quantity,
              assetId
            }
          ])
        );
      }
    }, "updateAssetInput");
    mergeQuantities(requiredQuantities, transactionFeeForDryRun).forEach(
      ({ amount, assetId }) => updateAssetInput(assetId, amount)
    );
    const txCost = await this.provider.getTransactionCost(txRequestClone, {
      signatureCallback,
      gasPrice
    });
    return {
      ...txCost,
      requiredQuantities
    };
  }
  /**
   * Sign a message from the account via the connector.
   *
   * @param message - the message to sign.
   * @returns a promise that resolves to the signature.
   *
   * @hidden
   */
  async signMessage(message) {
    if (!this._connector) {
      throw new FuelError22(ErrorCode19.MISSING_CONNECTOR, "A connector is required to sign messages.");
    }
    return this._connector.signMessage(this.address.toString(), message);
  }
  /**
   * Signs a transaction from the account via the connector..
   *
   * @param transactionRequestLike - The transaction request to sign.
   * @returns A promise that resolves to the signature of the transaction.
   */
  async signTransaction(transactionRequestLike) {
    if (!this._connector) {
      throw new FuelError22(
        ErrorCode19.MISSING_CONNECTOR,
        "A connector is required to sign transactions."
      );
    }
    return this._connector.signTransaction(this.address.toString(), transactionRequestLike);
  }
  /**
   * Sends a transaction to the network.
   *
   * @param transactionRequestLike - The transaction request to be sent.
   * @param sendTransactionParams - The provider send transaction parameters (optional).
   * @returns A promise that resolves to the transaction response.
   */
  async sendTransaction(transactionRequestLike, { estimateTxDependencies = true, ...connectorOptions } = {}) {
    let transactionRequest = transactionRequestify(transactionRequestLike);
    if (this._connector) {
      const { onBeforeSend, skipCustomFee = false } = connectorOptions;
      transactionRequest = await this.prepareTransactionForSend(transactionRequest);
      const params = {
        onBeforeSend,
        skipCustomFee,
        provider: {
          url: this.provider.url,
          cache: await serializeProviderCache(this.provider)
        },
        transactionState: transactionRequest.flag.state,
        transactionSummary: await this.prepareTransactionSummary(transactionRequest)
      };
      const transaction = await this._connector.sendTransaction(
        this.address.toString(),
        transactionRequest,
        params
      );
      return typeof transaction === "string" ? this.provider.getTransactionResponse(transaction) : transaction;
    }
    if (estimateTxDependencies) {
      await this.provider.estimateTxDependencies(transactionRequest);
    }
    return this.provider.sendTransaction(transactionRequest, {
      estimateTxDependencies: false
    });
  }
  /**
   * Simulates a transaction.
   *
   * @param transactionRequestLike - The transaction request to be simulated.
   * @param estimateTxParams - The estimate transaction params (optional).
   * @returns A promise that resolves to the call result.
   */
  async simulateTransaction(transactionRequestLike, { estimateTxDependencies = true } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      await this.provider.estimateTxDependencies(transactionRequest);
    }
    return this.provider.simulate(transactionRequest, { estimateTxDependencies: false });
  }
  /**
   * Generates an array of fake resources based on the provided coins.
   *
   * @param coins - An array of `FakeResources` objects representing the coins.
   * @returns An array of `Resource` objects with generated properties.
   */
  generateFakeResources(coins) {
    return coins.map((coin) => ({
      id: hexlify21(randomBytes5(UTXO_ID_LEN3)),
      owner: this.address,
      blockCreated: bn21(1),
      txCreatedIdx: bn21(1),
      ...coin
    }));
  }
  /** @hidden */
  async prepareTransactionForSend(request) {
    const { transactionId } = request.flag;
    if (!isDefined4(transactionId)) {
      return request;
    }
    const chainId = await this.provider.getChainId();
    const currentTransactionId = request.getTransactionId(chainId);
    if (transactionId !== currentTransactionId) {
      request.updateState(chainId);
    }
    return request;
  }
  /** @hidden */
  async prepareTransactionSummary(request) {
    const chainId = await this.provider.getChainId();
    return isDefined4(request.flag.summary) ? {
      ...request.flag.summary,
      id: request.getTransactionId(chainId),
      transactionBytes: hexlify21(request.toTransactionBytes())
    } : void 0;
  }
  /** @hidden * */
  async assembleTx(transactionRequest, quantities = []) {
    const outputQuantities = transactionRequest.outputs.filter((o) => o.type === OutputType9.Coin).map(({ amount, assetId }) => ({ assetId: String(assetId), amount: bn21(amount) }));
    transactionRequest.gasLimit = bn21(0);
    transactionRequest.maxFee = bn21(0);
    const { assembledRequest, gasPrice } = await this.provider.assembleTx({
      request: transactionRequest,
      accountCoinQuantities: mergeQuantities(outputQuantities, quantities),
      feePayerAccount: this
    });
    return { transactionRequest: assembledRequest, gasPrice };
  }
  /** @hidden * */
  validateTransferAmount(amount) {
    if (bn21(amount).lte(0)) {
      throw new FuelError22(
        ErrorCode19.INVALID_TRANSFER_AMOUNT,
        "Transfer amount must be a positive number."
      );
    }
  }
  /** @hidden * */
  async estimateAndFundTransaction(transactionRequest, txParams, costParams) {
    let request = transactionRequest;
    const txCost = await this.getTransactionCost(request, costParams);
    request = this.validateGasLimitAndMaxFee({
      transactionRequest: request,
      gasUsed: txCost.gasUsed,
      maxFee: txCost.maxFee,
      txParams
    });
    request = await this.fund(request, txCost);
    return request;
  }
  /** @hidden * */
  validateGasLimitAndMaxFee({
    gasUsed,
    maxFee,
    transactionRequest,
    txParams: { gasLimit: setGasLimit, maxFee: setMaxFee }
  }) {
    const request = transactionRequestify(transactionRequest);
    if (!isDefined4(setGasLimit)) {
      request.gasLimit = gasUsed;
    } else if (gasUsed.gt(setGasLimit)) {
      throw new FuelError22(
        ErrorCode19.GAS_LIMIT_TOO_LOW,
        `Gas limit '${setGasLimit}' is lower than the required: '${gasUsed}'.`
      );
    }
    if (!isDefined4(setMaxFee)) {
      request.maxFee = maxFee;
    } else if (maxFee.gt(setMaxFee)) {
      throw new FuelError22(
        ErrorCode19.MAX_FEE_TOO_LOW,
        `Max fee '${setMaxFee}' is lower than the required: '${maxFee}'.`
      );
    }
    return request;
  }
  /** @hidden * */
  validateConsolidationTxsCoins(coins, assetId) {
    if (coins.length <= 1) {
      throw new FuelError22(ErrorCode19.NO_COINS_TO_CONSOLIDATE, "No coins to consolidate.");
    }
    if (!coins.every((c) => c.assetId === assetId)) {
      throw new FuelError22(
        ErrorCode19.COINS_ASSET_ID_MISMATCH,
        "All coins to consolidate must be from the same asset id."
      );
    }
  }
};

// src/wallet/keystore-wallet.ts
import { Address as Address6 } from "@fuel-ts/address";
import {
  bufferFromString,
  keccak256,
  randomBytes as randomBytes6,
  scrypt,
  stringFromBuffer,
  decryptJsonWalletData,
  encryptJsonWalletData,
  randomUUID as randomUUID2
} from "@fuel-ts/crypto";
import { ErrorCode as ErrorCode20, FuelError as FuelError23 } from "@fuel-ts/errors";
import { hexlify as hexlify22 } from "@fuel-ts/utils";
var DEFAULT_KDF_PARAMS_LOG_N = 13;
var DEFAULT_KDF_PARAMS_R = 8;
var DEFAULT_KDF_PARAMS_P = 1;
var DEFAULT_KEY_SIZE = 32;
var DEFAULT_IV_SIZE = 16;
var removeHexPrefix = /* @__PURE__ */ __name((hexString) => {
  if (/^0x/.test(hexString)) {
    return hexString.slice(2);
  }
  return hexString;
}, "removeHexPrefix");
async function encryptKeystoreWallet(privateKey, address, password) {
  const privateKeyBuffer = bufferFromString(removeHexPrefix(privateKey), "hex");
  const ownerAddress = new Address6(address);
  const salt = randomBytes6(DEFAULT_KEY_SIZE);
  const key = scrypt({
    password: bufferFromString(password),
    salt,
    dklen: DEFAULT_KEY_SIZE,
    n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
    r: DEFAULT_KDF_PARAMS_R,
    p: DEFAULT_KDF_PARAMS_P
  });
  const iv = randomBytes6(DEFAULT_IV_SIZE);
  const ciphertext = await encryptJsonWalletData(privateKeyBuffer, key, iv);
  const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertext]);
  const macHashUint8Array = keccak256(data);
  const mac = stringFromBuffer(macHashUint8Array, "hex");
  const keystore = {
    id: randomUUID2(),
    version: 3,
    address: removeHexPrefix(ownerAddress.toHexString()),
    crypto: {
      cipher: "aes-128-ctr",
      mac,
      cipherparams: { iv: stringFromBuffer(iv, "hex") },
      ciphertext: stringFromBuffer(ciphertext, "hex"),
      kdf: "scrypt",
      kdfparams: {
        dklen: DEFAULT_KEY_SIZE,
        n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
        p: DEFAULT_KDF_PARAMS_P,
        r: DEFAULT_KDF_PARAMS_R,
        salt: stringFromBuffer(salt, "hex")
      }
    }
  };
  return JSON.stringify(keystore);
}
__name(encryptKeystoreWallet, "encryptKeystoreWallet");
async function decryptKeystoreWallet(jsonWallet, password) {
  const keystoreWallet = JSON.parse(jsonWallet);
  const {
    crypto: {
      mac,
      ciphertext,
      cipherparams: { iv },
      kdfparams: { dklen, n, r, p, salt }
    }
  } = keystoreWallet;
  const ciphertextBuffer = bufferFromString(ciphertext, "hex");
  const ivBuffer = bufferFromString(iv, "hex");
  const saltBuffer = bufferFromString(salt, "hex");
  const passwordBuffer = bufferFromString(password);
  const key = scrypt({
    password: passwordBuffer,
    salt: saltBuffer,
    n,
    p,
    r,
    dklen
  });
  const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertextBuffer]);
  const macHashUint8Array = keccak256(data);
  const macHash = stringFromBuffer(macHashUint8Array, "hex");
  if (mac !== macHash) {
    throw new FuelError23(
      ErrorCode20.INVALID_PASSWORD,
      "Failed to decrypt the keystore wallet, the provided password is incorrect."
    );
  }
  const buffer = await decryptJsonWalletData(ciphertextBuffer, key, ivBuffer);
  const privateKey = hexlify22(buffer);
  return privateKey;
}
__name(decryptKeystoreWallet, "decryptKeystoreWallet");

// src/wallet/base-wallet-unlocked.ts
var BaseWalletUnlocked = class extends Account {
  static {
    __name(this, "BaseWalletUnlocked");
  }
  /**
   * Default HDWallet path.
   */
  static defaultPath = "m/44'/1179993420'/0'/0/0";
  /**
   * A function that returns the wallet's signer.
   */
  signer;
  /**
   * Creates a new BaseWalletUnlocked instance.
   *
   * @param privateKey - The private key of the wallet.
   * @param provider - A Provider instance (optional).
   */
  constructor(privateKey, provider) {
    const signer = new Signer(privateKey);
    super(signer.address, provider);
    this.signer = () => signer;
  }
  /**
   * Gets the private key of the wallet.
   *
   * @returns The private key of the wallet.
   */
  get privateKey() {
    return this.signer().privateKey;
  }
  /**
   * Gets the public key of the wallet.
   *
   * @returns
   */
  get publicKey() {
    return this.signer().publicKey;
  }
  /**
   * Signs a message with the wallet's private key.
   *
   * @param message - The message to sign.
   * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
   */
  async signMessage(message) {
    const signedMessage = await this.signer().sign(hashMessage(message));
    return hexlify23(signedMessage);
  }
  /**
   * Signs a transaction with the wallet's private key.
   *
   * @param transactionRequestLike - The transaction request to sign.
   * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
   */
  async signTransaction(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    const chainId = await this.provider.getChainId();
    const hashedTransaction = transactionRequest.getTransactionId(chainId);
    const signature = await this.signer().sign(hashedTransaction);
    return hexlify23(signature);
  }
  /**
   * Populates a transaction with the witnesses signature.
   *
   * @param transactionRequestLike - The transaction request to populate.
   * @returns The populated transaction request.
   */
  async populateTransactionWitnessesSignature(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    const signedTransaction = await this.signTransaction(transactionRequest);
    transactionRequest.updateWitnessByOwner(this.address, signedTransaction);
    return transactionRequest;
  }
  /**
   * Populates the witness signature for a transaction and sends it to the network using `provider.sendTransaction`.
   *
   * @param transactionRequestLike - The transaction request to send.
   * @param estimateTxDependencies - Whether to estimate the transaction dependencies.
   * @returns A promise that resolves to the TransactionResponse object.
   */
  async sendTransaction(transactionRequestLike, { estimateTxDependencies = false, enableAssetBurn } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    validateTransactionForAssetBurn(
      await this.provider.getBaseAssetId(),
      transactionRequest,
      enableAssetBurn
    );
    if (estimateTxDependencies) {
      await this.provider.estimateTxDependencies(transactionRequest);
    }
    return this.provider.sendTransaction(
      await this.populateTransactionWitnessesSignature(transactionRequest),
      { estimateTxDependencies: false, enableAssetBurn }
    );
  }
  /**
   * Populates the witness signature for a transaction and sends a call to the network using `provider.dryRun`.
   *
   * @param transactionRequestLike - The transaction request to simulate.
   * @returns A promise that resolves to the CallResult object.
   */
  async simulateTransaction(transactionRequestLike, { estimateTxDependencies = true } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      await this.provider.estimateTxDependencies(transactionRequest);
    }
    return this.provider.dryRun(
      await this.populateTransactionWitnessesSignature(transactionRequest),
      {
        utxoValidation: true,
        estimateTxDependencies: false
      }
    );
  }
  /**
   * Encrypts an unlocked wallet with a password.
   *
   * @param password - the password to encrypt the wallet with.
   * @returns - the encrypted wallet.
   */
  async encrypt(password) {
    return encryptKeystoreWallet(this.privateKey, this.address, password);
  }
};

// src/hdwallet/hdwallet.ts
import { computeHmac as computeHmac2, ripemd160 } from "@fuel-ts/crypto";
import { ErrorCode as ErrorCode23, FuelError as FuelError26 } from "@fuel-ts/errors";
import { sha256 as sha2564 } from "@fuel-ts/hasher";
import { bn as bn22, toBytes as toBytes2, toHex } from "@fuel-ts/math";
import { arrayify as arrayify20, hexlify as hexlify25, concat as concat6, dataSlice as dataSlice2, encodeBase58 as encodeBase582, decodeBase58 } from "@fuel-ts/utils";

// src/mnemonic/mnemonic.ts
import { randomBytes as randomBytes7, pbkdf2, computeHmac } from "@fuel-ts/crypto";
import { ErrorCode as ErrorCode22, FuelError as FuelError25 } from "@fuel-ts/errors";
import { sha256 as sha2563 } from "@fuel-ts/hasher";
import { arrayify as arrayify19, hexlify as hexlify24, concat as concat5, dataSlice, encodeBase58, toUtf8Bytes } from "@fuel-ts/utils";

// src/wordlists/words/english.ts
var english = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];

// src/mnemonic/utils.ts
import { ErrorCode as ErrorCode21, FuelError as FuelError24 } from "@fuel-ts/errors";
import { sha256 as sha2562 } from "@fuel-ts/hasher";
import { arrayify as arrayify18 } from "@fuel-ts/utils";
function getLowerMask(bits) {
  return (1 << bits) - 1;
}
__name(getLowerMask, "getLowerMask");
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits;
}
__name(getUpperMask, "getUpperMask");
function getWords(mnemonic) {
  if (!Array.isArray(mnemonic)) {
    return mnemonic.split(/\s+/);
  }
  return mnemonic;
}
__name(getWords, "getWords");
function getPhrase(mnemonic) {
  if (Array.isArray(mnemonic)) {
    return mnemonic.join(" ");
  }
  return mnemonic;
}
__name(getPhrase, "getPhrase");
function entropyToMnemonicIndices(entropy) {
  const indices = [0];
  let remainingBits = 11;
  for (let i = 0; i < entropy.length; i += 1) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
      indices.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum = arrayify18(sha2562(entropy))[0] & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum >> 8 - checksumBits;
  return indices;
}
__name(entropyToMnemonicIndices, "entropyToMnemonicIndices");
function mnemonicWordsToEntropy(words, wordlist) {
  const size = Math.ceil(11 * words.length / 8);
  const entropy = arrayify18(new Uint8Array(size));
  let offset = 0;
  for (let i = 0; i < words.length; i += 1) {
    const index = wordlist.indexOf(words[i].normalize("NFKD"));
    if (index === -1) {
      throw new FuelError24(
        ErrorCode21.INVALID_MNEMONIC,
        `Invalid mnemonic: the word '${words[i]}' is not found in the provided wordlist.`
      );
    }
    for (let bit = 0; bit < 11; bit += 1) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset += 1;
    }
  }
  const entropyBits = 32 * words.length / 3;
  const checksumBits = words.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum = arrayify18(sha2562(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
    throw new FuelError24(
      ErrorCode21.INVALID_CHECKSUM,
      "Checksum validation failed for the provided mnemonic."
    );
  }
  return entropy.slice(0, entropyBits / 8);
}
__name(mnemonicWordsToEntropy, "mnemonicWordsToEntropy");

// src/mnemonic/mnemonic.ts
var MasterSecret = toUtf8Bytes("Bitcoin seed");
var MainnetPRV = "0x0488ade4";
var TestnetPRV = "0x04358394";
var MNEMONIC_SIZES = [12, 15, 18, 21, 24];
function assertWordList(wordlist) {
  if (wordlist.length !== 2048) {
    throw new FuelError25(
      ErrorCode22.INVALID_WORD_LIST,
      `Expected word list length of 2048, but got ${wordlist.length}.`
    );
  }
}
__name(assertWordList, "assertWordList");
function assertEntropy(entropy) {
  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new FuelError25(
      ErrorCode22.INVALID_ENTROPY,
      `Entropy should be between 16 and 32 bytes and a multiple of 4, but got ${entropy.length} bytes.`
    );
  }
}
__name(assertEntropy, "assertEntropy");
function assertMnemonic(words) {
  if (!MNEMONIC_SIZES.includes(words.length)) {
    const errorMsg = `Invalid mnemonic size. Expected one of [${MNEMONIC_SIZES.join(
      ", "
    )}] words, but got ${words.length}.`;
    throw new FuelError25(ErrorCode22.INVALID_MNEMONIC, errorMsg);
  }
}
__name(assertMnemonic, "assertMnemonic");
var Mnemonic = class _Mnemonic {
  static {
    __name(this, "Mnemonic");
  }
  wordlist;
  /**
   *
   * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.
   * @returns Mnemonic instance
   */
  constructor(wordlist = english) {
    this.wordlist = wordlist;
    assertWordList(this.wordlist);
  }
  /**
   *
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @returns Entropy hash
   */
  mnemonicToEntropy(phrase) {
    return _Mnemonic.mnemonicToEntropy(phrase, this.wordlist);
  }
  /**
   *
   * @param entropy - Entropy source to the mnemonic phrase.
   * @returns Mnemonic phrase
   */
  entropyToMnemonic(entropy) {
    return _Mnemonic.entropyToMnemonic(entropy, this.wordlist);
  }
  /**
   *
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.
   * @returns Mnemonic phrase
   */
  static mnemonicToEntropy(phrase, wordlist = english) {
    const words = getWords(phrase);
    assertMnemonic(words);
    return hexlify24(mnemonicWordsToEntropy(words, wordlist));
  }
  /**
   * @param entropy - Entropy source to the mnemonic phrase.
   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static entropyToMnemonic(entropy, wordlist = english) {
    const entropyBytes = arrayify19(entropy);
    assertWordList(wordlist);
    assertEntropy(entropyBytes);
    return entropyToMnemonicIndices(entropyBytes).map((i) => wordlist[i]).join(" ");
  }
  /**
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static mnemonicToSeed(phrase, passphrase = "") {
    assertMnemonic(getWords(phrase));
    const phraseBytes = toUtf8Bytes(getPhrase(phrase));
    const salt = toUtf8Bytes(`mnemonic${passphrase}`);
    return pbkdf2(phraseBytes, salt, 2048, 64, "sha512");
  }
  /**
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static mnemonicToMasterKeys(phrase, passphrase = "") {
    const seed = _Mnemonic.mnemonicToSeed(phrase, passphrase);
    return _Mnemonic.masterKeysFromSeed(seed);
  }
  /**
   * Validates if given mnemonic is  valid
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @returns true if phrase is a valid mnemonic
   */
  static isMnemonicValid(phrase) {
    const words = getWords(phrase);
    let i = 0;
    try {
      assertMnemonic(words);
    } catch {
      return false;
    }
    while (i < words.length) {
      if (_Mnemonic.binarySearch(words[i]) === false) {
        return false;
      }
      i += 1;
    }
    return true;
  }
  static binarySearch(target) {
    const words = english;
    let left = 0;
    let right = words.length - 1;
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      if (words[mid] === target) {
        return true;
      }
      if (target < words[mid]) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    }
    return false;
  }
  /**
   * @param seed - BIP39 seed
   * @param testnet - Inform if should use testnet or mainnet prefix, the default value is true (`mainnet`).
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static masterKeysFromSeed(seed) {
    const seedArray = arrayify19(seed);
    if (seedArray.length < 16 || seedArray.length > 64) {
      throw new FuelError25(
        ErrorCode22.INVALID_SEED,
        `Seed length should be between 16 and 64 bytes, but received ${seedArray.length} bytes.`
      );
    }
    return arrayify19(computeHmac("sha512", MasterSecret, seedArray));
  }
  /**
   * Get the extendKey as defined on BIP-32 from the provided seed
   *
   * @param seed - BIP39 seed
   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
   * @returns BIP-32 extended private key
   */
  static seedToExtendedKey(seed, testnet = false) {
    const masterKey = _Mnemonic.masterKeysFromSeed(seed);
    const prefix = arrayify19(testnet ? TestnetPRV : MainnetPRV);
    const depth = "0x00";
    const fingerprint = "0x00000000";
    const index = "0x00000000";
    const chainCode = masterKey.slice(32);
    const privateKey = masterKey.slice(0, 32);
    const extendedKey = concat5([
      prefix,
      depth,
      fingerprint,
      index,
      chainCode,
      concat5(["0x00", privateKey])
    ]);
    const checksum = dataSlice(sha2563(sha2563(extendedKey)), 0, 4);
    return encodeBase58(concat5([extendedKey, checksum]));
  }
  /**
   *  Create a new mnemonic using a randomly generated number as entropy.
   *  As defined in BIP39, the entropy must be a multiple of 32 bits, and its size must be between 128 and 256 bits.
   *  Therefore, the possible values for `strength` are 128, 160, 192, 224, and 256.
   *  If not provided, the default entropy length will be set to 256 bits.
   *  The return is a list of words that encodes the generated entropy.
   *
   *
   * @param size - Number of bytes used as an entropy
   * @param extraEntropy - Optional extra entropy to increase randomness
   * @returns A randomly generated mnemonic
   */
  static generate(size = 32, extraEntropy = "") {
    const entropy = extraEntropy ? sha2563(concat5([randomBytes7(size), arrayify19(extraEntropy)])) : randomBytes7(size);
    return _Mnemonic.entropyToMnemonic(entropy);
  }
};
var mnemonic_default = Mnemonic;

// src/hdwallet/hdwallet.ts
var HARDENED_INDEX = 2147483648;
var MainnetPRV2 = hexlify25("0x0488ade4");
var MainnetPUB = hexlify25("0x0488b21e");
var TestnetPRV2 = hexlify25("0x04358394");
var TestnetPUB = hexlify25("0x043587cf");
function base58check(data) {
  return encodeBase582(concat6([data, dataSlice2(sha2564(sha2564(data)), 0, 4)]));
}
__name(base58check, "base58check");
function getExtendedKeyPrefix(isPublic = false, testnet = false) {
  if (isPublic) {
    return testnet ? TestnetPUB : MainnetPUB;
  }
  return testnet ? TestnetPRV2 : MainnetPRV2;
}
__name(getExtendedKeyPrefix, "getExtendedKeyPrefix");
function isPublicExtendedKey(extendedKey) {
  return [MainnetPUB, TestnetPUB].includes(hexlify25(extendedKey.slice(0, 4)));
}
__name(isPublicExtendedKey, "isPublicExtendedKey");
function isValidExtendedKey(extendedKey) {
  return [MainnetPRV2, TestnetPRV2, MainnetPUB, TestnetPUB].includes(
    hexlify25(extendedKey.slice(0, 4))
  );
}
__name(isValidExtendedKey, "isValidExtendedKey");
function parsePath(path2, depth = 0) {
  const components = path2.split("/");
  if (components.length === 0 || components[0] === "m" && depth !== 0) {
    throw new FuelError26(ErrorCode23.HD_WALLET_ERROR, `invalid path - ${path2}`);
  }
  if (components[0] === "m") {
    components.shift();
  }
  return components.map(
    (p) => ~p.indexOf(`'`) ? parseInt(p, 10) + HARDENED_INDEX : parseInt(p, 10)
  );
}
__name(parsePath, "parsePath");
var HDWallet = class _HDWallet {
  static {
    __name(this, "HDWallet");
  }
  depth = 0;
  index = 0;
  fingerprint = hexlify25("0x00000000");
  parentFingerprint = hexlify25("0x00000000");
  privateKey;
  publicKey;
  chainCode;
  /**
   * HDWallet is a implementation of the BIP-0044 and BIP-0032, Multi-Account Hierarchy for Deterministic Wallets
   *
   * @param config - Wallet configurations
   */
  constructor(config) {
    if (config.privateKey) {
      const signer = new Signer(config.privateKey);
      this.publicKey = hexlify25(signer.compressedPublicKey);
      this.privateKey = hexlify25(config.privateKey);
    } else {
      if (!config.publicKey) {
        throw new FuelError26(
          ErrorCode23.HD_WALLET_ERROR,
          "Both public and private Key cannot be missing. At least one should be provided."
        );
      }
      this.publicKey = hexlify25(config.publicKey);
    }
    this.parentFingerprint = config.parentFingerprint || this.parentFingerprint;
    this.fingerprint = dataSlice2(ripemd160(sha2564(this.publicKey)), 0, 4);
    this.depth = config.depth || this.depth;
    this.index = config.index || this.index;
    this.chainCode = config.chainCode;
  }
  get extendedKey() {
    return this.toExtendedKey();
  }
  /**
   * Derive the current HDWallet instance navigating only on the index.
   * `Ex.: m/44'/0 -> Ex.: m/44'/1 -> m/44'/2`. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
   *
   * @param index - Index of the child HDWallet.
   * @returns A new instance of HDWallet on the derived index
   */
  deriveIndex(index) {
    const privateKey = this.privateKey && arrayify20(this.privateKey);
    const publicKey = arrayify20(this.publicKey);
    const chainCode = arrayify20(this.chainCode);
    const data = new Uint8Array(37);
    if (index & HARDENED_INDEX) {
      if (!privateKey) {
        throw new FuelError26(
          ErrorCode23.HD_WALLET_ERROR,
          "Cannot derive a hardened index without a private Key."
        );
      }
      data.set(privateKey, 1);
    } else {
      data.set(arrayify20(this.publicKey));
    }
    data.set(toBytes2(index, 4), 33);
    const bytes = arrayify20(computeHmac2("sha512", chainCode, data));
    const IL = bytes.slice(0, 32);
    const IR = bytes.slice(32);
    if (privateKey) {
      const N = "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141";
      const ki = bn22(IL).add(privateKey).mod(N).toBytes(32);
      return new _HDWallet({
        privateKey: ki,
        chainCode: IR,
        index,
        depth: this.depth + 1,
        parentFingerprint: this.fingerprint
      });
    }
    const signer = new Signer(hexlify25(IL));
    const Ki = signer.addPoint(publicKey);
    return new _HDWallet({
      publicKey: Ki,
      chainCode: IR,
      index,
      depth: this.depth + 1,
      parentFingerprint: this.fingerprint
    });
  }
  /**
   * Derive the current HDWallet instance to the path. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
   *
   * @param path - The string representation of the child HDWallet. `Ex.: m/44'/0'/0'/0/0`
   * @returns A new instance of HDWallet on the derived path
   */
  derivePath(path2) {
    const paths = parsePath(path2, this.depth);
    return paths.reduce((hdwallet, index) => hdwallet.deriveIndex(index), this);
  }
  /**
   * Get the extendKey as defined on BIP-32 from the provided seed
   *
   * @param isPublic - enable to export public extendedKey, it not required when HDWallet didn't have the privateKey.
   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
   * @returns BIP-32 extended private key
   */
  toExtendedKey(isPublic = false, testnet = false) {
    if (this.depth >= 256) {
      throw new FuelError26(
        ErrorCode23.HD_WALLET_ERROR,
        `Exceeded max depth of 255. Current depth: ${this.depth}.`
      );
    }
    const prefix = getExtendedKeyPrefix(this.privateKey == null || isPublic, testnet);
    const depth = hexlify25(Uint8Array.from([this.depth]));
    const parentFingerprint = this.parentFingerprint;
    const index = toHex(this.index, 4);
    const chainCode = this.chainCode;
    const key = this.privateKey != null && !isPublic ? concat6(["0x00", this.privateKey]) : this.publicKey;
    const extendedKey = arrayify20(concat6([prefix, depth, parentFingerprint, index, chainCode, key]));
    return base58check(extendedKey);
  }
  /**
   * Create HDWallet instance from seed
   *
   * @param seed - Seed
   * @returns A new instance of HDWallet
   */
  static fromSeed(seed) {
    const masterKey = mnemonic_default.masterKeysFromSeed(seed);
    return new _HDWallet({
      chainCode: arrayify20(masterKey.slice(32)),
      privateKey: arrayify20(masterKey.slice(0, 32))
    });
  }
  static fromExtendedKey(extendedKey) {
    const decoded = hexlify25(toBytes2(decodeBase58(extendedKey)));
    const bytes = arrayify20(decoded);
    const validChecksum = base58check(bytes.slice(0, 78)) === extendedKey;
    if (bytes.length !== 82 || !isValidExtendedKey(bytes)) {
      throw new FuelError26(ErrorCode23.HD_WALLET_ERROR, "Provided key is not a valid extended key.");
    }
    if (!validChecksum) {
      throw new FuelError26(ErrorCode23.HD_WALLET_ERROR, "Provided key has an invalid checksum.");
    }
    const depth = bytes[4];
    const parentFingerprint = hexlify25(bytes.slice(5, 9));
    const index = parseInt(hexlify25(bytes.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify25(bytes.slice(13, 45));
    const key = bytes.slice(45, 78);
    if (depth === 0 && parentFingerprint !== "0x00000000" || depth === 0 && index !== 0) {
      throw new FuelError26(
        ErrorCode23.HD_WALLET_ERROR,
        "Inconsistency detected: Depth is zero but fingerprint/index is non-zero."
      );
    }
    if (isPublicExtendedKey(bytes)) {
      if (key[0] !== 3) {
        throw new FuelError26(ErrorCode23.HD_WALLET_ERROR, "Invalid public extended key.");
      }
      return new _HDWallet({
        publicKey: key,
        chainCode,
        index,
        depth,
        parentFingerprint
      });
    }
    if (key[0] !== 0) {
      throw new FuelError26(ErrorCode23.HD_WALLET_ERROR, "Invalid private extended key.");
    }
    return new _HDWallet({
      privateKey: key.slice(1),
      chainCode,
      index,
      depth,
      parentFingerprint
    });
  }
};
var hdwallet_default = HDWallet;

// src/wallet/wallets.ts
var WalletLocked = class extends Account {
  static {
    __name(this, "WalletLocked");
  }
  /**
   * Unlocks the wallet using the provided private key and returns an instance of WalletUnlocked.
   *
   * @param privateKey - The private key used to unlock the wallet.
   * @returns An instance of WalletUnlocked.
   */
  unlock(privateKey) {
    return new WalletUnlocked(privateKey, this._provider);
  }
};
var WalletUnlocked = class _WalletUnlocked extends BaseWalletUnlocked {
  static {
    __name(this, "WalletUnlocked");
  }
  /**
   * Locks the wallet and returns an instance of WalletLocked.
   *
   * @returns An instance of WalletLocked.
   */
  lock() {
    this.signer = () => new Signer("0x00");
    return new WalletLocked(this.address, this._provider);
  }
  /**
   * Generate a new Wallet Unlocked with a random key pair.
   *
   * @param generateOptions - Options to customize the generation process (optional).
   * @returns An instance of WalletUnlocked.
   */
  static generate(generateOptions) {
    const privateKey = Signer.generatePrivateKey(generateOptions?.entropy);
    return new _WalletUnlocked(privateKey, generateOptions?.provider);
  }
  /**
   * Create a Wallet Unlocked from a seed.
   *
   * @param seed - The seed phrase.
   * @param provider - A Provider instance (optional).
   * @param path - The derivation path (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromSeed(seed, path2, provider) {
    const hdWallet = hdwallet_default.fromSeed(seed);
    const childWallet = hdWallet.derivePath(path2 || _WalletUnlocked.defaultPath);
    return new _WalletUnlocked(childWallet.privateKey, provider);
  }
  /**
   * Create a Wallet Unlocked from a mnemonic phrase.
   *
   * @param mnemonic - The mnemonic phrase.
   * @param provider - A Provider instance (optional).
   * @param path - The derivation path (optional).
   * @param passphrase - The passphrase for the mnemonic (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromMnemonic(mnemonic, path2, passphrase, provider) {
    const seed = mnemonic_default.mnemonicToSeed(mnemonic, passphrase);
    const hdWallet = hdwallet_default.fromSeed(seed);
    const childWallet = hdWallet.derivePath(path2 || _WalletUnlocked.defaultPath);
    return new _WalletUnlocked(childWallet.privateKey, provider);
  }
  /**
   * Create a Wallet Unlocked from an extended key.
   *
   * @param extendedKey - The extended key.
   * @param provider - A Provider instance (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromExtendedKey(extendedKey, provider) {
    const hdWallet = hdwallet_default.fromExtendedKey(extendedKey);
    return new _WalletUnlocked(hdWallet.privateKey, provider);
  }
  /**
   * Create a Wallet Unlocked from an encrypted JSON.
   *
   * @param jsonWallet - The encrypted JSON keystore.
   * @param password - The password to decrypt the JSON.
   * @param provider - A Provider instance (optional).
   * @returns An unlocked wallet instance.
   */
  static async fromEncryptedJson(jsonWallet, password, provider) {
    const privateKey = await decryptKeystoreWallet(jsonWallet, password);
    return new _WalletUnlocked(privateKey, provider);
  }
};

// src/wallet/wallet.ts
var Wallet = class {
  static {
    __name(this, "Wallet");
  }
  /**
   * Creates a locked wallet instance from an address and a provider.
   *
   * @param address - The address of the wallet.
   * @param provider - A Provider instance (optional).
   * @returns A locked wallet instance.
   */
  static fromAddress(address, provider) {
    return new WalletLocked(address, provider);
  }
  /**
   * Creates an unlocked wallet instance from a private key and a provider.
   *
   * @param privateKey - The private key of the wallet.
   * @param provider - A Provider instance (optional).
   * @returns An unlocked wallet instance.
   */
  static fromPrivateKey(privateKey, provider) {
    return new WalletUnlocked(privateKey, provider);
  }
  /**
   * Generate a new Wallet Unlocked with a random key pair.
   *
   * @param generateOptions - Options to customize the generation process (optional).
   * @returns An unlocked wallet instance.
   */
  static generate = WalletUnlocked.generate;
  /**
   * Create a Wallet Unlocked from a seed.
   *
   * @param seed - The seed phrase.
   * @param provider - A Provider instance (optional).
   * @param path - The derivation path (optional).
   * @returns An unlocked wallet instance.
   */
  static fromSeed = WalletUnlocked.fromSeed;
  /**
   * Create a Wallet Unlocked from a mnemonic phrase.
   *
   * @param mnemonic - The mnemonic phrase.
   * @param provider - A Provider instance (optional).
   * @param path - The derivation path (optional).
   * @param passphrase - The passphrase for the mnemonic (optional).
   * @returns An unlocked wallet instance.
   */
  static fromMnemonic = WalletUnlocked.fromMnemonic;
  /**
   * Create a Wallet Unlocked from an extended key.
   *
   * @param extendedKey - The extended key.
   * @param provider - A Provider instance (optional).
   * @returns An unlocked wallet instance.
   */
  static fromExtendedKey = WalletUnlocked.fromExtendedKey;
  /**
   * Create a Wallet Unlocked from an encrypted JSON.
   *
   * @param jsonWallet - The encrypted JSON keystore.
   * @param password - The password to decrypt the JSON.
   * @param provider - A Provider instance (optional).
   * @returns An unlocked wallet instance.
   */
  static fromEncryptedJson = WalletUnlocked.fromEncryptedJson;
};

// src/test-utils/wallet-config.ts
var WalletsConfig = class _WalletsConfig {
  static {
    __name(this, "WalletsConfig");
  }
  initialState;
  options;
  wallets;
  generateWallets = /* @__PURE__ */ __name(() => {
    const generatedWallets = [];
    for (let index = 1; index <= this.options.count; index++) {
      generatedWallets.push(new WalletUnlocked(randomBytes8(32)));
    }
    return generatedWallets;
  }, "generateWallets");
  constructor(baseAssetId, config) {
    _WalletsConfig.validate(config);
    this.options = config;
    const { assets, coinsPerAsset, amountPerCoin, messages } = this.options;
    this.wallets = this.generateWallets();
    this.initialState = {
      messages: _WalletsConfig.createMessages(this.wallets, messages),
      coins: _WalletsConfig.createCoins(
        this.wallets,
        baseAssetId,
        assets,
        coinsPerAsset,
        amountPerCoin
      )
    };
  }
  apply(snapshotConfig) {
    return {
      ...snapshotConfig,
      stateConfig: {
        ...snapshotConfig?.stateConfig ?? defaultSnapshotConfigs2.stateConfig,
        coins: this.initialState.coins.concat(snapshotConfig?.stateConfig?.coins || []),
        messages: this.initialState.messages.concat(snapshotConfig?.stateConfig?.messages ?? [])
      }
    };
  }
  /**
   * Create messages for the wallets in the format that the chain expects.
   */
  static createMessages(wallets, messages) {
    return messages.map((msg) => wallets.map((wallet) => msg.toChainMessage(wallet.address))).flatMap((x) => x);
  }
  /**
   * Create coins for the wallets in the format that the chain expects.
   */
  static createCoins(wallets, baseAssetId, assets, coinsPerAsset, amountPerCoin) {
    const coins = [];
    let assetIds = [baseAssetId];
    if (Array.isArray(assets)) {
      assetIds = assetIds.concat(assets.map((a) => a.value));
    } else {
      assetIds = assetIds.concat(TestAssetId.random(assets - 1).map((a) => a.value));
    }
    wallets.map((wallet) => wallet.address.toHexString()).forEach((walletAddress) => {
      assetIds.forEach((assetId) => {
        for (let index = 0; index < coinsPerAsset; index++) {
          coins.push({
            amount: bn23(amountPerCoin).toString(),
            asset_id: assetId,
            owner: walletAddress,
            tx_pointer_block_height: 0,
            tx_pointer_tx_idx: 0,
            output_index: 0,
            tx_id: hexlify26(randomBytes8(32))
          });
        }
      });
    });
    return coins;
  }
  static validate({
    count: wallets,
    assets,
    coinsPerAsset,
    amountPerCoin
  }) {
    if (Array.isArray(wallets) && wallets.length === 0 || typeof wallets === "number" && wallets <= 0) {
      throw new FuelError27(
        FuelError27.CODES.INVALID_INPUT_PARAMETERS,
        "Number of wallets must be greater than zero."
      );
    }
    if (Array.isArray(assets) && assets.length === 0 || typeof assets === "number" && assets <= 0) {
      throw new FuelError27(
        FuelError27.CODES.INVALID_INPUT_PARAMETERS,
        "Number of assets per wallet must be greater than zero."
      );
    }
    if (coinsPerAsset <= 0) {
      throw new FuelError27(
        FuelError27.CODES.INVALID_INPUT_PARAMETERS,
        "Number of coins per asset must be greater than zero."
      );
    }
    if (bn23(amountPerCoin).lt(0)) {
      throw new FuelError27(
        FuelError27.CODES.INVALID_INPUT_PARAMETERS,
        "Amount per coin must be greater than or equal to zero."
      );
    }
  }
};

// src/test-utils/setup-test-provider-and-wallets.ts
var defaultWalletConfigOptions = {
  count: 2,
  assets: [TestAssetId.A, TestAssetId.B],
  coinsPerAsset: 1,
  amountPerCoin: 1e10,
  messages: []
};
async function setupTestProviderAndWallets({
  walletsConfig: walletsConfigOptions = {},
  providerOptions,
  nodeOptions = {},
  launchNodeServerPort = process.env.LAUNCH_NODE_SERVER_PORT || void 0
} = {}) {
  Symbol.dispose ??= Symbol("Symbol.dispose");
  const walletsConfig = new WalletsConfig(
    nodeOptions.snapshotConfig?.chainConfig?.consensus_parameters?.V2?.base_asset_id ?? defaultSnapshotConfigs3.chainConfig.consensus_parameters.V2.base_asset_id,
    {
      ...defaultWalletConfigOptions,
      ...walletsConfigOptions
    }
  );
  const launchNodeOptions = {
    loggingEnabled: false,
    ...nodeOptions,
    snapshotConfig: mergeDeepRight(
      defaultSnapshotConfigs3,
      walletsConfig.apply(nodeOptions?.snapshotConfig)
    ),
    port: nodeOptions.port || "0"
  };
  let killNode;
  let url;
  if (launchNodeServerPort) {
    const serverUrl = `http://localhost:${launchNodeServerPort}`;
    url = await (await fetch(serverUrl, { method: "POST", body: JSON.stringify(launchNodeOptions) })).text();
    killNode = /* @__PURE__ */ __name(() => {
      fetch(`${serverUrl}/cleanup/${url}`);
    }, "killNode");
  } else {
    const settings = await launchNode(launchNodeOptions);
    url = settings.url;
    killNode = settings.cleanup;
  }
  const cleanup = /* @__PURE__ */ __name(() => {
    Provider.clearChainAndNodeCaches(url);
    killNode();
  }, "cleanup");
  let provider;
  try {
    provider = new Provider(url, providerOptions);
  } catch (err) {
    cleanup();
    throw err;
  }
  const wallets = walletsConfig.wallets;
  wallets.forEach((wallet) => {
    wallet.connect(provider);
  });
  return {
    provider,
    wallets,
    cleanup,
    [Symbol.dispose]: cleanup
  };
}
__name(setupTestProviderAndWallets, "setupTestProviderAndWallets");

// src/test-utils/test-message.ts
import { Address as Address7 } from "@fuel-ts/address";
import { randomBytes as randomBytes9 } from "@fuel-ts/crypto";
import { bn as bn24 } from "@fuel-ts/math";
import { hexlify as hexlify27 } from "@fuel-ts/utils";
var TestMessage = class {
  static {
    __name(this, "TestMessage");
  }
  sender;
  recipient;
  nonce;
  amount;
  data;
  da_height;
  /**
   * A helper class to create messages for testing purposes.
   *
   * Used in tandem with `WalletsConfig`.
   * It can also be used standalone and passed into the initial state of a chain via the `.toChainMessage` method.
   */
  constructor({
    sender = Address7.fromRandom(),
    recipient = Address7.fromRandom(),
    nonce = hexlify27(randomBytes9(32)),
    amount = 1e6,
    data = "",
    // Will default to empty data in order to be a spendable message
    da_height = 0
  } = {}) {
    this.sender = sender;
    this.recipient = recipient;
    this.nonce = nonce;
    this.amount = amount;
    this.data = data;
    this.da_height = da_height;
  }
  toChainMessage(recipient) {
    const data = /^0x/.test(this.data) ? this.data.replace(/^0x/, "") : this.data;
    return {
      sender: this.sender.toB256(),
      recipient: recipient?.toB256() ?? this.recipient.toB256(),
      nonce: this.nonce,
      amount: bn24(this.amount).toNumber(),
      data,
      da_height: this.da_height
    };
  }
};
export {
  TestAssetId,
  TestMessage,
  WalletsConfig,
  launchNode,
  setupTestProviderAndWallets
};
//# sourceMappingURL=test-utils.mjs.map